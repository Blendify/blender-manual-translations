# SOME DESCRIPTIVE TITLE.
# Copyright (C) : This page is licensed under a CC-BY-SA 4.0 Int. License
# This file is distributed under the same license as the Blender 2.78 Manual
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Blender 2.78 Manual 2.78\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-01-12 16:43-0500\n"
"PO-Revision-Date: 1971-01-02 00:00+0000\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../../manual/compositing/types/converter/math.rst:9
msgid "Math Node"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:14
msgid "Math node."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:16
msgid "The *Math Node* performs math operations."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:20
msgid "Inputs"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:23
#: ../../manual/compositing/types/converter/math.rst:29
#: ../../manual/compositing/types/converter/math.rst:101
msgid "Value"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:23
msgid ""
"First numerical value. The trigonometric functions accept values in "
"radians."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:26
msgid ""
"Second numerical value. This value is **not** used in functions that "
"accept only one parameter like the trigonometric functions, Round and "
"Absolute."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:32
msgid "Properties"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:90
msgid "Operation"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:35
msgid ""
"Mathematical operation to use; see below for a list of supported "
"operations:"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:40
msgid "**Functions**"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:41
msgid "`Add <https://en.wikipedia.org/wiki/Addition>`__"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:42
msgid "`Subtract <https://en.wikipedia.org/wiki/Subtraction>`__"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:43
msgid "`Multiply <https://en.wikipedia.org/wiki/Multiplication>`__"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:44
msgid "`Divide <https://en.wikipedia.org/wiki/Division_(mathematics)>`__"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:45
#, python-format
msgid ""
"`Multiply Add "
"<https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation>`__"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:46
msgid "`Power <https://en.wikipedia.org/wiki/Exponential_function>`__"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:47
msgid "`Logarithm <https://en.wikipedia.org/wiki/Logarithm>`__"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:48
msgid "`Square Root <https://en.wikipedia.org/wiki/Square_root>`__"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:49
msgid "`Inverse Square Root <https://en.wikipedia.org/wiki/Square_root>`__"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:50
msgid "`Absolute <https://en.wikipedia.org/wiki/Absolute_value>`__"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:51
msgid "`Exponent <https://en.wikipedia.org/wiki/E_(mathematical_constant)>`__"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:53
msgid "**Comparison**"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:54
msgid "`Minimum <https://en.wikipedia.org/wiki/Maxima_and_minima>`__"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:55
msgid "`Maximum <https://en.wikipedia.org/wiki/Maxima_and_minima>`__"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:56
msgid "`Less Than <https://en.wikipedia.org/wiki/Inequality_(mathematics)>`__"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:57
msgid "`Greater Than <https://en.wikipedia.org/wiki/Inequality_(mathematics)>`__"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:58
msgid "`Sign <https://en.wikipedia.org/wiki/Sign_function>`__"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:59
msgid "`Compare <https://en.wikipedia.org/wiki/Comparison_function>`__"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:60
msgid "`Smooth Minimum <https://en.wikipedia.org/wiki/Smooth_maximum>`__"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:61
msgid "`Smooth Maximum <https://en.wikipedia.org/wiki/Smooth_maximum>`__"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:66
msgid "**Rounding**"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:67
msgid "`Round <https://en.wikipedia.org/wiki/Round_function>`__"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:68
msgid "`Floor <https://en.wikipedia.org/wiki/Floor_and_ceiling_functions>`__"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:69
msgid "`Ceil <https://en.wikipedia.org/wiki/Floor_and_ceiling_functions>`__"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:70
msgid "`Truncate <https://en.wikipedia.org/wiki/Truncation>`__"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:71
msgid "`Fraction <https://en.wikipedia.org/wiki/Rational_function>`__"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:72
msgid "`Modulo <https://en.wikipedia.org/wiki/Modulo_operation>`__"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:73
msgid "`Snap <https://en.wikipedia.org/wiki/Rounding>`__"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:74
msgid "`Wrap <https://en.wikipedia.org/wiki/Rounding>`__"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:75
msgid "`Pingpong <https://en.wikipedia.org/wiki/Rounding>`__"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:79
msgid "**Conversion**"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:80
msgid ""
"`To Radians "
"<https://en.wikipedia.org/wiki/Radian#Conversion_between_radians_and_degrees>`__"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:81
msgid ""
"`To Degrees "
"<https://en.wikipedia.org/wiki/Radian#Conversion_between_radians_and_degrees>`__"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:94
msgid "Clamp"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:93
msgid "Limits the output to the range (0 to 1). See :term:`clamp`."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:97
msgid "Outputs"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:100
msgid "Numerical value output."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:104
msgid "Examples"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:107
msgid "Manual Z-Mask"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:111
msgid "Minimum and maximum function example."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:113
msgid ""
"This example has one scene input by the top *Render Layers* node, which "
"has a cube that is about 10 units from the camera. The bottom *Render "
"Layers* node inputs a scene with a plane that covers the left half of the"
" view and is 7 units from the camera. Both are fed through their "
"respective *Map Value* nodes to divide the Z-buffer by 20 (multiply by "
"0.05, as shown in the Size field) and clamped to be a min/max of 0.0/1.0 "
"respectively."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:121
msgid ""
"For the minimum function, the node selects those Z values where the "
"corresponding pixel is closer to the camera; so it chooses the Z values "
"for the plane and part of the cube. The background has an infinite Z "
"value, so it is clamped to 1.0 (shown as white). In the maximum example, "
"the Z values of the cube are greater than the plane, so they are chosen "
"for the left side, but the plane *Render Layers* Z are infinite (mapped "
"to 1.0) for the right side, so they are chosen."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:131
msgid "Using Sine Function to Pulsate"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:135
msgid "Using sine function example."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:137
msgid ""
"This example has a *Time* node putting out a linear sequence from 0 to 1 "
"over the course of 101 frames. At frame 25, the output value is 0.25. "
"That value is multiplied by 2 × pi (6.28) and converted to 1.0 by the "
"Sine function, since we all know that :math:`sin(2 × pi/ 4) = sin(pi/ 2) "
"= +1.0`."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:142
msgid ""
"Since the sine function can put out values between (-1.0 to 1.0), the "
"*Map Value* node scales that to 0.0 to 1.0 by taking the input (-1 to 1),"
" adding 1 (making 0 to 2), and multiplying the result by one-half (thus "
"scaling the output between 0 to 1). The default *Color Ramp* converts "
"those values to a gray-scale. Thus, medium gray corresponds to a 0.0 "
"output by the sine, black to -1.0, and white to 1.0. As you can see, "
":math:`sin(pi/ 2) = 1.0`. Like having your own visual color calculator! "
"Animating this node setup provides a smooth cyclic sequence through the "
"range of grays."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:150
msgid ""
"Use this function to vary, for example, the alpha channel of an image to "
"produce a fading in/out effect. Alter the Z channel to move a scene "
"in/out of focus. Alter a color channel value to make a color \"pulse\"."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:157
msgid "Brightening (Scaling) a Channel"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:161
msgid "Scaling a channel example."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:163
msgid ""
"This example has a *Math (Multiply)* node increasing the luminance "
"channel (Y) of the image to make it brighter. Note that you should use a "
"*Map Value node* with min() and max() enabled to clamp the output to "
"valid values. With this approach, you could use a logarithmic function to"
" make a high dynamic range image. For this particular example, there is "
"also a *Bright/Contrast node* that might give simpler control over "
"brightness."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:172
msgid "Restrict Color Selection (Posterization)"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:176
msgid "Posterization example."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:178
msgid ""
"In this example, we restrict the color values to be one of the six "
"values: 0, 0.2, 0.4, 0.6, 0.8, 1."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:180
msgid ""
"To split up a continuous range of values between 0 and 1 to certain set "
"of values, the following function is used: :math:`round(x × n - 0.5) / (n"
" - 1)`, where \"n\" is the number of possible output values, and \"x\" is"
" the input pixel color. `Read more about this function "
"<https://en.blender.org/index.php/Doc:2.4/Manual/Composite_Nodes/Types/Convertor#Quantize.2FRestrict_Color_Selection>`__."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:186
msgid ""
"To implement this function in Blender, consider the node setup above. We "
"string the Math nodes into a function that takes each color (values from "
"0 to 1), multiplies it up by six, the desired number of divisions (values"
" become from 0 to 6), offsets it by 0.5 (-0.5 to 5.5), rounds the value "
"to the nearest whole number (produces 0, 1, 2, 3, 4, 5), and then divides"
" the image pixel color by five (0.0, 0.2, 0.4, 0.6, 0.8, 1.0)."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:193
msgid ""
"In the case of a color image, you need split it into separate RGB "
"channels using *Separate/Combine RGBA* nodes and perform this operation "
"on each channel independently."
msgstr ""

#~ msgid ""
#~ "An algebraic function is made up "
#~ "of primitive mathematical operations (add, "
#~ "subtract, multiply, sine, cosine, etc) "
#~ "that operate on an input value to"
#~ " provide the desired output value."
#~ msgstr ""

#~ msgid ""
#~ "So, to get good even shading, we"
#~ " want to take values that are "
#~ "0.16 or less and map them to "
#~ "0.0; values between 0.16 and 0.33 "
#~ "get fixed to 0.2; color band "
#~ "values between 0.33 and 0.5 get "
#~ "quantized to 0.4, and so on up "
#~ "to values between 0.83 and 1.0 get"
#~ " mapped to 1.0."
#~ msgstr ""

#~ msgid ""
#~ "The ``JPG`` or ``PNG`` image format "
#~ "will store each of the colors "
#~ "according to their image standard for"
#~ " color depth (e.g. ``JPG`` is "
#~ "24-bit), but the image will be "
#~ "very small since reducing color depth"
#~ " and quantizing colors are essentially "
#~ "what the ``JPEG`` compression algorithm "
#~ "accomplishes."
#~ msgstr ""

#~ msgid ""
#~ "Since there are three channels and "
#~ "256 values, we have some flexibility "
#~ "how to quantize each channel, since "
#~ "there are a lot of combinations of"
#~ " R × G × B that would "
#~ "equal 256. For example, if {R, G,"
#~ " B} = {4, 4, 16}, then :math:`4"
#~ " × 4 × 16 = 256`. Also, "
#~ "{6, 6, 7} would give 252 possible"
#~ " values. The difference in appearance "
#~ "between {4, 4, 16} and {6, 6, "
#~ "7} is that the first set (4, "
#~ "4, 16} would have fewer shades of"
#~ " red and green, but lots of "
#~ "shades of blue. The set {6, 6, "
#~ "7} would have a more even "
#~ "distribution of colors. To get better"
#~ " image quality with fewer color "
#~ "values, give possible values to the "
#~ "predominant colors in the image."
#~ msgstr ""

#~ msgid ""
#~ "This example has a *Time* node "
#~ "putting out a linear sequence from "
#~ "0 to 1 over the course of "
#~ "101 frames. The green vertical line "
#~ "in the curve widget shows that "
#~ "frame 25 is being put out, or "
#~ "a value of 0.25. That value is "
#~ "multiplied by 2 × pi and converted"
#~ " to 1.0 by the Sine function, "
#~ "since we all know that :math:`sin(2 "
#~ "× pi/ 4) = sin(pi/ 2) = "
#~ "+1.0` Since the sine function can "
#~ "put out values between (-1.0 to "
#~ "1.0), the *Map Value* node scales "
#~ "that to 0.0 to 1.0 by taking "
#~ "the input (-1 to 1), adding 1 "
#~ "(making 0 to 2), and multiplying "
#~ "the result by one-half (thus "
#~ "scaling the output between 0 to "
#~ "1). The default *Color Ramp* converts"
#~ " those values to a grayscale. Thus,"
#~ " medium gray corresponds to a 0.0 "
#~ "output by the sine, black to -1.0,"
#~ " and white to 1.0. As you can"
#~ " see, :math:`sin(pi/ 2) = 1.0`. Like"
#~ " having your own visual color "
#~ "calculator! Animating this node setup "
#~ "provides a smooth cyclic sequence "
#~ "through the range of grays."
#~ msgstr ""

#~ msgid ""
#~ "This example has one scene input "
#~ "by the top *Render Layer* node, "
#~ "which has a cube that is about "
#~ "10 BU from the camera. The bottom"
#~ " Render Layer node inputs a scene "
#~ "(FlyCam) with a plane that covers "
#~ "the left half of the view and "
#~ "is 7 BU from the camera. Both "
#~ "are fed through their respective Map "
#~ "Value nodes to divide the Z buffer"
#~ " by 20 (multiply by 0.05, as "
#~ "shown in the Size field) and "
#~ "clamped to be a min/ max of "
#~ "0.0/ 1.0 respectively."
#~ msgstr ""

#~ msgid ""
#~ "This example has a *Time* node "
#~ "putting out a linear sequence from "
#~ "0 to 1 over the course of "
#~ "101 frames. The green vertical line "
#~ "in the curve widget shows that "
#~ "frame 25 is being put out, or "
#~ "a value of 0.25. That value is "
#~ "multiplied by 2 × pi and converted"
#~ " to 1.0 by the Sine function, "
#~ "since we all know that :math:`sin(2 "
#~ "× pi/ 4) = sin(pi/ 2) = "
#~ "+1.0`. Since the sine function can "
#~ "put out values between (-1.0 to "
#~ "1.0), the *Map Value* node scales "
#~ "that to 0.0 to 1.0 by taking "
#~ "the input (-1 to 1), adding 1 "
#~ "(making 0 to 2), and multiplying "
#~ "the result by one-half (thus "
#~ "scaling the output between 0 to "
#~ "1). The default *Color Ramp* converts"
#~ " those values to a grayscale. Thus,"
#~ " medium gray corresponds to a 0.0 "
#~ "output by the sine, black to -1.0,"
#~ " and white to 1.0. As you can"
#~ " see, :math:`sin(pi/ 2) = 1.0`. Like"
#~ " having your own visual color "
#~ "calculator! Animating this node setup "
#~ "provides a smooth cyclic sequence "
#~ "through the range of grays."
#~ msgstr ""

#~ msgid ""
#~ "This example has a *Math: Multiply* "
#~ "node increasing the luminance channel "
#~ "(Y) of the image to make it "
#~ "brighter. Note that you should use "
#~ "a *Map Value node* with min() and"
#~ " max() enabled to clamp the output"
#~ " to valid values. With this approach,"
#~ " you could use a logarithmic function"
#~ " to make a high-dynamic range "
#~ "image. For this particular example, "
#~ "there is also a *Brighten/Contrast node*"
#~ " that might give simpler control over"
#~ " brightness."
#~ msgstr ""

#~ msgid ""
#~ "You can use this node setup to "
#~ "quantize any channel; alpha, speed "
#~ "(vector), z-values, and so forth."
#~ msgstr ""

#~ msgid ""
#~ "This example has one scene input "
#~ "by the top *Render Layer* node, "
#~ "which has a cube that is about "
#~ "10 BU from the camera. The bottom"
#~ " Render Layer node inputs a scene "
#~ "(FlyCam) with a plane that covers "
#~ "the left half of the view and "
#~ "is 7 BU from the camera. Both "
#~ "are fed through their respective Map "
#~ "Value nodes to divide the Z-buffer "
#~ "by 20 (multiply by 0.05, as shown"
#~ " in the Size field) and clamped "
#~ "to be a min/ max of 0.0/ 1.0"
#~ " respectively."
#~ msgstr ""

#~ msgid "Example."
#~ msgstr ""

#~ msgid ""
#~ "This example has one scene input "
#~ "by the top *Render Layer* node, "
#~ "which has a cube that is about "
#~ "10 BU from the camera. The bottom"
#~ " Render Layer node inputs a scene "
#~ "(FlyCam) with a plane that covers "
#~ "the left half of the view and "
#~ "is 7 BU from the camera. Both "
#~ "are fed through their respective Map "
#~ "Value nodes to divide the Z-buffer "
#~ "by 20 (multiply by 0.05, as shown"
#~ " in the Size field) and clamped "
#~ "to be a min/max of 0.0/1.0 "
#~ "respectively."
#~ msgstr ""

#~ msgid ""
#~ "For the minimum function, the node "
#~ "selects those Z values where the "
#~ "corresponding pixel is closer to the "
#~ "camera; so it chooses the Z values"
#~ " for the plane and part of the"
#~ " cube. The background has an infinite"
#~ " Z value, so it is clamped to"
#~ " 1.0 (shown as white). In the "
#~ "maximum example, the Z values of "
#~ "the cube are greater than the "
#~ "plane, so they are chosen for the"
#~ " left side, but the plane (FlyCam)"
#~ " Render layers Z are infinite (mapped"
#~ " to 1.0) for the right side, so"
#~ " they are chosen."
#~ msgstr ""

#~ msgid ""
#~ "This example has a *Time* node "
#~ "putting out a linear sequence from "
#~ "0 to 1 over the course of "
#~ "101 frames. The green vertical line "
#~ "in the curve widget shows that "
#~ "frame 25 is being put out, or "
#~ "a value of 0.25. That value is "
#~ "multiplied by 2 × pi and converted"
#~ " to 1.0 by the Sine function, "
#~ "since we all know that :math:`sin(2 "
#~ "× pi/ 4) = sin(pi/ 2) = "
#~ "+1.0`. Since the sine function can "
#~ "put out values between (-1.0 to "
#~ "1.0), the *Map Value* node scales "
#~ "that to 0.0 to 1.0 by taking "
#~ "the input (-1 to 1), adding 1 "
#~ "(making 0 to 2), and multiplying "
#~ "the result by one-half (thus "
#~ "scaling the output between 0 to "
#~ "1). The default *Color Ramp* converts"
#~ " those values to a gray-scale. "
#~ "Thus, medium gray corresponds to a "
#~ "0.0 output by the sine, black to"
#~ " -1.0, and white to 1.0. As you"
#~ " can see, :math:`sin(pi/ 2) = 1.0`."
#~ " Like having your own visual color"
#~ " calculator! Animating this node setup "
#~ "provides a smooth cyclic sequence "
#~ "through the range of grays."
#~ msgstr ""

#~ msgid "Brightening/Scaling a Channel"
#~ msgstr ""

#~ msgid ""
#~ "This example has a *Math: Multiply* "
#~ "node increasing the luminance channel "
#~ "(Y) of the image to make it "
#~ "brighter. Note that you should use "
#~ "a *Map Value node* with min() and"
#~ " max() enabled to clamp the output"
#~ " to valid values. With this approach,"
#~ " you could use a logarithmic function"
#~ " to make a high dynamic range "
#~ "image. For this particular example, "
#~ "there is also a *Brighten/Contrast node*"
#~ " that might give simpler control over"
#~ " brightness."
#~ msgstr ""

#~ msgid "Quantize/Restrict Color Selection"
#~ msgstr ""

#~ msgid ""
#~ "In this example, we want to "
#~ "restrict the color output to only "
#~ "256 possible values. Possible use of "
#~ "this is to see what the image "
#~ "will look like on an 8-bit cell"
#~ " phone display. To do this, we "
#~ "want to restrict the R, G and "
#~ "B values of any pixel to be "
#~ "one of a certain value, such that"
#~ " when they are combined, will not "
#~ "result in more than 256 possible "
#~ "values. The number of possible values"
#~ " of an output is the number of"
#~ " channel values multiplied by each "
#~ "other, or Q = R × G × "
#~ "B."
#~ msgstr ""

#~ msgid ""
#~ "Since there are three channels and "
#~ "256 values, we have some flexibility "
#~ "how to quantize each channel, since "
#~ "there are a lot of combinations of"
#~ " R × G × B that would "
#~ "equal 256. For example, if {R, G,"
#~ " B} = {4, 4, 16}, then :math:`4"
#~ " × 4 × 16 = 256`. Also, "
#~ "{6, 6, 7} would give 252 possible"
#~ " values. The difference in appearance "
#~ "between {4, 4, 16} and {6, 6, "
#~ "7} is that the first set {4, "
#~ "4, 16} would have fewer shades of"
#~ " red and green, but lots of "
#~ "shades of blue. The set {6, 6, "
#~ "7} would have a more even "
#~ "distribution of colors. To get better"
#~ " image quality with fewer color "
#~ "values, give possible values to the "
#~ "predominant colors in the image."
#~ msgstr ""

#~ msgid "Theory"
#~ msgstr ""

#~ msgid ""
#~ "`Two Approaches to Quantizing to six "
#~ "values <https://wiki.blender.org/index.php/File:Manual-"
#~ "Compositing-Node-Math_ColorBand>`__."
#~ msgstr ""

#~ msgid ""
#~ "To accomplish this quantization of an"
#~ " image to 256 possible values, let"
#~ " us use the set {6, 6, 7}. "
#~ "To split up a continuous range of"
#~ " values between 0 and 1 (the "
#~ "full Red spectrum) into six values, "
#~ "we need to construct an algorithm "
#~ "or function that takes any input "
#~ "value but only puts out six "
#~ "possible values, as illustrated by the"
#~ " image to the right. We want to"
#~ " include zero as true black, with "
#~ "five other colors in between. The "
#~ "approach shown produces {0, 0.2, 0.4,"
#~ " 0.6, 0.8, 1}. Dividing 1.0 by "
#~ "5 equals 0.2, which tells how far"
#~ " apart each quantified value is from"
#~ " the other."
#~ msgstr ""

#~ msgid ""
#~ "So, to get good even shading, we"
#~ " want to take values that are "
#~ "0.16 or less and map them to "
#~ "0.0; values between 0.16 and 0.33 "
#~ "get fixed to 0.2; color values "
#~ "between 0.33 and 0.5 get quantized "
#~ "to 0.4, and so on up to "
#~ "values between 0.83 and 1.0 get "
#~ "mapped to 1.0."
#~ msgstr ""

#~ msgid "Function f(x)"
#~ msgstr ""

#~ msgid ""
#~ "An algebraic function is made up "
#~ "of primitive mathematical operations (add, "
#~ "subtract, multiply, sine, cosine, etc.) "
#~ "that operate on an input value to"
#~ " provide the desired output value."
#~ msgstr ""

#~ msgid ""
#~ "`Spreadsheet showing a function "
#~ "<https://wiki.blender.org/index.php/File:Manual-Compositing-"
#~ "Node-Math_spreadsheet>`__."
#~ msgstr ""

#~ msgid ""
#~ "The theory behind this function is "
#~ "scaled truncation. Suppose we want a "
#~ "math function that takes in a "
#~ "range of values between 0 and 1,"
#~ " such as 0.552, but only outputs "
#~ "a value of 0.0, 0.2, 0.4, etc. "
#~ "We can imagine then that we need"
#~ " to get that range 0 to 1 "
#~ "powered up to something 0 to 6 "
#~ "so that we can chop off and "
#~ "make it a whole number. So, with"
#~ " six divisions, how can we do "
#~ "that? The answer is we multiply "
#~ "the range by 6. The output of "
#~ "that first math Multiply Node is a"
#~ " range of values between 0 and "
#~ "6. To get even divisions, because "
#~ "we are using the rounding function "
#~ "(see documentation above), we want any"
#~ " number plus or minus around a "
#~ "whole number will get rounded to "
#~ "that number. So, we subtract a "
#~ "half, which shifts everything over. The"
#~ " round() function then makes that "
#~ "range 0 to 5. We then divide "
#~ "by 5 to get back a range of"
#~ " numbers between 0 and 1 which "
#~ "can then be combined back with the"
#~ " other color channels. Thus, you get"
#~ " the function :math:`f(x, n) = "
#~ "round(x × n - 0.5)/ (n - 1)`"
#~ " where \"n\" is the number of "
#~ "possible output values, and \"x\" is "
#~ "the input pixel color and :math:`f(x,"
#~ " n)` is the output value. There "
#~ "is only one slight problem, and "
#~ "that is for the value exactly "
#~ "equal to 1, the formula result is"
#~ " 1.2, which is an invalid value. "
#~ "This is because the round function "
#~ "is actually a roundup function, and "
#~ "exactly 5.5 is rounded up to 6."
#~ " So, by subtracting 0.501, we "
#~ "compensate and thus 5. 499 is "
#~ "rounded to 5. At the other end "
#~ "of the spectrum, pure black, or 0,"
#~ " when 0.501 subtracted, rounds up to"
#~ " 0 since the Round() function does"
#~ " not return a negative number."
#~ msgstr ""

#~ msgid ""
#~ "Sometimes using a spreadsheet can help"
#~ " you figure out how to put "
#~ "these nodes together to get the "
#~ "result that you want. Stepping you "
#~ "through the formula for :math:`n = "
#~ "6` and :math:`x = 0.70`, locate "
#~ "the line on the spreadsheet that "
#~ "has the 8-bit value 179 and R "
#~ "value 0.7. Multiplying by 6 gives "
#~ "4.2. Subtracting 1/2 gives 3.7, which"
#~ " rounds up to 4.4 divided by 5"
#~ " = 0.8. Thus, f(0.7, 6) = 0.8"
#~ " or an 8-bit value of 204. You"
#~ " can see that this same 8-bit "
#~ "value is output for a range of "
#~ "input values."
#~ msgstr ""

#~ msgid "Reality"
#~ msgstr ""

#~ msgid ""
#~ "To implement this function in Blender,"
#~ " consider the node setup above. "
#~ "First, feed the image to the "
#~ "Separate RGB node. For the Red "
#~ "channel, we string the math nodes "
#~ "into a function that takes each "
#~ "red color, multiplies (scales) it up "
#~ "by the desired number of divisions "
#~ "(6), offsets it by 0.5, rounds the"
#~ " value to the nearest whole number,"
#~ " and then divides the image pixel "
#~ "color by 5. So, the transformation "
#~ "is {0 to 1} becomes {0 to "
#~ "6}, subtracting centers the medians to"
#~ " {-0.5 to 5.5} and the rounding "
#~ "to the nearest whole number produces "
#~ "{0, 1, 2, 3, 4, 5} since the"
#~ " function rounds down, and then "
#~ "dividing by five results in six "
#~ "values {0.0, 0.2, 0.4, 0.6, 0.8, "
#~ "1.0}."
#~ msgstr ""

#~ msgid ""
#~ "The result is that the output "
#~ "value can only be one of a "
#~ "certain set of values, stair-stepped,"
#~ " because of the rounding function of"
#~ " the math node. Copying this one "
#~ "channel to operate on Green and "
#~ "Blue gives the node setup below. "
#~ "To get the 6:6:7, we set the "
#~ "three Multiply Nodes to {6, 6, 7}"
#~ " and the divide nodes to {5, 5,"
#~ " 6}."
#~ msgstr ""

#~ msgid ""
#~ "If you make this into a node "
#~ "group, you can easily reuse this "
#~ "setup from project to project. When "
#~ "you do, consider using a math node"
#~ " to drive the different values that"
#~ " you would have to otherwise set "
#~ "manually, just to error-proof your "
#~ "work."
#~ msgstr ""

#~ msgid "Summary"
#~ msgstr ""

#~ msgid ""
#~ "Normally, an output render consists of"
#~ " 32- or 24-bit color depth, and "
#~ "each pixel can be one of the "
#~ "millions of possible colors. This node"
#~ " setup example takes each of the "
#~ "Red, Green and Blue channels and "
#~ "normalizes them to one of a few"
#~ " values. When all three channels are"
#~ " combined back together, each color "
#~ "can only be one of 256 possible"
#~ " values."
#~ msgstr ""

#~ msgid ""
#~ "While this example uses the "
#~ "Separate/Combine RGB to create distinct "
#~ "colors, other Separate/Combine nodes can "
#~ "be used as well. If using the "
#~ "YUV values, remember that U and V"
#~ " vary between (-0.5 to +0.5), so "
#~ "you will have to first add on "
#~ "a half to bring the range between"
#~ " 0 and 1, and then after "
#~ "dividing, subtract a half to bring "
#~ "in back into standard range."
#~ msgstr ""

#~ msgid ""
#~ "The ``JPG`` or ``PNG`` image format "
#~ "will store each of the colors "
#~ "according to its image standard for "
#~ "color depth (e.g. ``JPG`` is 24-bit),"
#~ " but the image will be very "
#~ "small since reducing color depth and "
#~ "quantizing colors are essentially what "
#~ "the ``JPEG`` compression algorithm "
#~ "accomplishes."
#~ msgstr ""

#~ msgid ""
#~ "You do not have to reduce the "
#~ "color depth of each channel evenly. "
#~ "For example, if blue was the "
#~ "dominant color in an image, to "
#~ "preserve image quality, you could reduce"
#~ " Red to 2 values, Green to 4,"
#~ " and let the blue take on "
#~ ":math:`256/(2 × 4)` or 32 values. "
#~ "If using the HSV, you could reduce"
#~ " the Saturation and Value to 2 "
#~ "values (0 or 1.0) by Multiply by"
#~ " 2 and Divide by 2, and "
#~ "restrict the Hue to 64 possible "
#~ "values."
#~ msgstr ""

#~ msgid ""
#~ "You can use this node setup to "
#~ "quantize any channel; alpha, speed "
#~ "(vector), Z values, and so forth."
#~ msgstr ""

#~ msgid ""
#~ "Add, Subtract, Multiply, Divide, Sine, "
#~ "Cosine, Tangent, Arcsine, Arccosine, "
#~ "Arctangent, Power, Logarithm, Minimum, "
#~ "Maximum, Round, Less Than, Greater Than,"
#~ " Modulo, Absolute."
#~ msgstr ""

#~ msgid ""
#~ "To implement this function in Blender,"
#~ " consider the node setup above. We"
#~ " string the math nodes into a "
#~ "function that takes each color (values"
#~ " from 0 to 1), multiplies it up"
#~ " by six, the desired number of "
#~ "divisions (values becomes from 0 to "
#~ "6), offsets it by 0.5 (-0.5 to "
#~ "5.5), rounds the value to the "
#~ "nearest whole number (produces 0, 1, "
#~ "2, 3, 4, 5), and then divides "
#~ "the image pixel color by five "
#~ "(0.0, 0.2, 0.4, 0.6, 0.8, 1.0)."
#~ msgstr ""

#~ msgid ""
#~ "This example has one scene input "
#~ "by the top *Render Layers* node, "
#~ "which has a cube that is about "
#~ "10 BU from the camera. The bottom"
#~ " *Render Layers* node inputs a scene"
#~ " with a plane that covers the "
#~ "left half of the view and is "
#~ "7 BU from the camera. Both are "
#~ "fed through their respective *Map Value*"
#~ " nodes to divide the Z-buffer by "
#~ "20 (multiply by 0.05, as shown in"
#~ " the Size field) and clamped to "
#~ "be a min/max of 0.0/1.0 respectively."
#~ msgstr ""

#~ msgid ""
#~ "To implement this function in Blender,"
#~ " consider the node setup above. We"
#~ " string the math nodes into a "
#~ "function that takes each color (values"
#~ " from 0 to 1), multiplies it up"
#~ " by six, the desired number of "
#~ "divisions (values become from 0 to "
#~ "6), offsets it by 0.5 (-0.5 to "
#~ "5.5), rounds the value to the "
#~ "nearest whole number (produces 0, 1, "
#~ "2, 3, 4, 5), and then divides "
#~ "the image pixel color by five "
#~ "(0.0, 0.2, 0.4, 0.6, 0.8, 1.0)."
#~ msgstr ""

#~ msgid ""
#~ "Add, Subtract, Multiply, Divide, Sine, "
#~ "Cosine, Tangent, Arcsine, Arccosine, "
#~ "Arctangent, Arctangent2, Power, Logarithm, "
#~ "Minimum, Maximum, Round, Less Than, "
#~ "Greater Than, Modulo, Absolute"
#~ msgstr ""

