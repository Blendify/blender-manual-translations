# SOME DESCRIPTIVE TITLE.
# Copyright (C) : This page is public domain as CC0
# This file is distributed under the same license as the Blender Reference
# Manual package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
# phan <phahoatho@gmail.com>, 2017, 2018.
#
msgid ""
msgstr ""
"Project-Id-Version: Blender Reference Manual 2.76\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-07-05 13:47-0400\n"
"PO-Revision-Date: 2018-07-15 14:41+0200\n"
"Last-Translator: phan <phahoatho@gmail.com>\n"
"Language-Team: français <bf-docboard@blender.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Gtranslator 2.91.6\n"

#: ../../manual/compositing/types/converter/math.rst:11
msgid "Math Node"
msgstr "Node Math"

#: ../../manual/compositing/types/converter/math.rst:16
msgid "Math node."
msgstr "Node Math."

#: ../../manual/compositing/types/converter/math.rst:18
msgid "The *Math Node* performs math operations."
msgstr "Le *Node Math* effectue des opérations mathématiques."

#: ../../manual/compositing/types/converter/math.rst:22
msgid "Inputs"
msgstr "Entrées"

#: ../../manual/compositing/types/converter/math.rst:25
#: ../../manual/compositing/types/converter/math.rst:31
#: ../../manual/compositing/types/converter/math.rst:48
msgid "Value"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:25
msgid ""
"First numerical value. The trigonometric functions accept values in radians."
msgstr ""
"Première valeur numérique. Les fonctions trigonométriques acceptent des "
"valeurs en radians."

#: ../../manual/compositing/types/converter/math.rst:28
msgid ""
"Second numerical value. This value is **not** used in functions that accept "
"only one parameter like the trigonometric functions, Round and Absolute."
msgstr ""
"Seconde valeur numérique. Cette valeur n'est **pas** utilisée dans les "
"fonctions qui acceptent seulement un paramètre  comme les fonctions "
"trigonométriques, Round et Absolute."

#: ../../manual/compositing/types/converter/math.rst:34
msgid "Properties"
msgstr "Propriétés"

#: ../../manual/compositing/types/converter/math.rst:37
msgid "Operation"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:37
msgid ""
"Add, Subtract, Multiply, Divide, Sine, Cosine, Tangent, Arcsine, Arccosine, "
"Arctangent, Power, Logarithm, Minimum, Maximum, Round, Less Than, Greater "
"Than, Modulo, Absolute."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:41
msgid "Clamp"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:40
msgid "Limits the output to the range (0 to 1). See :term:`clamp`."
msgstr "Borde la sortie dasn l'intervalle (0 à 1). Voir :term:`clamp`."

#: ../../manual/compositing/types/converter/math.rst:44
msgid "Outputs"
msgstr "Sorties"

#: ../../manual/compositing/types/converter/math.rst:47
msgid "Numerical value output."
msgstr "Sortie de valeur numérique."

#: ../../manual/compositing/types/converter/math.rst:51
msgid "Examples"
msgstr "Exemples"

#: ../../manual/compositing/types/converter/math.rst:54
msgid "Manual Z-Mask"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:58
msgid "Minimum and maximum function example."
msgstr "Exemple de fonctions minimum et maximum."

#: ../../manual/compositing/types/converter/math.rst:60
msgid ""
"This example has one scene input by the top *Render Layers* node, which has "
"a cube that is about 10 BU from the camera. The bottom *Render Layers* node "
"inputs a scene with a plane that covers the left half of the view and is 7 "
"BU from the camera. Both are fed through their respective *Map Value* nodes "
"to divide the Z-buffer by 20 (multiply by 0.05, as shown in the Size field) "
"and clamped to be a min/max of 0.0/1.0 respectively."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:68
#, fuzzy
msgid ""
"For the minimum function, the node selects those Z values where the "
"corresponding pixel is closer to the camera; so it chooses the Z values for "
"the plane and part of the cube. The background has an infinite Z value, so "
"it is clamped to 1.0 (shown as white). In the maximum example, the Z values "
"of the cube are greater than the plane, so they are chosen for the left "
"side, but the plane *Render Layers* Z are infinite (mapped to 1.0) for the "
"right side, so they are chosen."
msgstr ""
"Pour la fonction *minimum*, le node sélectionne ces valeurs Z où le pixel "
"correspondant est plus proche de la caméra ; ainsi il choisit les valeurs Z "
"pour le plan et une partie du cube. L'arrière-plan a une valeur Z infinie, "
"aussi il est à 1.0 (affiché en blanc). Dans l'exemple *maximum*, les valeurs "
"Z du cube sont supérieures à celles du plan, aussi elles sont choisies pour "
"le côté gauche, mais le plan (FlyCam) sont infinies (correspond à 1.0) pour "
"le côté droit, raison pour laquelle elles sont choisies."

#: ../../manual/compositing/types/converter/math.rst:78
msgid "Using Sine Function to Pulsate"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:82
msgid "Using sine function example."
msgstr "Exemple d'utilisation de la fonction Sine (Sinus)."

#: ../../manual/compositing/types/converter/math.rst:84
msgid ""
"This example has a *Time* node putting out a linear sequence from 0 to 1 "
"over the course of 101 frames. At frame 25, the output value is 0.25. That "
"value is multiplied by 2 × pi (6.28) and converted to 1.0 by the Sine "
"function, since we all know that :math:`sin(2 × pi/ 4) = sin(pi/ 2) = +1.0`."
msgstr ""
"Cet exemple a un node *Time* sortant une séquence linéaire de 0 à 1 au cours "
"de 101 trames. À la trame 25, la valeur est de 0.25. Cette valeur est "
"multipliée par 2 x pi (6.28) et convertie à 1.0 par la fonction Sine "
"(sinus), car nous savons tous que :math:`sin(2 × pi/ 4) = sin(pi/ 2) = +1.0`."

#: ../../manual/compositing/types/converter/math.rst:89
msgid ""
"Since the sine function can put out values between (-1.0 to 1.0), the *Map "
"Value* node scales that to 0.0 to 1.0 by taking the input (-1 to 1), adding "
"1 (making 0 to 2), and multiplying the result by one-half (thus scaling the "
"output between 0 to 1). The default *Color Ramp* converts those values to a "
"gray-scale. Thus, medium gray corresponds to a 0.0 output by the sine, black "
"to -1.0, and white to 1.0. As you can see, :math:`sin(pi/ 2) = 1.0`. Like "
"having your own visual color calculator! Animating this node setup provides "
"a smooth cyclic sequence through the range of grays."
msgstr ""
"Puisque la fonction Sine (sinus) peut sortir des valeurs entre (-1.0 à 1.0), "
"le node *Map Value* met cela à l'échelle (0.0 à 1.0) en prenant l'entrée (-1 "
"à 1), en ajoutant 1  (0 à 2), et en multipliant le résultat par un demi "
"(mettant ainsi à l'échelle la sortie entre 0 à 1). Le *Color Ramp* par "
"défaut convertit ces valeurs en une échelle de gris. Ainsi, le gris moyen "
"correspond à une sortie de 0.0 par le sinus, le noir à -1.0, et le blanc à "
"1.0. Comme vous pouvez le voir, :math:`sin(pi/ 2) = 1.0`. C'est comme avoir "
"votre propre machine à calculer en couleur visuelle ! L'animation de cette "
"configuration de nodes offre une séquence cyclique lisse à travers une "
"palette de gris. "

#: ../../manual/compositing/types/converter/math.rst:97
msgid ""
"Use this function to vary, for example, the alpha channel of an image to "
"produce a fading in/out effect. Alter the Z channel to move a scene in/out "
"of focus. Alter a color channel value to make a color \"pulse\"."
msgstr ""
"Utilisez cette fonction pour varier, par exemple, le canal alpha d'une image "
"pour produire un effet de fusion . Modifiez le canal Z pour déplacer une "
"scène dans/hors du focus. Modifiez une valeur de canal de couleur pour faire "
"une \"pulsation\" de couleur."

#: ../../manual/compositing/types/converter/math.rst:104
msgid "Brightening (Scaling) a Channel"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:108
msgid "Scaling a channel example."
msgstr "Exemple de mise à l'échelle d'un canal."

#: ../../manual/compositing/types/converter/math.rst:110
msgid ""
"This example has a *Math (Multiply)* node increasing the luminance channel "
"(Y) of the image to make it brighter. Note that you should use a *Map Value "
"node* with min() and max() enabled to clamp the output to valid values. With "
"this approach, you could use a logarithmic function to make a high dynamic "
"range image. For this particular example, there is also a *Bright/Contrast "
"node* that might give simpler control over brightness."
msgstr ""
"Cet exemple a un node *Math: Multiply* augmentant le canal luminance (Y) de "
"l'image pour la rendre plus claire. Notez que vous devriez utiliser un node "
"*Map Value* avec min() et max() activés pour borner la sortie aux valeurs "
"valides. Avec cette approche, vous pourriez utiliser une fonction "
"logarithmique pour construire une image à palette hautement dynamique. Pour "
"cet exemple particulier, il y a aussi un node *Bright/Contrast* qui pourrait "
"offrir un contrôle plus simple sur la luminosité."

#: ../../manual/compositing/types/converter/math.rst:119
msgid "Restrict Color Selection (Posterization)"
msgstr "Restriction de la sélection de couleur (postérisation)"

#: ../../manual/compositing/types/converter/math.rst:123
msgid "Posterization example."
msgstr "Exemple de postérisation."

#: ../../manual/compositing/types/converter/math.rst:125
msgid ""
"In this example, we restrict the color values to be one of the six values: "
"0, 0.2, 0.4, 0.6, 0.8, 1."
msgstr ""
"Dans cet exemple, nous restreignons les couleurs à 6 valeurs : 0, 0.2, 0.4, "
"0.6, 0.8, 1."

#: ../../manual/compositing/types/converter/math.rst:127
msgid ""
"To split up a continuous range of values between 0 and 1 to certain set of "
"values, the following function is used: :math:`round(x × n - 0.5) / (n - "
"1)`, where \"n\" is the number of possible output values, and \"x\" is the "
"input pixel color. `Read more about this function <https://en.blender.org/"
"index.php/Doc:2.4/Manual/Composite_Nodes/Types/"
"Convertor#Quantize.2FRestrict_Color_Selection>`__."
msgstr ""
"Pour diviser un intervalle continu de valeurs entre 0 et 1 en une ensemble "
"de valeurs, la fonction suivante est utilisée : :math:`round(x × n - 0.5) / "
"(n - 1)`, où \"n\" est le nombre de valeurs possibles de sortie, et \"x\" "
"est la couleur de pixel d'entrée. `Plus sur cette fonction <https://en."
"blender.org/index.php/Doc:2.4/Manual/Composite_Nodes/Types/"
"Convertor#Quantize.2FRestrict_Color_Selection>`__. "

#: ../../manual/compositing/types/converter/math.rst:133
msgid ""
"To implement this function in Blender, consider the node setup above. We "
"string the math nodes into a function that takes each color (values from 0 "
"to 1), multiplies it up by six, the desired number of divisions (values "
"becomes from 0 to 6), offsets it by 0.5 (-0.5 to 5.5), rounds the value to "
"the nearest whole number (produces 0, 1, 2, 3, 4, 5), and then divides the "
"image pixel color by five (0.0, 0.2, 0.4, 0.6, 0.8, 1.0)."
msgstr ""
"Pour implémenter cette fonction dans Blender, considérez la configuration de "
"nodes ci-dessus. Nous enchaînons les nodes math dans une fonction qui prend "
"chaque couleur (valeurs de 0 à 1), la multiplie par six, le nombre souhaité "
"de divisions (les valeurs deviennent de 0 à 6), le décale de 0.5 (-0.5 à "
"5.5), arrondit la valeur au nombre entier le plus proche (produit 0, 1, 2, "
"3, 4, 5), et enfin divise la couleur de pixel d'image par cinq (0.0, 0.2, "
"0.4, 0.6, 0.8, 1.0)."

#: ../../manual/compositing/types/converter/math.rst:140
msgid ""
"In the case of a color image, you need split it into separate RGB channels "
"using *Separate/Combine RGBA* nodes and perform this operation on each "
"channel independently."
msgstr ""
"Dans le cas d'une image en couleur, vous devez le fractionner en canaux RVB "
"distincts en utilisant les nodes *Separate/Combine RGBA* et effectuer cette "
"opération indépendamment sur chaque canal."

#~ msgid ""
#~ "This example has one scene input by the top *Render Layer* node, which "
#~ "has a cube that is about 10 BU from the camera. The bottom Render Layer "
#~ "node inputs a scene (FlyCam) with a plane that covers the left half of "
#~ "the view and is 7 BU from the camera. Both are fed through their "
#~ "respective Map Value nodes to divide the Z-buffer by 20 (multiply by "
#~ "0.05, as shown in the Size field) and clamped to be a min/ max of 0.0/ "
#~ "1.0 respectively.This example has one scene input by the top *Render "
#~ "Layer* node, which has a cube that is about 10 BU from the camera. The "
#~ "bottom Render Layer node inputs a scene (FlyCam) with a plane that covers "
#~ "the left half of the view and is 7 BU from the camera. Both are fed "
#~ "through their respective Map Value nodes to divide the Z-buffer by 20 "
#~ "(multiply by 0.05, as shown in the Size field) and clamped to be a min/ "
#~ "max of 0.0/ 1.0 respectively.This example has one scene input by the top "
#~ "*Render Layer* node, which has a cube that is about 10 BU from the "
#~ "camera. The bottom Render Layer node inputs a scene (FlyCam) with a plane "
#~ "that covers the left half of the view and is 7 BU from the camera. Both "
#~ "are fed through their respective Map Value nodes to divide the Z-buffer "
#~ "by 20 (multiply by 0.05, as shown in the Size field) and clamped to be a "
#~ "min/max of 0.0/1.0 respectively."
#~ msgstr ""
#~ "Cet exemple a une entrée de scène par le node *Render Layer* du haut, qui "
#~ "a un cube à environ 10 BU de la caméra. Le node *Render Layer* du bas "
#~ "entre une scène (FlyCam) avec un plan qui couvre la moitié gauche de la "
#~ "vue et est à 7 BU de la caméra. Les deux sont alimentés via leurs nodes "
#~ "*Map Value* respectifs pour diviser le tampon Z par 20 (multiplier par "
#~ "0.05, comme montré dans le champ *Size*) et borné min/max de 0.0/ 1.0 "
#~ "respectivement."

#~ msgid "Example."
#~ msgstr "Exemples"

#~ msgid ""
#~ "In this example, we want to restrict the color output to only 256 "
#~ "possible values. Possible use of this is to see what the image will look "
#~ "like on an 8-bit cell phone display. To do this, we want to restrict the "
#~ "R, G and B values of any pixel to be one of a certain value, such that "
#~ "when they are combined, will not result in more than 256 possible values. "
#~ "The number of possible values of an output is the number of channel "
#~ "values multiplied by each other, or Q = R × G × B."
#~ msgstr ""
#~ "Dans cet exemple, nous voulons restreindre la sortie de couleur à "
#~ "seulement 256 valeurs possibles, Une utilisation possible de ceci est de "
#~ "voir à quoi l'image va ressembler sur un écran 8 bits de téléphone "
#~ "portable. Pour ce faire, nous voulons restreindre les valeurs R, G et B "
#~ "de chaque pixel à une certaine valeur, de sorte que quand elles sont "
#~ "combinées, elles ne produiront pas plus que 256 valeurs possibles. Le "
#~ "nombre de valeurs possibles d'une sortie est le nombre de valeurs par "
#~ "canal multiplié entre eux, ou Q = R × G × B."

#~ msgid ""
#~ "Since there are three channels and 256 values, we have some flexibility "
#~ "how to quantize each channel, since there are a lot of combinations of R "
#~ "× G × B that would equal 256. For example, if {R, G, B} = {4, 4, 16}, "
#~ "then :math:`4 × 4 × 16 = 256`. Also, {6, 6, 7} would give 252 possible "
#~ "values. The difference in appearance between {4, 4, 16} and {6, 6, 7} is "
#~ "that the first set {4, 4, 16} would have fewer shades of red and green, "
#~ "but lots of shades of blue. The set {6, 6, 7} would have a more even "
#~ "distribution of colors. To get better image quality with fewer color "
#~ "values, give possible values to the predominant colors in the image."
#~ msgstr ""
#~ "Bien qu'il y ait trois canaux et 256 valeurs, nous avons quelque "
#~ "flexibilité pour quantifier chaque canal, puisqu'il y a beaucoup de "
#~ "combinaisons de R × G × B qui 256. Par exemple, si {R, G, B} = {4, 4, "
#~ "16}, puis :math:`4 × 4 × 16 = 256`. Aussi, {6, 6, 7} donnerait 252 "
#~ "valeurs possibles. La différence en apparence entre {4, 4, 16} et {6, 6, "
#~ "7} est que le premier ensemble {4, 4, 16} aurait moins de nuances de "
#~ "rouge et de vert, mais beaucoup de nuances de bleu. L'ensemble {6, 6, 7} "
#~ "aurait une distribution de couleurs plus uniforme. Pour obtenir une "
#~ "meilleure qualité d'image avec moins de valeurs de couleur, attribuant "
#~ "des valeurs possibles aux couleurs prédominantes de l'image. "

#~ msgid ""
#~ "To accomplish this quantization of an image to 256 possible values, let "
#~ "us use the set {6, 6, 7}. To split up a continuous range of values "
#~ "between 0 and 1 (the full Red spectrum) into six values, we need to "
#~ "construct an algorithm or function that takes any input value but only "
#~ "puts out six possible values, as illustrated by the image to the right. "
#~ "We want to include zero as true black, with five other colors in between. "
#~ "The approach shown produces {0, 0.2, 0.4, 0.6, 0.8, 1}. Dividing 1.0 by 5 "
#~ "equals 0.2, which tells how far apart each quantified value is from the "
#~ "other."
#~ msgstr ""
#~ "Pour effectuer cette quantification d'une image en 256 valeurs possibles, "
#~ "utilisons l'ensemble {6, 6, 7}. Pour diviser un intervalle continu de "
#~ "valeurs entre 0 et 1 (le spectre Rouge complet) en six valeurs, nous "
#~ "devons construire un algorithme ou une fonction qui prend toute valeur "
#~ "d'entrée mais sort seulement six valeurs possibles, comme illustré par "
#~ "l'image de droite. Nous voulons inclure zéro comme noir véritable, avec "
#~ "cinq autres valeurs entre. L'approche affichée produit {0, 0.2, 0.4, 0.6, "
#~ "0.8, 1}. La division de 1.0 par 5 est égale à 0.2, qui représente la "
#~ "distance entre chaque valeur de quantification.  "

#~ msgid ""
#~ "An algebraic function is made up of primitive mathematical operations "
#~ "(add, subtract, multiply, sine, cosine, etc.) that operate on an input "
#~ "value to provide the desired output value."
#~ msgstr ""
#~ "Une fonction algébrique est faite d'opérations mathématiques primaires "
#~ "(addition, soustraction, multiplication, sinus, cosinus, etc.) qui "
#~ "opèrent sur une valeur d'entrée pour produire la valeur de sortie "
#~ "souhaitée. "

#~ msgid ""
#~ "`Spreadsheet showing a function <https://wiki.blender.org/index.php/File:"
#~ "Manual-Compositing-Node-Math_spreadsheet>`__."
#~ msgstr ""
#~ "`Feuille de calcul montrant une fonction <https://wiki.blender.org/index."
#~ "php/File:Manual-Compositing-Node-Math_spreadsheet>`__."

#~ msgid ""
#~ "The theory behind this function is scaled truncation. Suppose we want a "
#~ "math function that takes in a range of values between 0 and 1, such as "
#~ "0.552, but only outputs a value of 0.0, 0.2, 0.4, etc. We can imagine "
#~ "then that we need to get that range 0 to 1 powered up to something 0 to 6 "
#~ "so that we can chop off and make it a whole number. So, with six "
#~ "divisions, how can we do that? The answer is we multiply the range by 6. "
#~ "The output of that first math Multiply Node is a range of values between "
#~ "0 and 6. To get even divisions, because we are using the rounding "
#~ "function (see documentation above), we want any number plus or minus "
#~ "around a whole number will get rounded to that number. So, we subtract a "
#~ "half, which shifts everything over. The round() function then makes that "
#~ "range 0 to 5. We then divide by 5 to get back a range of numbers between "
#~ "0 and 1 which can then be combined back with the other color channels. "
#~ "Thus, you get the function :math:`f(x, n) = round(x × n - 0.5)/ (n - 1)` "
#~ "where \"n\" is the number of possible output values, and \"x\" is the "
#~ "input pixel color and :math:`f(x, n)` is the output value. There is only "
#~ "one slight problem, and that is for the value exactly equal to 1, the "
#~ "formula result is 1.2, which is an invalid value. This is because the "
#~ "round function is actually a roundup function, and exactly 5.5 is rounded "
#~ "up to 6. So, by subtracting 0.501, we compensate and thus 5. 499 is "
#~ "rounded to 5. At the other end of the spectrum, pure black, or 0, when "
#~ "0.501 subtracted, rounds up to 0 since the Round() function does not "
#~ "return a negative number."
#~ msgstr ""
#~ "La théorie derrière cette fonction est la troncation . Supposons que nous "
#~ "voulons une fonction mathématique qui prenne un intervalle entre 0 et 1, "
#~ "tel que 0.552, mais sort seulement une valeur de 0.0, 0.2, 0.4, etc. Nous "
#~ "pouvons imaginer alors que nous devons obtenir l'intervalle 0 à 1 levé à "
#~ "la puissance 0 à 6 de sorte que nous pouvons et en faire u n nombre "
#~ "entier. Aussi, avec six divisions,comment pouvons-nous faire cela ? la "
#~ "réponse est que nous multiplions l'intervalle par 6. La sortie de ce "
#~ "premier Node math Multiply est un intervalle de valeurs entre 0 et 6. "
#~ "Pour obtenir des divisions paires, parce que nous utilisons la fonction "
#~ "d'arrondi (voir la documentation ci-dessus), nous voulons que tout nombre "
#~ "plus ou moins autour d'un nombre entier soit arrondi à ce nombre. Aussi, "
#~ "nous soustrayons un demi, ce qui va tout décaler. La fonction round() "
#~ "qui  Nous divisons alors par 5 pour revenir sur un intervalle de nombres "
#~ "entre 0 et 1 qui peut être combiné avec les autres canaux de couleur. "
#~ "Ainsi,vous obtenez la fonction :math:`f(x, n) = round(x × n - 0.5)/ (n - "
#~ "1)` où \"n\" est le nombre de valeurs de sortie possibles, et \"x\" est "
#~ "la couleur de pixel d'entrée et :math:`f(x, n)` est la valeur de sortie. "
#~ "Seulement il y a un petit problème, et c'est la valeur exactement à 1, le "
#~ "résultat de la formule est 1.2, qui est une valeur invalide. C'est à "
#~ "cause de la fonction round es en réalité une fonction , et exactement 5.5 "
#~ "est arrondi à 6. Aussi, en soustrayant 0.501, nous compensons et ainsi "
#~ "5.499 est arrondi à 5. À l'autre bout du spectre, le noir pur, ou 0, "
#~ "quand 0.501 est soustrait, arrondi à 0 puisque la fonction Round() ne "
#~ "retourne pas de valeur négative."

#~ msgid ""
#~ "Sometimes using a spreadsheet can help you figure out how to put these "
#~ "nodes together to get the result that you want. Stepping you through the "
#~ "formula for :math:`n = 6` and :math:`x = 0.70`, locate the line on the "
#~ "spreadsheet that has the 8-bit value 179 and R value 0.7. Multiplying by "
#~ "6 gives 4.2. Subtracting 1/2 gives 3.7, which rounds up to 4.4 divided by "
#~ "5 = 0.8. Thus, f(0.7, 6) = 0.8 or an 8-bit value of 204. You can see that "
#~ "this same 8-bit value is output for a range of input values."
#~ msgstr ""
#~ "Parfois l'utilisation d'un feuille de tableur peut vous aider à "
#~ "déterminer la manière de mettre ces nodes ensemble pour obtenir le "
#~ "résultat que vous voulez. En parcourant la formule pour :math:`n = 6` et :"
#~ "math:`x = 0.70`, localisez la ligne sur la feuille du tableur qui a une "
#~ "valeur de 8 bits de 179 et R valeur de 0.7. La multiplication par 6 donne "
#~ "4.2. La soustraction de 1/2 donne 3.7, ce qui s'arrondit à 4.4 divisé par "
#~ "5 = 0.8. Ainsi, f(0.7, 6) = 0.8 ou une valeur 8 bits de 204. Vous pouvez "
#~ "voir que cette même valeur 8 bits est sortie pour  un intervalle de "
#~ "valeurs de sortie.  "

#~ msgid ""
#~ "To implement this function in Blender, consider the node setup above. "
#~ "First, feed the image to the Separate RGB node. For the Red channel, we "
#~ "string the math nodes into a function that takes each red color, "
#~ "multiplies (scales) it up by the desired number of divisions (6), offsets "
#~ "it by 0.5, rounds the value to the nearest whole number, and then divides "
#~ "the image pixel color by 5. So, the transformation is {0 to 1} becomes {0 "
#~ "to 6}, subtracting centers the medians to {-0.5 to 5.5} and the rounding "
#~ "to the nearest whole number produces {0, 1, 2, 3, 4, 5} since the "
#~ "function rounds down, and then dividing by five results in six values "
#~ "{0.0, 0.2, 0.4, 0.6, 0.8, 1.0}."
#~ msgstr ""
#~ "Pour implémenter cette fonction dans Blender, observez la configuration "
#~ "du node ci-dessus. D'abord, alimentez l'image au node *Separate RGB*. "
#~ "Pour le canal Rouge, nous enfilons les nodes *math* dans une fonction qui "
#~ "prend chaque couleur rouge, la multiplie (mise à l'échelle) par le nombre "
#~ "désiré de divisions (6),   , arrondit la valeur au nombre entier le plus "
#~ "proche, et puis divise la couleur de pixel d'image par 5. Ainsi, la "
#~ "transformation est {0 à 1} devient {0 à 6}, en soustrayant aux centres "
#~ "les médianes à {-0.5 à 5.5} et l'arrondi au nombre entier le plus proche "
#~ "produit {0, 1, 2, 3, 4, 5} puisque la fonction arrondit , et ensuite en "
#~ "divisant par cinq produit six valeurs {0.0, 0.2, 0.4, 0.6, 0.8, 1.0}."

#~ msgid ""
#~ "The result is that the output value can only be one of a certain set of "
#~ "values, stair-stepped, because of the rounding function of the math node. "
#~ "Copying this one channel to operate on Green and Blue gives the node "
#~ "setup below. To get the 6:6:7, we set the three Multiply Nodes to {6, 6, "
#~ "7} and the divide nodes to {5, 5, 6}."
#~ msgstr ""
#~ "Le résultat est que la valeur de sortie peut seulement être une valeur "
#~ "parmi un certain ensemble de valeurs, en marches d'escalier, à cause de "
#~ "la fonction rounding (arrondi) du node math.   Pour obtenir 6:6:7, nous "
#~ "fixons les trois Nodes Multiply à {6, 6, 7} et les nodes divide à {5, 5, "
#~ "6}."

#~ msgid ""
#~ "If you make this into a node group, you can easily reuse this setup from "
#~ "project to project. When you do, consider using a math node to drive the "
#~ "different values that you would have to otherwise set manually, just to "
#~ "error-proof your work."
#~ msgstr ""
#~ "Si vous faites ceci dans un groupe de nodes, vous pouvez facilement "
#~ "réutiliser cette configuration de projet en projet. En faisant cela, "
#~ "l'utilisation d'un node math pour contrôler les différentes valeurs que "
#~ "vous auriez autrefois définies manuellement, pour éviter des erreurs dans "
#~ "votre travail."

#~ msgid "Summary"
#~ msgstr "Résumé"

#~ msgid ""
#~ "Normally, an output render consists of 32- or 24-bit color depth, and "
#~ "each pixel can be one of the millions of possible colors. This node setup "
#~ "example takes each of the Red, Green and Blue channels and normalizes "
#~ "them to one of a few values. When all three channels are combined back "
#~ "together, each color can only be one of 256 possible values."
#~ msgstr ""
#~ "Normalement, un rendu de sortie consiste en une profondeur de couleur de "
#~ "32 ou 24 bits, et chaque pixel peut être d'une couleur parmi des millions "
#~ "possibles. Cet exemple de configuration de nodes prend chacun des canaux "
#~ "Rouge, Vert et Bleu et les normalise à une parmi quelques valeurs. Quand "
#~ "les trois canaux sont recombinés ensemble, chaque couleur peut seulement "
#~ "être une des 256 valeurs possibles."

#~ msgid ""
#~ "While this example uses the Separate/Combine RGB to create distinct "
#~ "colors, other Separate/Combine nodes can be used as well. If using the "
#~ "YUV values, remember that U and V vary between (-0.5 to +0.5), so you "
#~ "will have to first add on a half to bring the range between 0 and 1, and "
#~ "then after dividing, subtract a half to bring in back into standard range."
#~ msgstr ""
#~ "Alors que cet exemple utilise le *node Separate/Combine RGB* pour créer "
#~ "des couleurs distinctes, d'autres nodes Separate/Combine peuvent aussi "
#~ "être utilisés. Si les valeurs YUV sont utilisées, rappelez que U and V "
#~ "varient entre (-0.5 et +0.5), aussi vous devez d'abord ajouter un demi "
#~ "pour amener l'intervalle entre 0 et 1, et ensuite, après la division, "
#~ "soustraire un demi pour le ramener dans l'intervalle standard. "

#~ msgid ""
#~ "The ``JPG`` or ``PNG`` image format will store each of the colors "
#~ "according to its image standard for color depth (e.g. ``JPG`` is 24-bit), "
#~ "but the image will be very small since reducing color depth and "
#~ "quantizing colors are essentially what the ``JPEG`` compression algorithm "
#~ "accomplishes."
#~ msgstr ""
#~ "le format d'image ``JPG`` ou ``PNG`` va enregistrer chacune des couleurs "
#~ "selon son standard d'image pour la profondeur de couleur (ex. ``JPG`` est "
#~ "à 24-bit), mais l'image sera très petite puisque la réduction de la "
#~ "profondeur de couleur et la quantification des couleurs sont "
#~ "essentiellement ce qu'accomplit l'algorithme de compression ``JPEG``. "

#~ msgid ""
#~ "You do not have to reduce the color depth of each channel evenly. For "
#~ "example, if blue was the dominant color in an image, to preserve image "
#~ "quality, you could reduce Red to 2 values, Green to 4, and let the blue "
#~ "take on :math:`256/(2 × 4)` or 32 values. If using the HSV, you could "
#~ "reduce the Saturation and Value to 2 values (0 or 1.0) by Multiply by 2 "
#~ "and Divide by 2, and restrict the Hue to 64 possible values."
#~ msgstr ""
#~ "Vous n'avez pas à réduire uniformément la profondeur de couleur de chaque "
#~ "canal. Par exemple, si le Bleu est la couleur dominante d'une image, pour "
#~ "préserver la qualité de l'image, vous pourriez réduire le Rouge à 2 "
#~ "valeurs, le Vert à 4, et laisser le Bleu prendre :math:`256/(2 × 4)` ou "
#~ "32 valeurs. Si *HSV* est utilisé, vous pourriez réduire la *Saturation* "
#~ "et la *Value* à 2 valeurs (0.0 ou 1.0)    , et restreindre le *Hue* à 64 "
#~ "valeurs possibles."

#~ msgid ""
#~ "You can use this node setup to quantize any channel; alpha, speed "
#~ "(vector), Z values, and so forth."
#~ msgstr ""
#~ "Vous pouvez utiliser cette configuration de nodes pour quantifier un "
#~ "canal ; alpha, vitesse (vecteur), valeur Z, etc."
