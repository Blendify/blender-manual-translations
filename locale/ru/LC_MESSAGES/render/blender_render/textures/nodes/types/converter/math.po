# Этот файл является частью перевода руководства к Blender'у.
# Соответствующая страница руководства может быть получена по адресу
#
#
# https://docs.blender.org/manual/ru/dev/render/blender_render/textures/nodes/types/converter/math.html
# Этот файл распространяется под всемирной лицензией CC-BY-SA 4.0
# https://creativecommons.org/licenses/by-sa/4.0/deed.ru
# Список переводчиков
# ===================
# Mingun <alexander_sergey@mail.ru>, 2016 - 2017.
msgid ""
msgstr ""
"Project-Id-Version: Руководство по Blender 2.78\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-24 22:17+1100\n"
"PO-Revision-Date: 2017-02-23 17:38+0500\n"
"Last-Translator: Mingun <alexander_sergey@mail.ru>\n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.3\n"

#: ../../manual/compositing/types/converter/math.rst:5
msgid "Math Node"
msgstr "Узел «Математика»"

#: ../../manual/compositing/types/converter/math.rst:10
msgid "Math node."
msgstr "Узел «Математика»"

#: ../../manual/compositing/types/converter/math.rst:12
#, fuzzy
msgid "The *Math Node* performs math operations."
msgstr "Этот узел позволяет выполнять математические операции."

#: ../../manual/compositing/types/converter/math.rst:16
msgid "Inputs"
msgstr "Входы"

#: ../../manual/compositing/types/converter/math.rst:19
#: ../../manual/compositing/types/converter/math.rst:25
#: ../../manual/compositing/types/converter/math.rst:42
msgid "Value"
msgstr "Значение"

#: ../../manual/compositing/types/converter/math.rst:19
msgid ""
"First numerical value. The trigonometric functions accept values in "
"radians."
msgstr ""
"Первое числовое значение. Тригонометрические функции принимают значения в"
" радианах."

#: ../../manual/compositing/types/converter/math.rst:22
msgid ""
"Second numerical value. This value is **not** used in functions that "
"accept only one parameter like the trigonometric functions, Round and "
"Absolute."
msgstr ""
"Второе числовое значение. Это значение **не используется** в функциях, "
"принимающих только один параметр, таких, как тригонометрические функции, "
"округление и взятие абсолютного значения."

#: ../../manual/compositing/types/converter/math.rst:28
msgid "Properties"
msgstr "Свойства"

#: ../../manual/compositing/types/converter/math.rst:31
msgid "Operation"
msgstr "Операция"

#: ../../manual/compositing/types/converter/math.rst:31
msgid ""
"Add, Subtract, Multiply, Divide, Sine, Cosine, Tangent, Arcsine, "
"Arccosine, Arctangent, Power, Logarithm, Minimum, Maximum, Round, Less "
"Than, Greater Than, Modulo, Absolute."
msgstr ""
"«Добавить», «Вычесть», «Умножить», «Разделить», «Синус», «Косинус», "
"«тангенс», «Арксинус», «Арккосинус», «Арктангенс», «Степень», «Логарифм»,"
" «Минимум», «Максимум», «Круг», «Меньше чем», «Больше чем», «Остаток "
"деления», «Абсолютно»."

#: ../../manual/compositing/types/converter/math.rst:35
msgid "Clamp"
msgstr "С ограничением"

#: ../../manual/compositing/types/converter/math.rst:34
msgid "Limits the output to the range (0 to 1). See :term:`clamp`."
msgstr ""
"Ограничивает вывод в диапазоне (от 0 до 1). Смотрите :term:`усекание "
"<clamp>`."

#: ../../manual/compositing/types/converter/math.rst:38
msgid "Outputs"
msgstr "Выходы"

#: ../../manual/compositing/types/converter/math.rst:41
msgid "Numerical value output."
msgstr "Выход числового значения."

#: ../../manual/compositing/types/converter/math.rst:45
msgid "Examples"
msgstr "Примеры"

#: ../../manual/compositing/types/converter/math.rst:48
msgid "Manual Z-Mask"
msgstr "Ручная Z-маска"

#: ../../manual/compositing/types/converter/math.rst:52
msgid "Example."
msgstr "Пример"

#: ../../manual/compositing/types/converter/math.rst:54
msgid ""
"This example has one scene input by the top *Render Layer* node, which "
"has a cube that is about 10 BU from the camera. The bottom Render Layer "
"node inputs a scene (FlyCam) with a plane that covers the left half of "
"the view and is 7 BU from the camera. Both are fed through their "
"respective Map Value nodes to divide the Z buffer by 20 (multiply by "
"0.05, as shown in the Size field) and clamped to be a min/ max of 0.0/ "
"1.0 respectively."
msgstr ""
"В этом примере имеется один вход сцены в верхний узел *«Слои "
"визуализации»*, в которой содержится куб, расположенный на расстоянии "
"около 10 BU от камеры. Вход нижнего узла «Слои визуализации» содержит "
"сцену (FlyCam) с плоскостью, закрывающей левую половину вида и "
"расположенной на расстоянии 7 BU от камеры. Выходы обеих узлов подаются "
"на соответствующие узлы «Отобразить значение», чтобы разделить значения в"
" Z-буфере на 20 (умножая на 0.05, как видно в поле «Размер») и отсечь по "
"диапазону 0.0 - 1.0."

#: ../../manual/compositing/types/converter/math.rst:62
msgid ""
"For the minimum function, the node selects those Z values where the "
"corresponding pixel is closer to the camera; so it chooses the Z values "
"for the plane and part of the cube. The background has an infinite Z "
"value, so it is clamped to 1.0 (shown as white). In the maximum example, "
"the Z values of the cube are greater than the plane, so they are chosen "
"for the left side, but the plane (FlyCam) Render layers Z are infinite "
"(mapped to 1.0) for the right side, so they are chosen."
msgstr ""
"Для функции минимума узел выбирает те значения Z, где соответствующий "
"пиксель ближе всего к камере; поэтому он выбирает значения Z для "
"плоскости и части куба. Фон имеет бесконечное значение Z, поэтому он "
"усекается до 1.0 (показывается белым цветом). В примере с функцией "
"максимума значение Z куба больше, чем плоскости, поэтому они и выбираются"
" для левой стороны, но слой визуалиции с плоскостью (FlyCam) с правой "
"стороны содержит бесконечное значение Z (усекается до 1.0), поэтому "
"выбирается плоскость."

#: ../../manual/compositing/types/converter/math.rst:72
msgid "Using Sine Function to Pulsate"
msgstr "Использование функции синуса для пульсаций"

#: ../../manual/compositing/types/converter/math.rst:76
#, fuzzy
msgid ""
"This example has a *Time* node putting out a linear sequence from 0 to 1 "
"over the course of 101 frames. The green vertical line in the curve "
"widget shows that frame 25 is being put out, or a value of 0.25. That "
"value is multiplied by 2 × pi and converted to 1.0 by the Sine function, "
"since we all know that :math:`sin(2 × pi/ 4) = sin(pi/ 2) = +1.0`. Since "
"the sine function can put out values between (-1.0 to 1.0), the *Map "
"Value* node scales that to 0.0 to 1.0 by taking the input (-1 to 1), "
"adding 1 (making 0 to 2), and multiplying the result by one-half (thus "
"scaling the output between 0 to 1). The default *Color Ramp* converts "
"those values to a grayscale. Thus, medium gray corresponds to a 0.0 "
"output by the sine, black to -1.0, and white to 1.0. As you can see, "
":math:`sin(pi/ 2) = 1.0`. Like having your own visual color calculator! "
"Animating this node setup provides a smooth cyclic sequence through the "
"range of grays."
msgstr ""
"В этом примере узел *«Время»* выдаёт линейную последовательность от 0 до "
"1 на протяжении 101 кадра. Вертикальная зелёная линия на виджете кривых "
"показывает, что на 25-м кадре значение узла будет равно 0.25. Это "
"значение умножается на 2 × pi и преобразуется к 1.0 при помощи функции "
"синуса, поскольку мы все знаем, что :math:`sin(2 × pi/ 4) = sin(pi/ 2) = "
"+1.0`. Так как функция синуса может выдавать значения между (-1.0 и 1.0),"
" то узел *«Отобразить значение»* масштабирует её вывод к диапазону от 0.0"
" до 1.0: берёт вход (от -1 до 1), добавляет 1 (в результате чего диапазон"
" становится равным от 0 до 2) и умножает полученный результат на одну "
"вторую (таким образом, масштабируя выходной сигнал к диапазону от 0 до "
"1). Узел *«Градиентная карта»* с настройками по умолчанию преобразует эти"
" значения в оттенки серого. Таким образом, средний серый цвет "
"соответствует выходу 0.0 синуса, чёрный – выходу -1.0, а белый – выходу "
"1.0. Как вы можете видеть, :math:`sin(pi/ 2) = 1.0`. Как будто мы "
"получили собственный визуальный цветовой калькулятор! Анимировав это "
"дерево узлов, мы получим гладкую циклическую смену оттенков серого цвета."

#: ../../manual/compositing/types/converter/math.rst:88
msgid ""
"Use this function to vary, for example, the alpha channel of an image to "
"produce a fading in/out effect. Alter the Z channel to move a scene "
"in/out of focus. Alter a color channel value to make a color \"pulse\"."
msgstr ""
"Используйте эту функцию для изменения, к примеру, альфа-канала "
"изображения, чтобы реализовать эффект затухания/проявления. Изменяйте "
"Z-канал, чтобы переместить сцену в фокус / из фокуса. Изменяйте значение "
"цветового канала, чтобы заставить цвет «пульсировать»."

#: ../../manual/compositing/types/converter/math.rst:95
msgid "Brightening/Scaling a Channel"
msgstr "Осветление/масштабирование канала"

#: ../../manual/compositing/types/converter/math.rst:99
msgid ""
"This example has a *Math: Multiply* node increasing the luminance channel"
" (Y) of the image to make it brighter. Note that you should use a *Map "
"Value node* with min() and max() enabled to clamp the output to valid "
"values. With this approach, you could use a logarithmic function to make "
"a high-dynamic range image. For this particular example, there is also a "
"*Brighten/Contrast node* that might give simpler control over brightness."
msgstr ""
"В этом примере узел *«Математика: Умножение»* увеличивает канал яркости "
"(Y) изображения, чтобы сделать его светлее. Обратите внимание, что "
"следует использовать узел *«Отобразить значение»* с активными параметрами"
" «С минимумом» и «С максимумом», чтобы усечь выходной диапазон до "
"допустимых значений. При таком подходе для создания изображения с высоким"
" динамическим диапазоном можно использовать логарифмическую функцию. В "
"этом конкретном примере также можно использовать узел "
"*«Яркость/контраст»*, который позволяет упростить управление яркостью "
"изображения."

#: ../../manual/compositing/types/converter/math.rst:108
msgid "Quantize/Restrict Color Selection"
msgstr "Квантование/ограничение выбора цвета"

#: ../../manual/compositing/types/converter/math.rst:110
msgid ""
"In this example, we want to restrict the color output to only 256 "
"possible values. Possible use of this is to see what the image will look "
"like on an 8-bit cell phone display. To do this, we want to restrict the "
"R, G and B values of any pixel to be one of a certain value, such that "
"when they are combined, will not result in more than 256 possible values."
" The number of possible values of an output is the number of channel "
"values multiplied by each other, or Q = R × G × B."
msgstr ""
"В этом примере мы хотим ограничить цвета вывода 256-ю возможными "
"значениями. Возможное применение – посмотреть, как изображение будет "
"выглядеть на 8-битном дисплее сотового телефона. Для этого мы хотим "
"ограничить каналы R, G и B любого пикселя одним определённым значением, "
"чтобы при их объединении получилось не более 256 возможных значений. "
"Число возможных значений вывода равно перемноженным значениям каждого "
"канала, то есть Q = R × G × B."

#: ../../manual/compositing/types/converter/math.rst:117
#, fuzzy
msgid ""
"Since there are three channels and 256 values, we have some flexibility "
"how to quantize each channel, since there are a lot of combinations of R "
"× G × B that would equal 256. For example, if {R, G, B} = {4, 4, 16}, "
"then :math:`4 × 4 × 16 = 256`. Also, {6, 6, 7} would give 252 possible "
"values. The difference in appearance between {4, 4, 16} and {6, 6, 7} is "
"that the first set {4, 4, 16} would have fewer shades of red and green, "
"but lots of shades of blue. The set {6, 6, 7} would have a more even "
"distribution of colors. To get better image quality with fewer color "
"values, give possible values to the predominant colors in the image."
msgstr ""
"Поскольку у нас три канала и 256 значений, у нас появляется некоторая "
"гибкость в отношении того, как квантовать каждый канал. Это возможно "
"потому, что существует множество комбинаций произведения R × G × B, "
"которые в точности дают 256. Например, если {R, G, B} = {4, 4, 16}, то "
":math:`4 × 4 × 16 = 256`. Комбинация {6, 6, 7} даст 252 возможных "
"значения. Разница в результате для наборов {4, 4, 16} и {6, 6, 7} состоит"
" в том, что первый набор {4, 4, 16} кодирует меньшее количество оттенков "
"красного и зелёного, но больше оттенков синего. Набор {6, 6, 7} обладает "
"более равномерным распределением цветов. Чтобы получить лучшее качество "
"изображения с меньшим количеством значений цвета, выделите больше "
"возможных значений преобладающим цветам в изображении."

#: ../../manual/compositing/types/converter/math.rst:129
msgid "Theory"
msgstr "Теория"

#: ../../manual/compositing/types/converter/math.rst:131
msgid ""
"`Two Approaches to Quantizing to six values "
"<https://wiki.blender.org/index.php/File:Manual-Compositing-Node-"
"Math_ColorBand>`__."
msgstr ""
"`Два подхода к квантованию до шести значений "
"<https://wiki.blender.org/index.php/File:Manual-Compositing-Node-"
"Math_ColorBand>`__."

#: ../../manual/compositing/types/converter/math.rst:134
msgid ""
"To accomplish this quantization of an image to 256 possible values, let "
"us use the set {6, 6, 7}. To split up a continuous range of values "
"between 0 and 1 (the full Red spectrum) into six values, we need to "
"construct an algorithm or function that takes any input value but only "
"puts out six possible values, as illustrated by the image to the right. "
"We want to include zero as true black, with five other colors in between."
" The approach shown produces {0, 0.2, 0.4, 0.6, 0.8, 1}. Dividing 1.0 by "
"5 equals 0.2, which tells how far apart each quantified value is from the"
" other."
msgstr ""
"Давайте будем использовать набор {6, 6, 7} для квантования изображения по"
" 256 возможным значениям. Для разбиения непрерывного диапазона значений "
"от 0 до 1 (полный красный спектр) на шесть значений нам нужно построить "
"алгоритм или функцию, которая принимает любое входное значение, но на "
"выходе даёт только шесть возможных значений, как показано на изображении "
"справа. В этот набор мы хотим включить ноль для абсолютно чёрного цвета и"
" пять других цветов между чёрным и красным. Показанный подход выдаёт "
"набор {0, 0.2, 0.4, 0.6, 0.8, 1}. Разделив 1.0 на 5 частей по 0.2 мы "
"указали, насколько далеко друг от друга отстоят квантированные значения."

#: ../../manual/compositing/types/converter/math.rst:142
#, fuzzy
msgid ""
"So, to get good even shading, we want to take values that are 0.16 or "
"less and map them to 0.0; values between 0.16 and 0.33 get fixed to 0.2; "
"color values between 0.33 and 0.5 get quantized to 0.4, and so on up to "
"values between 0.83 and 1.0 get mapped to 1.0."
msgstr ""
"Таким образом, для получения хорошего затенения мы хотим взять значения, "
"меньшие или раные 0.16 и отобразить их в 0.0; значения от 0.16 до 0.33 "
"превратить в 0.2; значения полосы цвета между 0.33 и 0.5 сквантовать в "
"0.4, и так далее, до значений между 0.83 и 1.0, отображаемых в 1.0."

#: ../../manual/compositing/types/converter/math.rst:148
msgid "Function f(x)"
msgstr "Функция f(x)"

#: ../../manual/compositing/types/converter/math.rst:150
#, fuzzy
msgid ""
"An algebraic function is made up of primitive mathematical operations "
"(add, subtract, multiply, sine, cosine, etc.) that operate on an input "
"value to provide the desired output value."
msgstr ""
"Алгебраическая функция, состоящая из примитивных математических операций "
"(сложение, вычитание, умножение, синус, косинус и прочие), которые "
"оперируют с входным значением для возврата требуемого выходного значения."

#: ../../manual/compositing/types/converter/math.rst:154
msgid ""
"`Spreadsheet showing a function <https://wiki.blender.org/index.php/File"
":Manual-Compositing-Node-Math_spreadsheet>`__."
msgstr ""
"`Таблица со значениями функции <https://wiki.blender.org/index.php/File"
":Manual-Compositing-Node-Math_spreadsheet>`__."

#: ../../manual/compositing/types/converter/math.rst:157
msgid ""
"The theory behind this function is scaled truncation. Suppose we want a "
"math function that takes in a range of values between 0 and 1, such as "
"0.552, but only outputs a value of 0.0, 0.2, 0.4, etc. We can imagine "
"then that we need to get that range 0 to 1 powered up to something 0 to 6"
" so that we can chop off and make it a whole number. So, with six "
"divisions, how can we do that? The answer is we multiply the range by 6. "
"The output of that first math Multiply Node is a range of values between "
"0 and 6. To get even divisions, because we are using the rounding "
"function (see documentation above), we want any number plus or minus "
"around a whole number will get rounded to that number. So, we subtract a "
"half, which shifts everything over. The round() function then makes that "
"range 0 to 5. We then divide by 5 to get back a range of numbers between "
"0 and 1 which can then be combined back with the other color channels. "
"Thus, you get the function :math:`f(x, n) = round(x × n - 0.5)/ (n - 1)` "
"where \"n\" is the number of possible output values, and \"x\" is the "
"input pixel color and :math:`f(x, n)` is the output value. There is only "
"one slight problem, and that is for the value exactly equal to 1, the "
"formula result is 1.2, which is an invalid value. This is because the "
"round function is actually a roundup function, and exactly 5.5 is rounded"
" up to 6. So, by subtracting 0.501, we compensate and thus 5. 499 is "
"rounded to 5. At the other end of the spectrum, pure black, or 0, when "
"0.501 subtracted, rounds up to 0 since the Round() function does not "
"return a negative number."
msgstr ""
"Теория в основе этой функции называется масштабируемым усечением. "
"Предположим, мы хотим, чтобы математическая функция принимала диапазон "
"значений от 0 до 1, например 0.552, но на выходе возвращала значения 0.0,"
" 0.2, 0.4 и так далее. Можно представить себе, что нам нужно расширить "
"диапазон от 0 до 1 до значений от 0 до 6, чтобы мы могли порубить его на "
"целые числа. Так как же мы можем сделать это? Ответ – мы умножаем "
"диапазон на 6. Выходом первого узла «Математика» с операцией «Умножение» "
"будет диапазон значений от 0 до 6. Чтобы получить нужное разделение, мы "
"используем округление (смотрите документацию выше); мы хотим, чтобы любое"
" число, меньше или больше целого числа округлялось до этого числа. "
"Поэтому мы вычитаем 0.5, из-за чего все значения сдвигаются вверх. "
"Функция round() выдаёт целые значения в диапазоне от 0 до 5. Затем мы "
"делим их на 5, чтобы привести обратно в диапазон от 0 до 1. Затем "
"полученные числа можно снова объединить с другими цветовыми каналами. "
"Таким образом, мы получаем функцию :math:`f(x, n) = round(x × n - 0.5)/ "
"(n - 1)`, где «n» представляет число возможных выходных значений, «х» "
"определяет входной цвет пикселя, а :math:`f(x, n)` – выходное значение. "
"Существует только одна небольшая проблема – для входа 1 формула выдаёт "
"значение 1.2, которое является недопустимым. Так происходит потому, что "
"функция round() фактически является функцией округления вверх, а именно, "
"5.5 округляется до 6. Так что мы компенсируем этот недостаток, вычитая "
"0.501 и, таким образом, получая значение 5.499, которое округляется до 5."
" На другом, чёрном (в 0), конце спектра, при вычитании 0.501 округление "
"происходит до 0, поскольку функция round() не возвращает отрицательных "
"чисел."

#: ../../manual/compositing/types/converter/math.rst:179
msgid ""
"Sometimes using a spreadsheet can help you figure out how to put these "
"nodes together to get the result that you want. Stepping you through the "
"formula for :math:`n = 6` and :math:`x = 0.70`, locate the line on the "
"spreadsheet that has the 8-bit value 179 and R value 0.7. Multiplying by "
"6 gives 4.2. Subtracting 1/2 gives 3.7, which rounds up to 4.4 divided by"
" 5 = 0.8. Thus, f(0.7, 6) = 0.8 or an 8-bit value of 204. You can see "
"that this same 8-bit value is output for a range of input values."
msgstr ""
"Иногда использование электронных таблиц может помочь вам понять, как "
"скомпоновать все эти узлы, чтобы получить желаемый результат. Пройдёмся "
"по формуле для :math:`n = 6` и :math:`x = 0.70`. Найдите в таблице "
"строку, которая содержит 8-битное значение 179 и значение R, равное 0.7. "
"Умножение на 6 даст 4.2. Вычитание 1/2 даст 3.7, которое округлится вверх"
" до 4.4. Деление на 5 даст 0.8. Таким образом, f(0.7, 6) = 0.8 или "
"8-битное значение 204. Как вы можете видеть, такое же 8-битное значение "
"получается на выходе для всего диапазона входных значений."

#: ../../manual/compositing/types/converter/math.rst:188
msgid "Reality"
msgstr "Действительность"

#: ../../manual/compositing/types/converter/math.rst:190
msgid ""
"To implement this function in Blender, consider the node setup above. "
"First, feed the image to the Separate RGB node. For the Red channel, we "
"string the math nodes into a function that takes each red color, "
"multiplies (scales) it up by the desired number of divisions (6), offsets"
" it by 0.5, rounds the value to the nearest whole number, and then "
"divides the image pixel color by 5. So, the transformation is {0 to 1} "
"becomes {0 to 6}, subtracting centers the medians to {-0.5 to 5.5} and "
"the rounding to the nearest whole number produces {0, 1, 2, 3, 4, 5} "
"since the function rounds down, and then dividing by five results in six "
"values {0.0, 0.2, 0.4, 0.6, 0.8, 1.0}."
msgstr ""
"Для реализации этой функции в Blender рассмотрим конфигурацию узлов, "
"показанную выше. Во-первых, скормим изображение узлу «Разделить RGB». Для"
" красного канала мы выстроили узлы «Математика» в функцию, которая "
"принимает красный цвет, масштабирует его к необходимому количеству "
"делений (6), сдвигает на 0.5, округляет до ближайшего целого числа и "
"делит цвет пикселя изображения на 5. Таким образом, она производит "
"преобразование диапазона {от 0 до 1} в диапазон {от 0 до 6}, вычитая "
"центры медиан, преобразует его в диапазон {от -0.5 до 5.5} и округляя до "
"ближайшего целого – в набор {0, 1, 2, 3, 4, 5} (поскольку функция "
"округляет вниз). В конце после деления на пять получаем искомый набор "
"{0.0, 0.2, 0.4, 0.6, 0.8, 1.0}."

#: ../../manual/compositing/types/converter/math.rst:200
#, fuzzy
msgid ""
"The result is that the output value can only be one of a certain set of "
"values, stair-stepped, because of the rounding function of the math node."
" Copying this one channel to operate on Green and Blue gives the node "
"setup below. To get the 6:6:7, we set the three Multiply Nodes to {6, 6, "
"7} and the divide nodes to {5, 5, 6}."
msgstr ""
"В результате, из-за присутствия узла с функцией округления, выход может "
"принимать только одно значение из определённого набора. Копированием "
"одной этой цепочки для зелёного и синего каналов мы получили показанную "
"конфигурацию узлов. Чтобы получить распределение 6:6:7, мы для узлов с "
"умножением задали значения {6, 6, 7}, а для узлов с делением – {5, 5, 6}."

#: ../../manual/compositing/types/converter/math.rst:207
#, fuzzy
msgid ""
"If you make this into a node group, you can easily reuse this setup from "
"project to project. When you do, consider using a math node to drive the "
"different values that you would have to otherwise set manually, just to "
"error-proof your work."
msgstr ""
"Если вы объедините эти узлы в группу, вы сможете легко повторно "
"использовать эту конфигурацию в каждом новом проекте. Когда вы сделаете "
"это, рассмотрите возможность использования узла «Математика» для "
"управления различными значениями, которые в противном случае вы бы "
"устанавливали вручную, просто чтобы защититься от ошибок."

#: ../../manual/compositing/types/converter/math.rst:213
msgid "Summary"
msgstr "Выводы"

#: ../../manual/compositing/types/converter/math.rst:215
msgid ""
"Normally, an output render consists of 32- or 24-bit color depth, and "
"each pixel can be one of the millions of possible colors. This node setup"
" example takes each of the Red, Green and Blue channels and normalizes "
"them to one of a few values. When all three channels are combined back "
"together, each color can only be one of 256 possible values."
msgstr ""
"Как правило, выход визуализации состоит из цветов 32- или 24-битной "
"глубины, то есть каждый пиксель может иметь один из миллионов возможных "
"цветов. В этом примере дерева узлов берутся все цветовые каналы – "
"красный, зелёного и синий – и нормализуются к одному из нескольких "
"значений. При последующем объединении всех трёх каналов, каждый цвет "
"может принять только одно из 256 возможных значений."

#: ../../manual/compositing/types/converter/math.rst:222
msgid ""
"While this example uses the Separate/Combine RGB to create distinct "
"colors, other Separate/Combine nodes can be used as well. If using the "
"YUV values, remember that U and V vary between (-0.5 to +0.5), so you "
"will have to first add on a half to bring the range between 0 and 1, and "
"then after dividing, subtract a half to bring in back into standard "
"range."
msgstr ""
"Хотя в этом примере для создания различных цветов используются узлы "
"«Разделить RGB»/«Объединить RGB», для этого также можно использовать "
"другие узлы класса «Разделить»/«Объединить». При использовании значений "
"YUV, помните, что значения U и V лежат в диапазоне (от -0.5 до +0.5), так"
" что вам придётся сначала добавить 0.5, чтобы перевести диапазон в "
"границы от 0 до 1, а после разделения вычесть 0.5, чтобы вернуться в "
"стандартные границы."

#: ../../manual/compositing/types/converter/math.rst:228
#, fuzzy
msgid ""
"The ``JPG`` or ``PNG`` image format will store each of the colors "
"according to its image standard for color depth (e.g. ``JPG`` is 24-bit),"
" but the image will be very small since reducing color depth and "
"quantizing colors are essentially what the ``JPEG`` compression algorithm"
" accomplishes."
msgstr ""
"Форматы изображения ``JPG`` или ``PNG`` сохранят каждый цвет согласно "
"своему стандарту на глубину цвета (например, для ``JPG`` это 24 бита на "
"пиксель), но изображение будет очень очень маленьким, поскольку "
"уменьшение глубины цвета и квантование цветов – это, по сути, и есть "
"алгоритм сжатия ``JPEG``."

#: ../../manual/compositing/types/converter/math.rst:233
msgid ""
"You do not have to reduce the color depth of each channel evenly. For "
"example, if blue was the dominant color in an image, to preserve image "
"quality, you could reduce Red to 2 values, Green to 4, and let the blue "
"take on :math:`256/(2 × 4)` or 32 values. If using the HSV, you could "
"reduce the Saturation and Value to 2 values (0 or 1.0) by Multiply by 2 "
"and Divide by 2, and restrict the Hue to 64 possible values."
msgstr ""
"Вы не должны равномерно уменьшать глубину цвета по каждому каналу. "
"Например, если доминирующим цветом в изображении был синий, то чтобы "
"сохранить качество изображения, можно уменьшить красный канал до 2-х "
"значений на пиксель, зелёный – до 4-х, а синий – до :math:`256/(2 × 4)`, "
"то есть 32-х значений. При использовании HSV, можно уменьшить "
"насыщенность и значение до 2 значений на пиксель (0 или 1.0) путём "
"умножения на 2 и деления на 2, а тон ограничить 64-мя возможными "
"значениями."

#: ../../manual/compositing/types/converter/math.rst:239
msgid ""
"You can use this node setup to quantize any channel; alpha, speed "
"(vector), z-values, and so forth."
msgstr ""
"Это дерево узлов можно использовать для квантования любого канала: "
"альфа-канала, вектора скорости, значений Z и так далее."

