# SOME DESCRIPTIVE TITLE.
# Copyright (C) : This page is public domain as CC0
# This file is distributed under the same license as the Blender Reference
# Manual package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
# urko <urkokul@gmail.com>, 2018.
#
msgid ""
msgstr ""
"Project-Id-Version: Blender 2.78 Manual 2.78\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-04-17 01:30+0200\n"
"PO-Revision-Date: 2018-02-24 20:06+0200\n"
"Last-Translator: urko <urkokul@gmail.com>\n"
"Language: uk\n"
"Language-Team: \n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.3\n"

#: ../../manual/game_engine/python_api/videotexture.rst:4
msgid "The VideoTexture Module: bge.texture"
msgstr "Модуль відеотекстур: bge.texture"

#: ../../manual/game_engine/python_api/videotexture.rst:6
msgid ""
"The ``bge.texture`` module allows you to manipulate textures during the "
"game. Several sources for texture are possible: video files, image files,"
" video capture, memory buffer, camera render or a mix of that. The video "
"and image files can be loaded from the Internet using a URL instead of a "
"file name. In addition, you can apply filters on the images before "
"sending them to the GPU, allowing video effect: blue screen, gradient, "
"gray, normal map. ``bge.texture`` uses FFmpeg to load images and videos. "
"All the formats and codecs that FFmpeg supports are supported by "
"``bge.texture``, including but not limited to:"
msgstr ""
"Модуль ``bge.texture`` дозволяє вам маніпулювати текстурами у ході гри. "
"Доступні різні джерела для текстур: файли відео, файли зображень, захвати"
" відео, буфер пам'яті, рендер камери або суміш цього. Файли відео та "
"зображень можуть бути завантажені з Інтернету, використовуючи URL замість"
" імені файлу. Окрім цього, ви можете застосовувати фільтри до зображень, "
"перед посиланням їх на GPU, роблячи відео-ефект: синій екран, градієнт, "
"сірий, карта нормалей. ``bge.texture`` використовує FFmpeg для "
"завантаження зображень та відео. Усі формати та кодеки, що підтримує "
"FFmpeg, також підтримуються модулем ``bge.texture``, включаючи, але не "
"обмежуючись:"

#: ../../manual/game_engine/python_api/videotexture.rst:16
msgid "AVI"
msgstr "AVI"

#: ../../manual/game_engine/python_api/videotexture.rst:17
msgid "Ogg"
msgstr "Ogg"

#: ../../manual/game_engine/python_api/videotexture.rst:18
msgid "Xvid"
msgstr "Xvid"

#: ../../manual/game_engine/python_api/videotexture.rst:19
msgid "Theora"
msgstr "Theora"

#: ../../manual/game_engine/python_api/videotexture.rst:20
msgid "dv1394 camera"
msgstr "dv1394 камера"

#: ../../manual/game_engine/python_api/videotexture.rst:21
msgid "video4linux capture card (this includes many webcams)"
msgstr "video4linux картка захвату (це включає багато вебкамер)"

#: ../../manual/game_engine/python_api/videotexture.rst:22
msgid "videoForWindows capture card (this includes many webcams)"
msgstr "videoForWindows картка захвату (це включає багато вебкамер)"

#: ../../manual/game_engine/python_api/videotexture.rst:23
msgid "JPG"
msgstr "JPG"

#: ../../manual/game_engine/python_api/videotexture.rst:27
msgid "How It Works"
msgstr "Як це працює"

#: ../../manual/game_engine/python_api/videotexture.rst:29
msgid ""
"The principle is simple: first you identify an existing texture by object"
" and name, then you create a new texture with dynamic content and swap "
"the two textures in the GPU. The GE is not aware of the substitution and "
"continues to display the object as always, except that you are now in "
"control of the texture. At the end, the new texture is deleted and the "
"old texture restored."
msgstr ""
"Принцип простий: спершу ви ідентифікуєте наявну текстуру за об'єктом та "
"іменам, далі ви створюєте нову текстуру з динамічним вмістом та обмінюєте"
" ці дві текстури в GPU. Рушій GE не знає про підміну та продовжує "
"показувати об'єкт, як завжди, за винятком того, що ви тепер керуєте цією "
"текстурою. У кінці, нова текстура видаляється, а стара текстура "
"відновлюється."

#: ../../manual/game_engine/python_api/videotexture.rst:35
msgid ""
"The present page is a guide to the ``bge.texture`` module with simple "
"examples."
msgstr ""
"Дана сторінка є провідником щодо модуля ``bge.texture`` за допомогою "
"простих прикладів."

#: ../../manual/game_engine/python_api/videotexture.rst:39
msgid "Game Preparation"
msgstr "Підготовка гри"

#: ../../manual/game_engine/python_api/videotexture.rst:41
msgid ""
"Before you can use the thing ``bge.texture`` module, you must have "
"objects with textures applied appropriately."
msgstr ""
"Перед тим, як ви зможете використати цей модуль ``bge.texture``, ви "
"повинні мати об'єкти з належно накладеними текстурами."

#: ../../manual/game_engine/python_api/videotexture.rst:44
msgid ""
"Imagine you want to have a television showing live broadcast programs in "
"the game. You will create a television object and UV-apply a different "
"texture at the place of the screen, for example ``tv.png``. What this "
"texture looks like is not important; probably you want to make it dark "
"gray to simulate power-off state. When the television must be turned on, "
"you create a dynamic texture from a video capture card and use it instead"
" of ``tv.png``: the TV screen will come to life."
msgstr ""
"Уявіть, що ви хочете мати телевізор, який показує у прямому ефірі "
"програми у грі. Ви створите об'єкт телевізора та накладете по UV іншу "
"текстуру у цьому місці екрану, наприклад, ``tv.png``. Те, як ця текстура "
"виглядає, не є важливим; можливо, ви схочете зробити її темно-сірою для "
"імітації вимкненого стану. Коли телевізор повинен бути увімкнений, ви "
"створюєте динамічну текстуру з карти захвату відео та використовуєте її "
"замість``tv.png``: телеекран оживає."

#: ../../manual/game_engine/python_api/videotexture.rst:51
msgid "You have two ways to define textures that ``bge.texture`` can grab:"
msgstr ""
"Ви маєте два шляхи для визначення текстур, що можуть захопити "
"``bge.texture``:"

#: ../../manual/game_engine/python_api/videotexture.rst:53
msgid "Simple UV texture."
msgstr "Проста текстура по UV."

#: ../../manual/game_engine/python_api/videotexture.rst:54
msgid "Blender material with image texture channel."
msgstr "Матеріал Blender'а з каналом текстури зображення."

#: ../../manual/game_engine/python_api/videotexture.rst:56
msgid ""
"Because ``bge.texture`` works at texture level, it is compatible with all"
" GE fancy texturing features: GLSL, multi-texture, custom shaders, etc."
msgstr ""
"Оскільки ``bge.texture`` працює на рівні текстури, то він сумісний з "
"усіма фантастичними функціями текстурування рушія GE: GLSL, "
"багато-текстура, користувацькі відтінювачі тощо."

#: ../../manual/game_engine/python_api/videotexture.rst:62
msgid "First Example"
msgstr "Перший приклад"

#: ../../manual/game_engine/python_api/videotexture.rst:64
msgid ""
"Let us assume that we have a game object with one or more faces assigned "
"to a material/image on which we want to display a video."
msgstr ""
"Припустімо, що ви маєте об'єкт гри з однією чи кількома гранями, на які "
"призначено матеріал/зображення, на яких ви хочете показувати відео."

#: ../../manual/game_engine/python_api/videotexture.rst:67
msgid ""
"The first step is to create a ``Texture`` object. We will do it in a "
"script that runs once. It can be at the start of the game, the video is "
"only played when you refresh the texture; we will come to that later. The"
" script is normally attached to the object on which we want to display "
"the video so that we can easily retrieve the object reference::"
msgstr ""
"Першим кроком буде створити об'єкт ``Texture``. Ми зробимо це у скрипті, "
"що виконується один раз. Це може бути на початку гри, відео відтворюється"
" тільки, коли ви освіжуєте текстуру; ми повернемося до цього пізніше. Цей"
" скрипт зазвичай прикріплюється до об'єкта, на якому ми хочемо показувати"
" відео, так, щоб ми могли легко отримати посилання на цей об'єкт::"

#: ../../manual/game_engine/python_api/videotexture.rst:80
msgid ""
"The check on ``video`` attribute is just a trick to make sure we create "
"the texture only once."
msgstr ""
"Перевірка атрибута ``video`` є просто хитрістю, щоб переконатися, що ми "
"створюємо текстуру тільки один раз."

#: ../../manual/game_engine/python_api/videotexture.rst:84
msgid "Find Material"
msgstr "Знаходження матеріалу"

#: ../../manual/game_engine/python_api/videotexture.rst:91
msgid ""
"``bge.texture.materialID()`` is a handy function to retrieve the object "
"material that is using ``video.png`` as texture. This method will work "
"with Blender material and UV texture. In case of UV texture, it grabs the"
" internal material corresponding to the faces that are assigned to this "
"texture. In case of Blender material, it grabs the material that has an "
"image texture channel matching the name as first channel."
msgstr ""
"``bge.texture.materialID()`` -- це зручна функція для отримання матеріалу"
" об'єкта, що використовує ``video.png`` як текстуру. Цей метод буде "
"працювати з матеріалом Blender'а та UV текстурою. У випаду UV текстури "
"він захоплює внутрішній матеріал, що відповідає граням, які призначені "
"для цієї текстури. У випадку матеріалу Blender'а він захоплює матеріал, "
"що має канал текстури зображення, що відповідає її імені як перший канал."

#: ../../manual/game_engine/python_api/videotexture.rst:98
msgid ""
"The ``IM`` prefix indicates that we are searching for a texture name but "
"we can also search for a material by giving the ``MA`` prefix. For "
"example, if we want to find the material called ``VideoMat`` on this "
"object, the code becomes::"
msgstr ""
"Префікс ``IM`` вказує, що ми шукаємо ім'я текстури, але ми можемо також "
"шукати матеріал, задавши префікс ``MA``. Наприклад, якщо ми хочемо знайти"
" матеріал, що зветься ``VideoMat`` на цьому об'єкті, то цей код стане "
"таким::"

#: ../../manual/game_engine/python_api/videotexture.rst:106
msgid "Create Texture"
msgstr "Створення текстури"

#: ../../manual/game_engine/python_api/videotexture.rst:108
msgid ""
"``bge.texture.Texture`` is the class that creates the ``Texture`` object "
"that loads the dynamic texture on the GPU. The constructor takes one "
"mandatory and three optional arguments:"
msgstr ""
"``bge.texture.Texture`` -- це клас, що створює об'єкт ``Texture``, який "
"завантажує цю динамічну текстуру на GPU. Цей конструктор приймає один "
"обов'язковий та три факультативні аргументи:"

#: ../../manual/game_engine/python_api/videotexture.rst:111
msgid "``gameObj``"
msgstr "``gameObj``"

#: ../../manual/game_engine/python_api/videotexture.rst:112
msgid "The game object."
msgstr "Об'єкт гри."

#: ../../manual/game_engine/python_api/videotexture.rst:113
msgid "``materialID``"
msgstr "``materialID``"

#: ../../manual/game_engine/python_api/videotexture.rst:114
msgid ""
"Material index as returned by ``bge.texture.materialID()``, 0 = first "
"material by default."
msgstr ""
"Індекс матеріалу як повернений ``bge.texture.materialID()``, 0 = перший "
"матеріал стандартно."

#: ../../manual/game_engine/python_api/videotexture.rst:116
msgid "``textureID``"
msgstr "``textureID``"

#: ../../manual/game_engine/python_api/videotexture.rst:116
msgid ""
"Texture index in case of multi-texture channel, 0 = first channel by "
"default. In case of UV texture, this parameter should always be 0."
msgstr ""
"Індекс текстури у випадку багато-текстурового каналу, 0 = перший канал "
"стандартно. У випадку UV текстури цей параметр повинен завжди бути 0."

#: ../../manual/game_engine/python_api/videotexture.rst:122
msgid "``textureObj``"
msgstr "``textureObj``"

#: ../../manual/game_engine/python_api/videotexture.rst:119
#, fuzzy
msgid ""
"Reference to another ``Texture`` object of which we want to reuse the "
"texture. If we use this argument, we should not create any source on this"
" texture and there is no need to refresh it either; the other ``Texture``"
" object will provide the texture for both materials/textures."
msgstr ""
"Посилання на інший об'єкт ``Texture``, на якому ми хочемо повторно "
"використати цю текстуру. Якщо ми використовуємо цей аргумент, ми не "
"повинні створювати жодне джерело на цій текстурі і немає необхідності її "
"освіжати; інший об'єкт ``Texture`` буде надавати текстуру для обох "
"матеріалів/текстур."

#: ../../manual/game_engine/python_api/videotexture.rst:130
msgid "Make Texture Persistent"
msgstr "Зроблення текстури сталою"

#: ../../manual/game_engine/python_api/videotexture.rst:132
msgid ""
"Note that we have assigned the object to a ``GameLogic``, ``video`` "
"attribute that we have created for the occasion. The reason is that the "
"``Texture`` object must be persistent across the game scripts. A local "
"variable would be deleted at the end of the script and the GPU texture "
"deleted at the same time. ``GameLogic`` module object is a handy place to"
" store persistent objects."
msgstr ""
"Зауважте, що ми призначили об'єкт атрибуту ``GameLogic``, ``video``, який"
" ми створили для цієї події. Причиною є те, що об'єкт ``Texture`` повинен"
" бути сталим, незмінним по скриптах цієї гри. Локальна змінна буде "
"виділена у кінці цього скрипту, а текстура на GPU видаляється у цей же "
"момент. Об'єкт модуля ``GameLogic`` є зручним місцем для збереження "
"сталих об'єктів."

#: ../../manual/game_engine/python_api/videotexture.rst:140
msgid "Create a Source"
msgstr "Створення джерела"

#: ../../manual/game_engine/python_api/videotexture.rst:142
msgid ""
"Now we have a ``Texture`` object but it cannot do anything because it "
"does not have any source. We must create a source object from one of the "
"possible sources available in ``bge.texture``:"
msgstr ""
"Тепер ми маємо об'єкт ``Texture``, але він не може робити нічого, "
"оскільки він не має жодного джерела. Ми повинні створити об'єкт джерела з"
" одного з доступних джерел, доступних у ``bge.texture``:"

#: ../../manual/game_engine/python_api/videotexture.rst:148
msgid "``VideoFFmpeg``"
msgstr "``VideoFFmpeg``"

#: ../../manual/game_engine/python_api/videotexture.rst:147
msgid "Moving pictures. Video file, video capture, video streaming."
msgstr "Рухомі картинки. Файл відео, захват відео, потік відео."

#: ../../manual/game_engine/python_api/videotexture.rst:152
msgid "``ImageFFmpeg``"
msgstr "``ImageFFmpeg``"

#: ../../manual/game_engine/python_api/videotexture.rst:151
msgid "Still pictures. Image file, image on web."
msgstr "Статичні картинки. Файл зображення, зображення з веб."

#: ../../manual/game_engine/python_api/videotexture.rst:156
msgid "``ImageBuff``"
msgstr "``ImageBuff``"

#: ../../manual/game_engine/python_api/videotexture.rst:155
msgid ""
"Image from application memory. For computer generated images, drawing "
"applications."
msgstr ""
"Зображення з пам'яті застосунку. Для генерованих комп'ютером зображень, "
"рисувальних застосунків."

#: ../../manual/game_engine/python_api/videotexture.rst:159
msgid "``ImageViewport``"
msgstr "``ImageViewport``"

#: ../../manual/game_engine/python_api/videotexture.rst:159
msgid ""
"Part or whole of the viewport (=rendering of the active camera displayed "
"on screen)."
msgstr ""
"Частина або все оглядвікно (=рендеринг активної камери, показуваний на "
"екрані)."

#: ../../manual/game_engine/python_api/videotexture.rst:162
msgid "``ImageRender``"
msgstr "``ImageRender``"

#: ../../manual/game_engine/python_api/videotexture.rst:162
#, fuzzy
msgid "Render of a non-active camera."
msgstr "Рендер не-активної камери."

#: ../../manual/game_engine/python_api/videotexture.rst:165
msgid "``ImageMix``"
msgstr "``ImageMix``"

#: ../../manual/game_engine/python_api/videotexture.rst:165
msgid "A mix of two or more of the above sources."
msgstr "Сумі двох або більше вищезгаданих джерел."

#: ../../manual/game_engine/python_api/videotexture.rst:167
msgid ""
"In this example we use a simple video file as source. The ``VideoFFmpeg``"
" constructor takes a file name as argument. To avoid any confusion with "
"the location of the file, we will use ``GameLogic.expandPath()`` to build"
" an absolute file name, assuming the video file is in the same directory "
"as the blend-file::"
msgstr ""
"У цьому прикладі ми використовуємо простий файл відео як джерело. "
"Конструктор ``VideoFFmpeg`` приймає ім'я файлу як аргумент. Для "
"запобігання плутанини з розташуванням цього файлу ми будемо "
"використовувати ``GameLogic.expandPath()`` для вибудування абсолютного "
"імені файлу, припускаючи, що цей файл відео є у тому ж каталогу, що й "
"даний blend-файл::"

#: ../../manual/game_engine/python_api/videotexture.rst:177
msgid ""
"We create the video source object and assign it to the ``Texture`` object"
" ``source`` attribute to set the source and make it persistent: as the "
"``Texture`` object is persistent, the source object will also be "
"persistent."
msgstr ""
"Ми створюємо об'єкт джерела відео та призначаємо його атрибуту ``source``"
" об'єкта ``Texture`` для установлення джерела та робимо його сталим: "
"оскільки об'єкт ``Texture`` є сталим, то цей об'єкт джерела також буде "
"сталим."

#: ../../manual/game_engine/python_api/videotexture.rst:181
msgid ""
"Note that we can change the ``Texture`` source at any time. Suppose we "
"want to switch between two movies during the game."
msgstr ""
"Зауважте, що ми можемо змінити джерело ``Texture`` у будь-який час. "
"Припустимо, що ми хочемо перемкнутися між двома фільмами у ході гри."

#: ../../manual/game_engine/python_api/videotexture.rst:184
msgid "We can do the following::"
msgstr "Ми можемо зробити наступне::"

#: ../../manual/game_engine/python_api/videotexture.rst:189
msgid "And then assign (and reassign) the source during the game::"
msgstr "І далі призначити (та перепризначити) джерело у ході гри::"

#: ../../manual/game_engine/python_api/videotexture.rst:195
msgid "Setup the Source"
msgstr "Укладання джерела"

#: ../../manual/game_engine/python_api/videotexture.rst:197
msgid ""
"The ``VideoFFmpeg`` source has several attributes to control the movie "
"playback:"
msgstr ""
"Джерело ``VideoFFmpeg`` має кілька атрибутів для керування відтворенням "
"фільму:"

#: ../../manual/game_engine/python_api/videotexture.rst:202
msgid "``range``"
msgstr "``range``"

#: ../../manual/game_engine/python_api/videotexture.rst:200
msgid ""
"[start,stop] (floats). Set the start and stop time of the video playback,"
" expressed in seconds from beginning. By default the entire video."
msgstr ""
"[start,stop] (floats). Задає стартовий та кінцевий час відтворення відео,"
" виражені у секундах від початку. Стандартно, це відео цілком."

#: ../../manual/game_engine/python_api/videotexture.rst:206
msgid "``repeat``"
msgstr "``repeat``"

#: ../../manual/game_engine/python_api/videotexture.rst:205
msgid "(integer). Number of video replay, -1 for infinite."
msgstr "(integer). Кількість повторень відтворення відео, -1 -- щоб безкінечно."

#: ../../manual/game_engine/python_api/videotexture.rst:210
msgid "``framerate``"
msgstr "``framerate``"

#: ../../manual/game_engine/python_api/videotexture.rst:209
msgid "(float). Relative frame rate, <1.0 for slow, >1.0 for fast."
msgstr ""
"(float). Відносна частота кадрів, <1.0 для сповільнення, >1.0 для "
"пришвидшення."

#: ../../manual/game_engine/python_api/videotexture.rst:218
msgid "``scale``"
msgstr "``scale``"

#: ../../manual/game_engine/python_api/videotexture.rst:213
#, fuzzy
msgid ""
"(bool). Set to True to activate fast nearest-neighbor scaling algorithm. "
"Texture width and height must be a power of 2. If the video picture size "
"is not a power of 2, rescaling is required. By default ``bge.texture`` "
"uses the precise but slow ``gluScaleImage()`` function. Best is to "
"rescale the video offline so that no scaling is necessary at run-time!"
msgstr ""
"(bool). Установлює True для активації швидкого алгоритму масштабування "
"найближчого сусіда. Значення ширини та висоти текстури повинні бути "
"степенем 2. Якщо розмір картинки відео не є значенням степені 2, то "
"вимагається пере-масштабування. Стандартно, ``bge.texture`` використовує "
"точну, але повільну функцію ``gluScaleImage()``. Найкраще буде "
"пере-масштабувати це відео офлайн, щоб при виконанні не було необхідності"
" його масштабувати!"

#: ../../manual/game_engine/python_api/videotexture.rst:223
msgid "``flip``"
msgstr "``flip``"

#: ../../manual/game_engine/python_api/videotexture.rst:221
msgid ""
"(bool). Set to True if the image must be vertically flipped. FFmpeg "
"always delivers the image upside down, so this attribute is set to True "
"by default."
msgstr ""
"(bool). Задає у True, якщо зображення повинно бути перевернуто "
"вертикально. FFmpeg завжди постачає зображення зверху вниз, а тому цей "
"атрибут стандартно задано як True."

#: ../../manual/game_engine/python_api/videotexture.rst:229
msgid "``filter``"
msgstr "``filter``"

#: ../../manual/game_engine/python_api/videotexture.rst:226
msgid ""
"Set additional filter on the video before sending to GPU. Assign to one "
"of ``bge.texture`` filter object. By default the image is send unchanged "
"to the GPU. If an alpha channel is present in the video, it is "
"automatically loaded and sent to the GPU as well."
msgstr ""
"Задає додатковий фільтр на відео перед посиланням на GPU. Призначається "
"одному з об'єктів фільтра для ``bge.texture``. Стандартно, це зображення "
"посилається незміненим на GPU. Якщо канал альфа наявний у відео, то він "
"також автоматично завантажується та посилається на GPU."

#: ../../manual/game_engine/python_api/videotexture.rst:231
#, fuzzy
msgid ""
"We will simply set the ``scale`` attribute to True because the "
"``gluScaleImage()`` is really too slow for real-time video. In case the "
"video dimensions are already a power of 2, it has no effect. ::"
msgstr ""
"Ми просто установимо атрибут ``scale`` як True, оскільки "
"``gluScaleImage()`` є фактично надто повільним для відео у реальному "
"часі. У випадку, якщо розміри відео вже є значенням степені 2, то це не "
"має ефекту. ::"

#: ../../manual/game_engine/python_api/videotexture.rst:239
msgid "Play the Video"
msgstr "Відтворення відео"

#: ../../manual/game_engine/python_api/videotexture.rst:241
msgid "We are now ready to play the video::"
msgstr "Тепер ми готові для відтворення відео::"

#: ../../manual/game_engine/python_api/videotexture.rst:245
msgid ""
"Video playback is not a background process: it happens only when we "
"refresh the texture. So we must have another script that runs on every "
"frame and calls the ``refresh()`` method of the ``Texture`` object::"
msgstr ""
"Відтворення відео не є фоновим процесом: воно відбувається тільки тоді, "
"коли ми освіжуємо цю текстуру. Тому ми повинні мати інший скрипт, що "
"виконується у кожному кадрі та викликає метод ``refresh()`` об'єкта "
"``Texture``::"

#: ../../manual/game_engine/python_api/videotexture.rst:252
msgid ""
"If the video source is stopped, ``refresh()`` has no effect. The argument"
" of ``refresh()`` is a flag that indicates if the texture should be "
"recalculated on next refresh. For video playback, you definitively want "
"to set it to True."
msgstr ""
"Якщо це джерело відео зупинене, то ``refresh()`` немає жодного ефекту. "
"Аргумент ``refresh()`` є стягом, що вказує, чи повинна бути ця текстура "
"перерахована при наступному освіженні. Для відтворення відео ви визначено"
" схочете задати його як True."

#: ../../manual/game_engine/python_api/videotexture.rst:259
msgid "Checking the Video Status"
msgstr "Перевірка стану відео"

#: ../../manual/game_engine/python_api/videotexture.rst:261
msgid ""
"Video source classes (such as VideoFFMpeg) have an attribute ``status``. "
"If video is playing, its value is 2, if it's stopped, it's 3. So in our "
"example::"
msgstr ""
"Класи джерела відео (такі як VideoFFMpeg) мають атрибут ``status``. Якщо "
"відео відтворюється, то його значення є 2, якщо воно зупинене, то -- 3. "
"Тому, у нашому прикладі::"

#: ../../manual/game_engine/python_api/videotexture.rst:270
msgid "Advanced Workflow"
msgstr "Просунутий порядок роботи"

#: ../../manual/game_engine/python_api/videotexture.rst:272
msgid ""
"True argument in ``Texture.refresh()`` method simply invalidates the "
"image buffer after sending it to the GPU so that on next frame, a new "
"image will be loaded from the source. It has the side effect of making "
"the image unavailable to Python. You can also do it manually by calling "
"the ``refresh()`` method of the source directly."
msgstr ""
"Аргумент True у методі ``Texture.refresh()`` просто звільняє буфер "
"зображення після посилання його на GPU, так що на наступному кадрі нове "
"зображення буде завантажене з джерела. Він має побічний ефект, що робить "
"зображення недоступним для Python. Ви можете також зробити це вручну, "
"викликавши метод ``refresh()``для джерела безпосередньо."

#: ../../manual/game_engine/python_api/videotexture.rst:277
#, fuzzy
msgid "Here are some possible advanced workflow:"
msgstr "Ось деякий можливий просунутий порядок роботи:"

#: ../../manual/game_engine/python_api/videotexture.rst:279
msgid "Use the image buffer in Python (does not effect the Texture)::"
msgstr "Використати буфер зображення у Python (не впливає на Texture)::"

#: ../../manual/game_engine/python_api/videotexture.rst:288
msgid "Load image from source for Python processing without download to GPU:"
msgstr ""
"Завантажити зображення з джерела для оброблення Python без завантаження "
"на GPU:"

#: ../../manual/game_engine/python_api/videotexture.rst:289
msgid "Note that we do not even call refresh on the Texture."
msgstr "Зауважте, що ми навіть не викликали освіження на Texture."

#: ../../manual/game_engine/python_api/videotexture.rst:290
msgid "We could also just create a source object without a Texture object::"
msgstr "Ми можемо також просто створити об'єкт джерела без об'єкта Texture::"

#: ../../manual/game_engine/python_api/videotexture.rst:296
msgid ""
"If you have more than one material on the mesh and you want to modify a "
"texture of one particular material, get its ID::"
msgstr ""
"Якщо ви маєте більше, ніж один матеріал на сіті, і хочете модифікувати "
"текстуру конкретного матеріалу, то отримайте його ID::"

#: ../../manual/game_engine/python_api/videotexture.rst:301
msgid ""
"GLSL material can have more than one texture channel, identify the "
"texture by the texture slot where it is defined, here two::"
msgstr ""
"GLSL матеріал може мати більше, ніж один, канал текстури, ідентифікувати "
"текстуру за гніздом текстури, де вона визначена::"

#: ../../manual/game_engine/python_api/videotexture.rst:308
msgid "Advanced Demos"
msgstr "Просунуті демо"

#: ../../manual/game_engine/python_api/videotexture.rst:310
msgid ""
"Here is a `demo "
"<http://www.graphicall.org/ftp/ben2610/VideoTextureDemo2video.blend>`__ "
"that demonstrates the use of two videos alternatively on the same "
"texture. Note that it requires an additional video file which is the "
"*Elephant Dream* teaser. You can replace it with another file that you "
"want to run the demo."
msgstr ""
"Ось демо -- `demo "
"<http://www.graphicall.org/ftp/ben2610/VideoTextureDemo2video.blend>`__ ,"
" що демонструє використання двох відео, альтернативно на одній і тій же "
"текстурі. Зауважте, що це вимагає додаткового файлу відео, який є тизером"
" *Elephant Dream*. Ви можете замінити його іншим файлом, з яким ви хочете"
" виконати це демо."

#: ../../manual/game_engine/python_api/videotexture.rst:315
msgid ""
"Here is a `demo "
"<http://www.graphicall.org/ftp/ben2610/VideoTextureDemo2videoMix.blend>`__"
" that demonstrates the use of the ``ImageMix`` source. ``ImageMix`` is a "
"source that needs sources, which can be any other ``Texture`` source, "
"like ``VideoFFmpeg``, ``ImageFFmpeg`` or ``ImageRender``. You set them "
"with ``setSource()`` and their relative weight with ``setWeight()``. Pay "
"attention that the weight is a short number between 0 and 255, and that "
"the sum of all weights should be 255. ``ImageMix`` makes a mix of all the"
" sources according to their weights. The sources must all have the same "
"image size (after reduction to the nearest power of two dimension). If "
"they do not, you will get a Python error on the console."
msgstr ""
"Ось демо `demo "
"<http://www.graphicall.org/ftp/ben2610/VideoTextureDemo2videoMix.blend>`__,"
" що демонструє використання джерела ``ImageMix``. ``ImageMix`` -- це "
"джерело, що потребує джерел, які можуть бути іншим джерелом ``Texture``, "
"як ``VideoFFmpeg``, ``ImageFFmpeg`` або ``ImageRender``. Ви установлюєте "
"їх за допомогою ``setSource()`` та їх відносну вагомість за допомогою "
"``setWeight()``. Зверніть увагу, що вагомість є коротким числом між 0 та "
"255, і що сума усіх вагомостей повинна бути 255. ``ImageMix`` робить "
"суміш усіх джерел відповідно до їх вагомостей. Ці джерела повинні усі "
"мати однаковий розмір зображення (після зменшення розміру до найближчої "
"степені двійки). Якщо це не так, то ви отримаєте помилку Python у "
"консолі."

