# SOME DESCRIPTIVE TITLE.
# Copyright (C) : This page is public domain as CC0
# This file is distributed under the same license as the Blender Reference
# Manual package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
# urko <urkokul@gmail.com>, 2018.
#
msgid ""
msgstr ""
"Project-Id-Version: Blender 2.78 Manual 2.78\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-04-17 01:30+0200\n"
"PO-Revision-Date: 2018-02-19 03:41+0200\n"
"Last-Translator: urko <urkokul@gmail.com>\n"
"Language: uk\n"
"Language-Team: \n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.3\n"

#: ../../manual/game_engine/physics/introduction.rst:4
msgid "Introduction"
msgstr "Вступ"

#: ../../manual/game_engine/physics/introduction.rst:6
#, fuzzy
msgid ""
"Blender includes advanced physics simulation in the form of the Bullet "
"Physics Engine (`Bullet Physics <http://bulletphysics.org>`__). Most of "
"your work will involve setting the right properties on the objects in "
"your scene, then you can sit back and let the engine take over. The "
"physics simulation can be used for games, but also for animation."
msgstr ""
"Blender включає просунуту імітацію, симуляцію фізики у формі рушія фізики"
" Bullet Physics Engine (`Bullet Physics <http://bulletphysics.org>`__). "
"Більшість вашої роботи передбачатиме установлення правильних властивостей"
" на об'єктах у вашій сцені, далі ви можете сидіти, склавши руки, та "
"дозволити рушію зробити все інше. Імітація фізики може використовуватися "
"для Ігор, а також для Анімації."

#: ../../manual/game_engine/physics/introduction.rst:12
msgid ""
"The Blender Game Engine (BGE) is based on rigid body physics, which "
"differs significantly from the complementary set of tools available in "
"the form of soft body physics simulations. Though the BGE does have a "
"soft body type, it is not nearly as nuanced as the non-BGE soft body. The"
" inverse is even more true: it is difficult to get the non-BGE physics to"
" resemble anything like a stiff shape. Rigid body physics does not have, "
"as an effect or a cause, any mesh deformations. For a discussion on how "
"to partially overcome this, see: `Mesh Deformations`_."
msgstr ""

#: ../../manual/game_engine/physics/introduction.rst:24
msgid "Global Options"
msgstr "Глобальні Опції -- Global Options"

#: ../../manual/game_engine/physics/introduction.rst:26
msgid ""
"The global Physics Engine settings can be found in the :doc:`World "
"Properties </game_engine/physics/world>`, which include the Gravity "
"constant and some important engine performance tweaks."
msgstr ""
"Глобальні устави Рушія Фізики можна знайти тут -- :doc:`World Properties "
"</game_engine/physics/world>`, які включають константу Гравітації та "
"деякі важливі підправлення продуктивності рушія."

#: ../../manual/game_engine/physics/introduction.rst:31
msgid "Object Physics"
msgstr "Фізика Об'єкта -- Object Physics"

#: ../../manual/game_engine/physics/introduction.rst:35
msgid "See :ref:`game-engine-physics-types` in this chapter."
msgstr "Дивіться детальніше тут -- :ref:`game-engine-physics-types`."

#: ../../manual/game_engine/physics/introduction.rst:39
msgid "Material Physics"
msgstr "Фізика Матеріалу -- Material Physics"

#: ../../manual/game_engine/physics/introduction.rst:41
msgid ""
"Physics can be associated with a material on the material properties tab."
" These are settings that one would normally associate with a material, "
"such has its friction and they are meant to be used in conjunction with "
"the object physics settings, not replace it."
msgstr ""
"Фізика може бути асоційована з матеріалом на вкладці властивостей "
"матеріалу. Ці устави, які зазвичай асоціюються з матеріалом, зокрема, "
"його тертя, і вони призначені для використання у поєднанні з уставами "
"фізики об'єкта, а не мають заміняти їх."

#: ../../manual/game_engine/physics/introduction.rst:48
msgid "Constraints"
msgstr "Примуси -- Constraints"

#: ../../manual/game_engine/physics/introduction.rst:50
#, fuzzy
msgid ""
"It is imperative to understand that the Blender constraints generally do "
"not work inside the BGE. This means interesting effects such as *Copy "
"Rotation* are unavailable directly."
msgstr ""
"Слід категорично зрозуміти, що Примуси Blender'а зазвичай не працюють "
"всередині BGE. Це означає, що цікаві ефекти, такі як *Copy Rotation*, є "
"недоступні безпосередньо."

#: ../../manual/game_engine/physics/introduction.rst:53
msgid "Your options include:"
msgstr "Ваші доступні варіанти:"

#: ../../manual/game_engine/physics/introduction.rst:55
#, fuzzy
msgid ""
":doc:`Parenting </editors/3dview/object/properties/relations/parents>` --"
" But not Vertex Parenting."
msgstr ""
"Приріднення -- :doc:`Parenting "
"</editors/3dview/object/properties/relations/parents>` - Але не "
"приріднення до вершин -- Vertex Parenting."

#: ../../manual/game_engine/physics/introduction.rst:56
#, fuzzy
msgid ""
":doc:`Rigid Body Joint "
"</rigging/constraints/relationship/rigid_body_joint>` -- This is the one "
"constraint that you can set up through the UI that works in the BGE. It "
"has several options, and can be very powerful -- see ITS page for a "
"detailed description and demo blend-file. Do not forget that you can loop"
" through objects using ``bpy`` instead of clicking thousands of times to "
"set up chains of these constraints."
msgstr ""
"Сполучення Твердого Тіла -- :doc:`Rigid Body Joint "
"</rigging/constraints/relationship/rigid_body_joint>` -- Це єдиний "
"Примус, який ви можете установити через інтерфейс користувача у BGE. Він "
"має кілька опцій й може бути дуже потужним -- дивіться сторінку ITS для "
"детального опису та демо blend-файл. Не забувайте, що ви можете "
"зациклювати об'єкти за допомогою ``bpy``, замість клацання тисячі раз для"
" укладання ланцюгів цих Примусів."

#: ../../manual/game_engine/physics/introduction.rst:61
#, fuzzy
msgid ""
"Rigid body joints on-the-fly -- You can add/remove them after the BGE "
"starts by using ``bge.constraints.createConstraint()``. This can be good "
"either to simply automate their setup, or to truly make them dynamic. A "
"simple demo can be viewed in: `BGE-Physics-"
"DynamicallyCreateConstraint.blend "
"<https://wiki.blender.org/index.php/Media:BGE-Physics-"
"DynamicallyCreateConstraint.blend>`__"
msgstr ""
"Сполучення Твердого Тіла на Льоту -- Ви можете додавати/вилучати їх після"
" запуску BGE за допомогою ``bge.constraints.createConstraint()``. Це може"
" бути добрим, щоб просто автоматизувати їх уклад або по-справжньому "
"зробити їх динамічними. Просте демо можна переглянути тут: `BGE-Physics-"
"DynamicallyCreateConstraint.blend "
"<https://wiki.blender.org/index.php/Media:BGE-Physics-"
"DynamicallyCreateConstraint.blend>`__"

#: ../../manual/game_engine/physics/introduction.rst:66
msgid ""
":doc:`Python Controllers </game_engine/logic/controllers/types/python>` "
"-- As always, in the BGE, you can get the most power when you drop into "
"Python and start toying with the settings directly. For instance, the "
"*Copy Rotation* mentioned above is not hard -- All you have to do is "
"something to the effect of ``own.worldOrientation = "
"bge.logic.getCurrentScene().objects['TheTargetObject'].worldOrientation``"
msgstr ""
"Контролери Python -- :doc:`Python Controllers "
"</game_engine/logic/controllers/types/python>` -- Як завжди, у BGE, ви "
"можете отримати максимальну потужність, коли занурюєтеся у Python та "
"починаєте гратися з уставами безпосередньо. Наприклад, примус *Copy "
"Rotation*, згаданий вище, укласти не важко -- Все, що ви маєте зробити, "
"-- це щось подібне на ефект -- ``own.worldOrientation = "
"bge.logic.getCurrentScene().objects['TheTargetObject'].worldOrientation``"

#: ../../manual/game_engine/physics/introduction.rst:74
msgid "Visualizing Physics"
msgstr "Візуалізація Фізики -- Visualizing Physics"

#: ../../manual/game_engine/physics/introduction.rst:78
msgid ""
"Go to :menuselection:`Game --> Show Physics Visualization` to show lines "
"representing various attributes of the Bullet representation of your "
"objects. Note that these might be easier to see when you turn on "
"Wireframe Mode :kbd:`Z` before you press :kbd:`P`. Also note that you can"
" see how the Bullet triangulation is working (it busts all your Quads to "
"Tris at run-time, but the BGE meshes are still quads at run-time)."
msgstr ""
"Увімкніть стяг :menuselection:`Game --> Show Physics Visualization` для "
"показу ліній, що представляють різні атрибути представлення Bullet ваших "
"об'єктів. Зауважте, що їх може бути легшим бачити, коли ви перемкнетеся у"
" каркасний режим -- Wireframe Mode :kbd:`Z`, перед тим, як натиснете "
":kbd:`P`. Також, зверніть увагу, що ви можете бачити, як трибічникування,"
" тріангуляція Bullet працює (це дасть при виконанні перетворення "
"чотирибічників у трибічники, але сіті BGE все ще залишатимуться "
"чотирибічними)."

#: ../../manual/game_engine/physics/introduction.rst:85
msgid ""
"*RGB/XYZ Widget* -- Representing the object's Local Orientation and "
"Origin."
msgstr ""
"Віджет *RGB/XYZ Widget* -- Представлення Локальних Орієнтації та Початку "
"об'єкта."

#: ../../manual/game_engine/physics/introduction.rst:86
msgid ""
"*Green* -- \"sleeping meshes\" that are not moving, saving calculations "
"until an external event \"wakes\" them."
msgstr ""
"*Зелений* -- «сплячі сіті», що не рухаються, зберігають розрахування, "
"допоки зовнішня подія «не розбудить» їх."

#: ../../manual/game_engine/physics/introduction.rst:87
msgid ""
"*White* -- White lines represent active bounding meshes at are undergoing"
" physics calculations, until such calculations are so small that the "
"object is put to rest. This is how you can see the effects of the "
"*Collision Bounds*. - *Thick*, or *Many White Lines* -- A compound "
"collision mesh/meshes."
msgstr ""
"*Білий* -- Білі лінії представляють активні межові сіті у процесі "
"розрахування фізики, допоки такі розрахування є такі малі, що об'єкт "
"залишається у спокої. Це те, як ви можете бачити ефекти меж зіткнення -- "
"*Collision Bounds*. - *Товсті* або *Багато Білих Ліній* -- складене "
"зіткнення сіті/сітей."

#: ../../manual/game_engine/physics/introduction.rst:91
#, fuzzy
msgid "*Violet* -- Bounding meshes for soft bodies."
msgstr "*Фіолетовий* -- Межові сіті для М'яких тіл."

#: ../../manual/game_engine/physics/introduction.rst:92
#, fuzzy
msgid ""
"*Red* -- The bounding box, the outer boundary of object. It is always "
"aligned with global X, Y and Z, and is used to optimize calculations. "
"Also represents meshes that have been forced into \"no sleep\" status."
msgstr ""
"*Червоний* -- Габаритна Коробка (Bounding Box), зовнішня границя об'єкта."
" Вона завжди вирівнюється по глобальних X Y та Z та використовується для "
"оптимізації розрахунків. Також представляє сіті, що були примушені бути у"
" «не сплячому» стані."

#: ../../manual/game_engine/physics/introduction.rst:95
msgid "*Yellow* -- Normals."
msgstr "*Жовтий* -- Нормалі."

#: ../../manual/game_engine/physics/introduction.rst:96
msgid "*Black* -- When in wireframe, this is your mesh's visual appearance."
msgstr "*Чорний* -- Коли у каркасному режимі, це візуальний вигляд вашої сіті."

#: ../../manual/game_engine/physics/introduction.rst:98
msgid ""
"If you want finer-grained control over the display options, you can add "
"this as a Python Controller and uncomment whichever pieces you want to "
"see::"
msgstr ""
"Якщо ви хочете більш детальне керування опціями показу, ви можете додати "
"їх як контролер Python та розкоментувати частини, які ви хочете бачити::"

#: ../../manual/game_engine/physics/introduction.rst:108
msgid "For all debug modes, API docs for ``bge.constraints``."
msgstr "Для усіх режимів налагодження, документація API для ``bge.constraints``."

#: ../../manual/game_engine/physics/introduction.rst:112
msgid "Show Framerate and Profile"
msgstr "Показати Частоту кадрів та Профіль -- Show Framerate and Profile"

#: ../../manual/game_engine/physics/introduction.rst:116
msgid ""
"A shot of `Manual-BGE-Physics-DancingSticks.blend "
"<https://wiki.blender.org/index.php/Media:Manual-BGE-Physics-"
"DancingSticks.blend>`__ with :menuselection:`Game --> Show Framerate and "
"Profile` enabled."
msgstr ""
"Знімок вікна з файлом `Manual-BGE-Physics-DancingSticks.blend "
"<https://wiki.blender.org/index.php/Media:Manual-BGE-Physics-"
"DancingSticks.blend>`__ з увімкненим :menuselection:`Game --> Show "
"Framerate and Profile`."

#: ../../manual/game_engine/physics/introduction.rst:120
#, fuzzy
msgid ""
"If you enable :menuselection:`Game --> Show Framerate and Profile`, it "
"will put some statistics in the upper left area of the game window."
msgstr ""
"Якщо ви увімкнете :menuselection:`Game --> Show Framerate and Profile`, "
"то це поставить деяку статистику у верхню ліву частину вікна гри."

#: ../../manual/game_engine/physics/introduction.rst:125
msgid ""
"These can be very informative, but also a bit cryptic. Moguri has "
"elaborated on their meanings, for us: `Moguri's blog "
"<https://mogurijin.wordpress.com/2012/01/03/bge-profile-stats-and-what-"
"they-mean/>`__."
msgstr ""
"Ці записи можуть бути дуже інформативними, але також трохи загадковими. "
"Moguri розробив їх значення для нас: `Moguri's blog "
"<https://mogurijin.wordpress.com/2012/01/03/bge-profile-stats-and-what-"
"they-mean/>`__."

#: ../../manual/game_engine/physics/introduction.rst:130
msgid "Mesh Deformations"
msgstr "Деформування Сіті -- Mesh Deformations"

#: ../../manual/game_engine/physics/introduction.rst:132
#, fuzzy
msgid ""
"As mentioned above, rigid body physics do not affect mesh deformations, "
"nor do they account for them in the physics model. This leaves you with a"
" few options:"
msgstr ""
"Як згадувалося вище, фізики Rigid Body не впливає на деформування сіті й "
"останні не враховуються у моделі фізики. Це залишає вам кілька варіантів:"

#: ../../manual/game_engine/physics/introduction.rst:137
msgid "Soft Bodies"
msgstr "М'які Тіла -- Soft Bodies"

#: ../../manual/game_engine/physics/introduction.rst:139
#, fuzzy
msgid ""
"You can try using a :doc:`soft body "
"</game_engine/physics/types/soft_body>`, but these are fairly hard to "
"configure well."
msgstr ""
"Ви можете спробувати використовувати м'які тіла -- :doc:`Soft Body "
"</game_engine/physics/types/soft_body>`, але конфігурувати досить "
"складно."

#: ../../manual/game_engine/physics/introduction.rst:144
msgid "Actions"
msgstr "Дії -- Actions"

#: ../../manual/game_engine/physics/introduction.rst:146
#, fuzzy
msgid ""
"To use an :doc:`Action Actuator "
"</game_engine/logic/actuators/types/action>` to do the deformation, you "
"have to make a choice. If you use *shape keys* in the Action, you will be"
" fine as far as the overall collisions (but see below for the note on "
"``reinstancePhysicsMesh()``). The mesh itself is both a display and a "
"physics mesh, so there is not much to configure."
msgstr ""
"Щоб скористатися актуатором -- :doc:`Action Actuator "
"</game_engine/logic/actuators/types/action>` для зроблення такого "
"деформування, ви повинні зробити вибір. Якщо ви використовуєте ключі форм"
" -- Shapekeys у дії -- Action, то це настільки ж добре, як вжити загальні"
" зіткнення (але дивіться нижче примітку про ``reinstancePhysicsMesh()``)."
" Сама сіть є показуваною та фізичною сіттю, а тому конфігурувати вже не "
"так і багато."

#: ../../manual/game_engine/physics/introduction.rst:151
#, fuzzy
msgid ""
"To use an *armature* as the deformer will require a bit of extra thought "
"and effort. Basically the armature will only deform a mesh if the "
"armature is the parent of that mesh. But at that point, your mesh will "
"lose its physics responsiveness, and only hang in the air (it is copying "
"the location/rotation of the armature). To somewhat fix this you can then"
" parent the armature to a collision mesh (perhaps a simple box or "
"otherwise very low-poly mesh). This \"Deformation Mesh\" will be the "
"physics representative, being type: Dynamic or Rigid Body, but it will be"
" set to Invisible. Then \"display mesh\" will be the opposite set to *No "
"Collision*, but visible. This still leaves the problem mentioned in the "
"previous paragraph."
msgstr ""
"Для використання арматури Armature як деформера буде потрібно трохи "
"більше роздумувань та зусиль. Базово Armature буде деформувати тільки "
"сіть, якщо Арматура є предком для такої сіті. Але у такий момент, ваша "
"сіть буде втрачати її фізичну чутливість і буде лише висіти у повітрі "
"(вона копіює локацію/оберт Арматури). Для деякого виправлення цього ви "
"можете далі приріднити Арматуру до сіті зіткнення (можливо простої "
"коробки або іншої сіті з дуже малою кількістю полігонів). Ця «Сіть "
"Деформування» буде представником фізики, будучи типом: Dynamic або Rigid "
"Body, але установлена як Невидима. Далі «Показувана Сіть» буде навпаки "
"задана як *Без Зіткнення*, але видима. Це все ще залишає проблему, "
"згадану у попередньому параграфі."

#: ../../manual/game_engine/physics/introduction.rst:161
msgid ""
"When you deform a display mesh, it does not update the corresponding "
"physics mesh. You can view this evidently when you enable physics "
"visualization (`Visualizing Physics`_) -- the collision bounds will "
"remain exactly as when they began. To fix this, you must call "
"``own.reinstancePhysicsMesh()`` in some form. Currently this only works "
"on *Triangle Mesh* bounds, not *Convex Hull*. We have prepared a "
"demonstration file in `Manual-BGE-Physics-DancingSticks.blend "
"<https://wiki.blender.org/index.php/Media:Manual-BGE-Physics-"
"DancingSticks.blend>`__. Note that, we had to increase the "
":menuselection:`World --> Physics --> Physics Steps --> Substeps` to make"
" the collisions work well. The more basic case is the case the Shapekeyed"
" Action, which you can see in the back area of the scene. Since it is the"
" only object involved, you can call ``reinstancePhysicsMesh()`` "
"unadorned, and it will do the right thing."
msgstr ""
"Коли ви деформуєте показувану сіть, то це не оновлює відповідну фізичну "
"сіть. Ви можете це явно бачити, коли увімкнете візуалізацію фізики "
"(`Visualizing Physics`_) -- межі зіткнення будуть залишатися точно "
"такими, як на початку. Для виправлення цього ви повинні викликати "
"``own.reinstancePhysicsMesh()`` в якійсь формі. Поточно це працює тільки "
"для меж трибічникової сіті -- *Triangle Mesh*, а не для опуклої оболонки "
"-- *Convex Hull*. Ми підготували демонстраційний файл -- `Manual-BGE-"
"Physics-DancingSticks.blend <https://wiki.blender.org/index.php/Media"
":Manual-BGE-Physics-DancingSticks.blend>`__. Зауважте, що ми підвищили "
"уставу :menuselection:`World --> Physics --> Physics Steps --> Substeps`,"
" що примусити зіткнення добре працювати. Більш базовий випадок -- дія з "
"ключами форм -- Shapekeyed Action, яку ви можете бачити у задній області "
"сцени. Оскільки задіяно лише один об'єкт, то ви можете викликати "
"``reinstancePhysicsMesh()`` без аргументів і він зробить це правильно."

#: ../../manual/game_engine/physics/introduction.rst:175
#, fuzzy
msgid ""
"The more complicated case is the :menuselection:`Collision Mesh --> "
"Armature --> Display Mesh` cluster, which you can see in the front of the"
" scene. What it does in the blend-file is call "
"``reinstancePhysicsMesh(viz)``, that is, passing in a reference to the "
"visual mesh. If we tried to establish this relationship without the use "
"of Python, we would find that Blender's dependency check system would "
"reject it as a cyclic setup. This is an example of where Blender's "
"checking is too coarsely-grained, as this circle is perfectly valid: the "
"grandparent object (the collision mesh) controls the location/rotation, "
"while the middle object (the armature) receives the animated Action, "
"where the child (the Display Mesh) receives the deformation, and passes "
"that on up to the top, harmlessly. Something to note is that the "
"collision mesh is merely a plane -- that is all it requires for this, "
"since it will be getting the mesh data from ``viz``."
msgstr ""
"Більш складний випадок -- кластер :menuselection:`Collision Mesh --> "
"Armature --> Display Mesh`, який ви можете бачити у передній області "
"сцени. Те, що він робить у цьому blend-файлі -- це виклик "
"``reinstancePhysicsMesh(viz)``, тобто, передавання посилання на візуальну"
" сіть. Якщо ми б намагалися встановити це відношення без використання "
"Python, то ми виявили б, що система перевірки залежностей у Blender'а "
"відкинула його як зациклений уклад. Це приклад того, де перевірка "
"Blender'а є надто груба, оскільки ця зацикленість є ідеально допустимою: "
"об'єкт-предок вищого рівня (ця Сіть Зіткнення) керує локацією/обертанням,"
" тоді як предок рівня під ним -- середній об'єкт (ця Арматура) приймає "
"анімовану Дію, а нащадок (ця Показувана Сіть) отримує деформування та "
"передає його нагору без шкоди. Слід зауважити, що Сіть Зіткнення є просто"
" площиною -- тобто, це все, що вимагається тут, оскільки вона отримує "
"дані сіті від ``viz``."

#: ../../manual/game_engine/physics/introduction.rst:191
msgid "Ragdolls"
msgstr "«Ганчіркові ляльки» -- Ragdolls"

#: ../../manual/game_engine/physics/introduction.rst:193
#, fuzzy
msgid ""
"A third option is to create your items out of many sub-objects, connected"
" together with *rigid body joints* or similar. This can be quite a bit "
"more work, but the results can be much more like a realistic response to "
"collisions. For an add-on that can help you out in the process, check out"
" the `Blender Ragdoll Implementation Kit "
"<https://wiki.blender.org/index.php/Extensions:2.6/Py/Scripts/Game_Engine/BRIK_ragdolls>`__."
msgstr ""
"Третій варіант -- створити об'єкти з багатьох під-об'єктів, з'єднаних між"
" собою за допомогою Rigid Body Joint або подібним чином. Це може вимагати"
" трохи більше роботи, але результати можуть бути більш подібними на "
"реалістичну реакцію на зіткнення. Про Додаток, що може допомогти вам у "
"цьому процесі, дивіться тут -- `Blender Ragdoll Implementation Kit "
"<https://wiki.blender.org/index.php/Extensions:2.6/Py/Scripts/Game_Engine/BRIK_ragdolls>`__."

#: ../../manual/game_engine/physics/introduction.rst:203
msgid "Digging Deeper"
msgstr "Копання Глибше -- Digging Deeper"

#: ../../manual/game_engine/physics/introduction.rst:205
msgid "Sometimes you will want to look at:"
msgstr "Іноді ви схочете подивитися тут:"

#: ../../manual/game_engine/physics/introduction.rst:207
msgid "The `main Bullet Physics page <http://bulletphysics.org/wordpress/>`__"
msgstr "The `main Bullet Physics page <http://bulletphysics.org/wordpress/>`__"

#: ../../manual/game_engine/physics/introduction.rst:208
msgid ""
"The `Bullet Wiki "
"<http://www.bulletphysics.org/mediawiki-1.5.8/index.php?title=Documentation>`__"
msgstr ""
"The `Bullet Wiki "
"<http://www.bulletphysics.org/mediawiki-1.5.8/index.php?title=Documentation>`__"

#: ../../manual/game_engine/physics/introduction.rst:209
msgid ""
"The `Bullet API Docs "
"<http://www.continuousphysics.com/Bullet/BulletFull/index.html>`__"
msgstr ""
"The `Bullet API Docs "
"<http://www.continuousphysics.com/Bullet/BulletFull/index.html>`__"

#: ../../manual/game_engine/physics/introduction.rst:210
msgid "The `Bullet Forums <http://www.bulletphysics.org/Bullet/phpBB3/>`__"
msgstr "The `Bullet Forums <http://www.bulletphysics.org/Bullet/phpBB3/>`__"

#: ../../manual/game_engine/physics/introduction.rst:214
msgid "Recording to Keyframes"
msgstr "Записування у Ключкадри -- Recording to Keyframes"

#: ../../manual/game_engine/physics/introduction.rst:216
#, fuzzy
msgid ""
"Beyond gaming, sometimes you wish to render a complex scene that involves"
" collisions, multiple forces, friction between multiple bodies, and air "
"drag or even a simple setup that is just easier to achieve using the "
"real-time physics."
msgstr ""
"Поза іграми, інколи ви схочете рендерити складну сцену, що задіює "
"зіткнення, одночасно кілька сил, тертя між одночасно кількома тілами та "
"опір повітря чи навіть простий уклад, що просто легше досягти, "
"використовуючи реально-часову фізику."

#: ../../manual/game_engine/physics/introduction.rst:220
msgid ""
"Blender provides a way to ''bake'' or ''record'' a physics simulation "
"into keyframes allowing it then to be played as an action either for "
"animation or games. Keep in mind that the result of this method is a "
"recording, no longer a simulation. This means that the result is "
"completely deterministic (the same every time it is run) and unable to "
"interact with new objects that are added to the physics simulation after "
"it was recorded. This may, or not, be desired according to the situation."
msgstr ""
"Blender надає спосіб «запікання» або «запису» імітації фізики у "
"ключкадри, дозволяючи далі відтворювати її як дію для анімації або ігор. "
"Майте на увазі, що результатом цьому методу буде запис, більше не "
"імітація. Це означає, що цей результат є повністю детермінований "
"(однаковий при кожному виконанні) і не у змозі взаємодіяти з новими "
"об'єктами, що додаються в імітацію фізики після того, як вона була "
"записана. Це можливо або ні бути бажаним, відповідно до ситуації."

#: ../../manual/game_engine/physics/introduction.rst:230
msgid "Menu to record Keyframes to the Dope Sheet."
msgstr "Пункт меню для запису Ключкадрів в Аркуші Експозицій -- Dope Sheet."

#: ../../manual/game_engine/physics/introduction.rst:232
msgid ""
"All you have to do to achieve this effect is go to the Info Editor (the "
"bar at the top of the window) :menuselection:`Game --> Record Animation`,"
" and it will lock away your keyframes for use in *Blender Render* mode. "
"You can go back to the 3D View and press :kbd:`Alt-A` to play it back, or"
" :kbd:`Ctrl-F12` to render it out as an animation."
msgstr ""
"Все, що вам потрібно зробити для досягнення цього ефекту, -- це перейти у"
" редактор Info Editor (смуга вгорі вікна), увімкнути :menuselection:`Game"
" --> Record Animation`, і це зблокує ваші ключкадри для використання у "
"режимі *Blender Render*. Ви можете повернутися у редактор 3D View та "
"натиснути :kbd:`Alt-A` для відтворення або :kbd:`Ctrl-F12` для рендерингу"
" як анімації."

#: ../../manual/game_engine/physics/introduction.rst:238
msgid ""
"Note that you can also use Game Logic Bricks and scripting. Everything "
"will be recorded."
msgstr ""
"Зауважте, що ви можете також використовувати цеглини логіки гри та "
"скриптування. Все буде записано."

#: ../../manual/game_engine/physics/introduction.rst:242
msgid "Keyframe Clean-up"
msgstr "Вичищення Ключкадрів -- Keyframe Clean-up"

#: ../../manual/game_engine/physics/introduction.rst:246
msgid "Resulting recorded animation."
msgstr "Результатна записана анімація."

#: ../../manual/game_engine/physics/introduction.rst:248
msgid ""
"*Record Animation* keys redundant data (data that was did not change "
"relative to the last frame). Pressing :kbd:`O` while in the *Dope Sheet* "
"will remove all superfluous keyframes. Unwanted channels can also be "
"removed."
msgstr ""
"*Запис Анімації* ключує зайві дані (дані, що не були змінені відносно "
"останнього кадру). Натискання :kbd:`O` при знаходженні у режимі *Dope "
"Sheet* вилучить усі ці зайві ключкадри. Небажані канали можуть також бути"
" вилучені."

#: ../../manual/game_engine/physics/introduction.rst:254
msgid "Cleaned up recording."
msgstr "Вичищення запису."

#: ../../manual/game_engine/physics/introduction.rst:258
msgid "Exporting"
msgstr "Експортування -- Exporting"

#: ../../manual/game_engine/physics/introduction.rst:261
msgid ".bullet / Bullet Compatible Engines"
msgstr ".bullet / Bullet Compatible Engines"

#: ../../manual/game_engine/physics/introduction.rst:263
msgid "You can snapshot the physics world at any time with the following code::"
msgstr ""
"Ви можете зазнімкувати світ фізики у будь-який момент за допомогою "
"наступного коду::"

#: ../../manual/game_engine/physics/introduction.rst:269
msgid ""
"This will allow importing into other Bullet-based projects. See the "
"`Bullet Wiki on Serialization "
"<http://bulletphysics.org/mediawiki-1.5.8/index.php/Bullet_binary_serialization>`__"
" for more."
msgstr ""
"Це дозволить імпортувати його в інші проекти, що базуються на Bullet. "
"Дивіться детальніше тут -- `Bullet Wiki on Serialization "
"<http://bulletphysics.org/mediawiki-1.5.8/index.php/Bullet_binary_serialization>`__."

#~ msgid ""
#~ "The Blender Game Engine (BGE) is "
#~ "based on Rigid-Body Physics, which "
#~ "differs significantly from the complementary"
#~ " set of tools available in the "
#~ "form of Soft Body Physics Simulations."
#~ " Though the BGE does have a "
#~ "Soft Body type, it is not nearly"
#~ " as nuanced as the non-BGE Soft"
#~ " Body. The inverse is even more "
#~ "true: it is difficult to get the"
#~ " non-BGE physics to resemble anything"
#~ " like a stiff shape. Rigid Body "
#~ "Physics does not have, as an "
#~ "effect or a cause, any mesh "
#~ "deformations. For a discussion on how"
#~ " to partially overcome this, see: "
#~ "`Mesh Deformations`_."
#~ msgstr ""
#~ "Рушій Blender Game Engine (BGE) "
#~ "базується на фізиці твердого тіла -- "
#~ "Rigid-Body Physics, яка суттєво "
#~ "відрізняється від додаткового набору засобів,"
#~ " доступних у формі імітації фізики "
#~ "м'якого тіла -- Soft Body Physics. "
#~ "Хоча BGE має тип фізики Soft Body,"
#~ " але він не настільки деталізований "
#~ "як тип Soft Body не для BGE. "
#~ "Зворотне є навіть більш вірним: важко"
#~ " отримати не-BGE фізику, схожою на "
#~ "щось з жорсткою формою. Фізика твердого"
#~ " тіла -- Rigid Body Physics не "
#~ "має, як результат або як причину, "
#~ "будь-які деформування сіті. Для обговорення"
#~ " того, як це частково подолати, "
#~ "дивіться: `Mesh Deformations`_."

