# SOME DESCRIPTIVE TITLE.
# Copyright (C) : This page is public domain as CC0
# This file is distributed under the same license as the Blender Reference
# Manual package.
# urko <urkokul@gmail.com>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Blender 2.78 Manual 2.78\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-10-16 03:38+1100\n"
"PO-Revision-Date: 2017-08-09 02:12+0300\n"
"Last-Translator: urko <urkokul@gmail.com>\n"
"Language: uk\n"
"Language-Team: \n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../../manual/compositing/types/converter/math.rst:5
msgid "Math Node"
msgstr "Вузол «Математика» -- Math Node"

#: ../../manual/compositing/types/converter/math.rst:10
msgid "Math node."
msgstr "Вузол «Математика» -- Math node."

#: ../../manual/compositing/types/converter/math.rst:12
msgid "The *Math Node* performs math operations."
msgstr "Вузол «Математика» -- *Math Node* здійснює математичні операції."

#: ../../manual/compositing/types/converter/math.rst:16
msgid "Inputs"
msgstr "Уводи -- Inputs"

#: ../../manual/compositing/types/converter/math.rst:19
#: ../../manual/compositing/types/converter/math.rst:25
#: ../../manual/compositing/types/converter/math.rst:42
msgid "Value"
msgstr "Значення -- Value"

#: ../../manual/compositing/types/converter/math.rst:19
msgid ""
"First numerical value. The trigonometric functions accept values in "
"radians."
msgstr ""
"Перше числове значення. Тригонометричні функції приймають значення у "
"радіанах."

#: ../../manual/compositing/types/converter/math.rst:22
msgid ""
"Second numerical value. This value is **not** used in functions that "
"accept only one parameter like the trigonometric functions, Round and "
"Absolute."
msgstr ""
"Друге числове значення. Це значення **не** використовується у функціях, "
"що приймають тільки один параметр, на кшалт, тригонометричних функцій, "
"Округлення -- Round та Абсолют -- Absolute."

#: ../../manual/compositing/types/converter/math.rst:28
msgid "Properties"
msgstr "Властивості"

#: ../../manual/compositing/types/converter/math.rst:31
msgid "Operation"
msgstr "Операція -- Operation"

#: ../../manual/compositing/types/converter/math.rst:31
msgid ""
"Add, Subtract, Multiply, Divide, Sine, Cosine, Tangent, Arcsine, "
"Arccosine, Arctangent, Power, Logarithm, Minimum, Maximum, Round, Less "
"Than, Greater Than, Modulo, Absolute."
msgstr ""
"Додання -- Add, Відняття -- Subtract, Множення -- Multiply, Ділення -- "
"Divide, Синус -- Sine, Косинус -- Cosine, Тангенс -- Tangent, Арксинус --"
" Arcsine, Арккосинус -- Arccosine, Арктангенс -- Arctangent, Степінь -- "
"Power, Логарифм -- Logarithm, Мінімум -- Minimum, Максимум -- Maximum, "
"Округлення -- Round, Менше Ніж -- Less Than, Більше Ніж -- Greater Than, "
"Модуль -- Modulo, Абсолют -- Absolute."

#: ../../manual/compositing/types/converter/math.rst:35
msgid "Clamp"
msgstr "Затиск -- Clamp"

#: ../../manual/compositing/types/converter/math.rst:34
msgid "Limits the output to the range (0 to 1). See :term:`clamp`."
msgstr "Лімітує вивід діапазоном (від 0 до 1). Дивіться :term:`clamp`."

#: ../../manual/compositing/types/converter/math.rst:38
msgid "Outputs"
msgstr "Виводи -- Outputs"

#: ../../manual/compositing/types/converter/math.rst:41
msgid "Numerical value output."
msgstr "Вивід числового значення."

#: ../../manual/compositing/types/converter/math.rst:45
msgid "Examples"
msgstr "Приклади"

#: ../../manual/compositing/types/converter/math.rst:48
msgid "Manual Z-Mask"
msgstr "Ручна Z-Маска"

#: ../../manual/compositing/types/converter/math.rst:52
msgid "Example."
msgstr "Приклад."

#: ../../manual/compositing/types/converter/math.rst:54
msgid ""
"This example has one scene input by the top *Render Layer* node, which "
"has a cube that is about 10 BU from the camera. The bottom Render Layer "
"node inputs a scene (FlyCam) with a plane that covers the left half of "
"the view and is 7 BU from the camera. Both are fed through their "
"respective Map Value nodes to divide the Z buffer by 20 (multiply by "
"0.05, as shown in the Size field) and clamped to be a min/ max of 0.0/ "
"1.0 respectively."
msgstr ""
"Цей приклад має один увід зі сцени, поданий вузлом «Шари Зображу» -- "
"*Render Layers*, який має куб, що знаходиться близько 10 одиниць "
"Blender'а (BU) від камери. Нижній увід у карту вузлів -- другий вузол "
"«Шари Зображу» -- Render Layers зі сценою, що має площину (FlyCam), яка "
"покриває ліву частину огляду та знаходиться на 7 BU від камери. Обидва "
"подаються через відповідні їм вузли «Розкладка Значень» -- Map Value, що "
"ділять їх значення Z-буферу (глибини) на 20 (або множать на 0.05, як "
"показано у полі устави «Розмір» -- Size) та затискають ці значення у "
"діапазон 0-1 уставами «Вжити Мінімум» -- Use Minimum / «Вжити Максимум» "
"-- Use Maximum -- 0.0/1.0 відповідно."

#: ../../manual/compositing/types/converter/math.rst:62
msgid ""
"For the minimum function, the node selects those Z values where the "
"corresponding pixel is closer to the camera; so it chooses the Z values "
"for the plane and part of the cube. The background has an infinite Z "
"value, so it is clamped to 1.0 (shown as white). In the maximum example, "
"the Z values of the cube are greater than the plane, so they are chosen "
"for the left side, but the plane (FlyCam) Render layers Z are infinite "
"(mapped to 1.0) for the right side, so they are chosen."
msgstr ""
"Для мінімуму функції цей вузол вибирає ті значення Z, де відповідний "
"піксель є ближчим до камери; тому, він вибрав Z-значення для площини та "
"частини куба. Задньоплан має безкінечне значення Z-глибини, а тому він "
"затискається значенням 1.0 (показується білим кольором). У прикладі з "
"максимумом Z-значення куба є більшим, ніж площини, а тому вони "
"вибираються з лівого боку, але Z вузла «Render Layers» із площиною "
"(FlyCam) є безкінечним (розкладеним в 1.0) для правого боку, і тому вони "
"обоє є вибраними."

#: ../../manual/compositing/types/converter/math.rst:72
msgid "Using Sine Function to Pulsate"
msgstr "Використання функції синуса для отримання ефекту пульсації"

#: ../../manual/compositing/types/converter/math.rst:76
msgid ""
"This example has a *Time* node putting out a linear sequence from 0 to 1 "
"over the course of 101 frames. The green vertical line in the curve "
"widget shows that frame 25 is being put out, or a value of 0.25. That "
"value is multiplied by 2 × pi and converted to 1.0 by the Sine function, "
"since we all know that :math:`sin(2 × pi/ 4) = sin(pi/ 2) = +1.0` Since "
"the sine function can put out values between (-1.0 to 1.0), the *Map "
"Value* node scales that to 0.0 to 1.0 by taking the input (-1 to 1), "
"adding 1 (making 0 to 2), and multiplying the result by one-half (thus "
"scaling the output between 0 to 1). The default *Color Ramp* converts "
"those values to a grayscale. Thus, medium gray corresponds to a 0.0 "
"output by the sine, black to -1.0, and white to 1.0. As you can see, "
":math:`sin(pi/ 2) = 1.0`. Like having your own visual color calculator! "
"Animating this node setup provides a smooth cyclic sequence through the "
"range of grays."
msgstr ""
"Цей приклад має вузол «Час» -- *Time* викладений у прямолінійну "
"послідовність від 0 до 1 для діапазону 101 кадр. Зелена вертикальна лінія"
" на віджеті кривої показує, що виставлено 25 кадр, або це значення -- "
"0.25. Це значення множиться на 2 × pi та конвертується в 1.0 функцією "
"Синус -- Sine, оскільки ми всі знаємо, що :math:`sin(2 × pi/ 4) = sin(pi/"
" 2) = +1.0` Оскільки функій синус може виставляти значення між (-1.0 to "
"1.0), то вузол «Розкладка Значень» -- *Map Value* масштабує у діапазон "
"від 0.0 до 1.0 отримане з уводу (-1 до 1), додає 1 (роблячи від 0 до 2) "
"та множить результат на половину (тобто масштабує вивід у діапазоні між "
"від 0 до 1). Вузол «Колірний Градієнт» -- *Color Ramp* стандартно "
"конвертує ці значення у сіровідтінкові. Таким чином, середній сірий "
"відповідає виводу 0.0 за синусом, чорний -- значенню -1.0 та білий -- "
"значенню 1.0. Як ви можете бачити, :math:`sin(pi/ 2) = 1.0`. Ніби у вас є"
" свій візуальний калькулятор колір! Анімування цього укладу вузлів "
"забезпечує плавну циклічну послідовність через діапазон сірих відтінків."

#: ../../manual/compositing/types/converter/math.rst:88
msgid ""
"Use this function to vary, for example, the alpha channel of an image to "
"produce a fading in/out effect. Alter the Z channel to move a scene "
"in/out of focus. Alter a color channel value to make a color \"pulse\"."
msgstr ""
"Використовуйте цю функцію для варіювання, наприклад, альфа-каналу "
"зображення для отримання ефекту появи/щезання. Змінюйте значення цього "
"Z-каналу для переміщування сцени у/поза фокус. Змінюйте значення "
"колірного каналу для зроблення «пульсації» кольору."

#: ../../manual/compositing/types/converter/math.rst:95
msgid "Brightening/Scaling a Channel"
msgstr "Збільшення яскравості/Масштабування Каналу"

#: ../../manual/compositing/types/converter/math.rst:99
msgid ""
"This example has a *Math: Multiply* node increasing the luminance channel"
" (Y) of the image to make it brighter. Note that you should use a *Map "
"Value node* with min() and max() enabled to clamp the output to valid "
"values. With this approach, you could use a logarithmic function to make "
"a high-dynamic range image. For this particular example, there is also a "
"*Brighten/Contrast node* that might give simpler control over brightness."
msgstr ""
"Цей приклад має вузол «Математика: Множення» -- *Math: Multiply*, що "
"збільшує значення каналу світності (Y) зображення для зроблення його "
"яскравішим. Зауважте, що ви повинні використати вузол «Розкладка Значень»"
" -- *Map Value node* з увімкненими опціями «Вжити Мінімум» -- Use Minimum"
" min() та «Вжити Максимум» -- Use Maximum max() для затиску виводу у "
"дійсні значення. За допомогою такого підходу ви можете використати "
"логарифмічну функцію для зроблення зображення з високим динамічним "
"діапазоном. Для цього конкретного прикладу існує також вузол "
"«Яскравість/Контраст» -- *Brighten/Contrast node*, що може давати "
"простіший контроль за яскравістю."

#: ../../manual/compositing/types/converter/math.rst:108
msgid "Quantize/Restrict Color Selection"
msgstr "Квантизація/Вимежування Вибору Кольорів"

#: ../../manual/compositing/types/converter/math.rst:110
msgid ""
"In this example, we want to restrict the color output to only 256 "
"possible values. Possible use of this is to see what the image will look "
"like on an 8-bit cell phone display. To do this, we want to restrict the "
"R, G and B values of any pixel to be one of a certain value, such that "
"when they are combined, will not result in more than 256 possible values."
" The number of possible values of an output is the number of channel "
"values multiplied by each other, or Q = R × G × B."
msgstr ""
"У цьому прикладі ми хочемо вимежувати вивід кольорів тільки можливими 256"
" значеннями. Можливо це використовувати це, щоб побачити, як зображення "
"буде виглядати на 8-бітному дисплеї мобільного телефону. Для цього ми "
"хочемо вимежувати значення R, G і B будь-якого пікселя одним з певних "
"значень, таким, що коли вони скомбінуються, то результат цього не матиме "
"більше за можливі 256 значень. Кількість можливих значень виводу -- це "
"кількість значень каналів, помножених один на одного, або Q = R × G × B."

#: ../../manual/compositing/types/converter/math.rst:117
msgid ""
"Since there are three channels and 256 values, we have some flexibility "
"how to quantize each channel, since there are a lot of combinations of R "
"× G × B that would equal 256. For example, if {R, G, B} = {4, 4, 16}, "
"then :math:`4 × 4 × 16 = 256`. Also, {6, 6, 7} would give 252 possible "
"values. The difference in appearance between {4, 4, 16} and {6, 6, 7} is "
"that the first set (4, 4, 16} would have fewer shades of red and green, "
"but lots of shades of blue. The set {6, 6, 7} would have a more even "
"distribution of colors. To get better image quality with fewer color "
"values, give possible values to the predominant colors in the image."
msgstr ""
"Оскільки існує три канали і 256 значень, ми маємо деяку гнучкість, як "
"квантувати кожен канал, тому що є безліч комбінацій R × G × B, що "
"дорівнюють 256. Наприклад, якщо {R, G, B} = {4, 4, 16}, то :math:`4 × 4 ×"
" 16 = 256`. Також, {6, 6, 7} будуть давати можливі 252 значення. "
"Відмінність у вигляді між {4, 4, 16} та {6, 6, 7} полягає у тому, що "
"перший набір (4, 4, 16} буде мати менше відтінків червоного і зеленого, "
"але багато відтінків синього. Набір {6, 6, 7} буде мати більш рівномірний"
" розподіл кольорів. Для отримання кращої якості з меншою кількістю "
"кольорів надайте можливі значення для переважних кольорів у зображенні."

#: ../../manual/compositing/types/converter/math.rst:129
msgid "Theory"
msgstr "Теорія"

#: ../../manual/compositing/types/converter/math.rst:131
msgid ""
"`Two Approaches to Quantizing to six values "
"<https://wiki.blender.org/index.php/File:Manual-Compositing-Node-"
"Math_ColorBand>`__."
msgstr ""
"`Два підходи до квантування у шість значень -- Two Approaches to "
"Quantizing to six values <https://wiki.blender.org/index.php/File:Manual-"
"Compositing-Node-Math_ColorBand>`__."

#: ../../manual/compositing/types/converter/math.rst:134
msgid ""
"To accomplish this quantization of an image to 256 possible values, let "
"us use the set {6, 6, 7}. To split up a continuous range of values "
"between 0 and 1 (the full Red spectrum) into six values, we need to "
"construct an algorithm or function that takes any input value but only "
"puts out six possible values, as illustrated by the image to the right. "
"We want to include zero as true black, with five other colors in between."
" The approach shown produces {0, 0.2, 0.4, 0.6, 0.8, 1}. Dividing 1.0 by "
"5 equals 0.2, which tells how far apart each quantified value is from the"
" other."
msgstr ""
"Для здійснення цього квантування зображення у 256 можливих значень, "
"давайте скористаємося набором {6, 6, 7}. Для розділення безперервного "
"діапазону значень між 0 та 1 (повний спектр червоного) на шість значень "
"нам треба побудувати алгоритм або функцію, що прийме будь-яке увідне "
"значення, але на видасть лише шість можливих значень, як ілюстровано вже "
"згаданим зображенням. Ми хочемо включити нуль як справжній чорний з "
"п'ятьма іншими кольорами між ним і білим. Цей показаний підхід дає {0, "
"0.2, 0.4, 0.6, 0.8, 1}. Ділення 1.0 на 5 дорівнює 0.2, що показує, "
"наскільки далеко кожне квантоване значення знаходиться одне від одного."

#: ../../manual/compositing/types/converter/math.rst:142
msgid ""
"So, to get good even shading, we want to take values that are 0.16 or "
"less and map them to 0.0; values between 0.16 and 0.33 get fixed to 0.2; "
"color band values between 0.33 and 0.5 get quantized to 0.4, and so on up"
" to values between 0.83 and 1.0 get mapped to 1.0."
msgstr ""
"Тому, для отримання доброго рівномірного відтінення, ми хочемо прийняти "
"значення, які становлять 0.16 або менше, та розкласти їх у 0.0; значення "
"між 0.16 та 0.33 фіксуються у 0.2; значення колірної смуги між 0.33 та "
"0.5 квантуються у 0.4 і так далі до значень між 0.83 та 1.0, які "
"розкладаються в 1.0."

#: ../../manual/compositing/types/converter/math.rst:148
msgid "Function f(x)"
msgstr "Функція f(x)"

#: ../../manual/compositing/types/converter/math.rst:150
#, fuzzy
msgid ""
"An algebraic function is made up of primitive mathematical operations "
"(add, subtract, multiply, sine, cosine, etc.) that operate on an input "
"value to provide the desired output value."
msgstr ""
"Алгебраїчна функція, утворена примітивними математичними операціями "
"(додання, відняття, множення, синус, косинус тощо), що оперують увідним "
"значенням для забезпечення бажаного вивідного значення."

#: ../../manual/compositing/types/converter/math.rst:154
msgid ""
"`Spreadsheet showing a function <https://wiki.blender.org/index.php/File"
":Manual-Compositing-Node-Math_spreadsheet>`__."
msgstr ""
"`Таблиця, що показує функцію -- Spreadsheet showing a function "
"<https://wiki.blender.org/index.php/File:Manual-Compositing-Node-"
"Math_spreadsheet>`__."

#: ../../manual/compositing/types/converter/math.rst:157
msgid ""
"The theory behind this function is scaled truncation. Suppose we want a "
"math function that takes in a range of values between 0 and 1, such as "
"0.552, but only outputs a value of 0.0, 0.2, 0.4, etc. We can imagine "
"then that we need to get that range 0 to 1 powered up to something 0 to 6"
" so that we can chop off and make it a whole number. So, with six "
"divisions, how can we do that? The answer is we multiply the range by 6. "
"The output of that first math Multiply Node is a range of values between "
"0 and 6. To get even divisions, because we are using the rounding "
"function (see documentation above), we want any number plus or minus "
"around a whole number will get rounded to that number. So, we subtract a "
"half, which shifts everything over. The round() function then makes that "
"range 0 to 5. We then divide by 5 to get back a range of numbers between "
"0 and 1 which can then be combined back with the other color channels. "
"Thus, you get the function :math:`f(x, n) = round(x × n - 0.5)/ (n - 1)` "
"where \"n\" is the number of possible output values, and \"x\" is the "
"input pixel color and :math:`f(x, n)` is the output value. There is only "
"one slight problem, and that is for the value exactly equal to 1, the "
"formula result is 1.2, which is an invalid value. This is because the "
"round function is actually a roundup function, and exactly 5.5 is rounded"
" up to 6. So, by subtracting 0.501, we compensate and thus 5. 499 is "
"rounded to 5. At the other end of the spectrum, pure black, or 0, when "
"0.501 subtracted, rounds up to 0 since the Round() function does not "
"return a negative number."
msgstr ""
"Ця теорія в основі цієї функції доволі урізана. Припустімо, що ми хочемо "
"математичну функцію, яка прийме на увід діапазон значень між 0 та 1, "
"наприклад 0.5552, але виведе лише значення 0.0, 0.2, 0.4 тощо. Ми можемо "
"уявити далі, що нам треба отримати цей діапазон від 0 до 1 піднесеним до "
"ступеня від 0 до 6, так, щоб ми могли обрубати та зробити його цілим "
"числом. Отже, з шістьма поділами, як ми можемо зробити це? Відповідь -- "
"ми множимо діапазон на 6. Вивід першого вузла «Математика: Множення» -- "
"Math: Multiply є діапазон значень між 0 та 6. Для отримання рівномірних "
"розділень, оскільки ми використовуємо функцію округлення (дивіться "
"документацію вище), ми хочемо, щоб будь-яке число плюс чи мінус біля "
"цілого числа було округлене до цього числа. А тому, ми віднімаємо "
"половину, яка зсуває все над цим. Функція округлення round() далі робить "
"цей діапазон як від 0 до 5. Далі ми ділимо на 5 для отримання назад "
"діапазону чисел між 0 та 1, які ми потім можемо знову скомбінувати з "
"іншими колірними каналами. Таким чином, ви отримуєте функцію: :math:`f(x,"
" n) = round(x × n - 0.5)/ (n - 1)` де \"n\" -- це кількість можливих "
"вивідних значень, а \"x\" -- увідний колір пікселя та :math:`f(x, n)` -- "
"це вивідне значення. Існує лише одна незначна проблема, яка полягає у "
"тому, що при значенні рівному 1 формула видає результат як 1.2, яке є "
"недійсним значенням. Це через те, що функція округлення є функцією "
"зведення, і точне 5.4 округлюється до 6. Тому, віднявши 0.501, ми "
"компенсували це і таким чином 5. 499 округлюється до 5. В іншому кінці "
"спектру число чорний або 0, коли 0.501 віднімається, округлюється до 0, "
"оскільки функція Round() не повертає від'ємне число."

#: ../../manual/compositing/types/converter/math.rst:178
msgid ""
"Sometimes using a spreadsheet can help you figure out how to put these "
"nodes together to get the result that you want. Stepping you through the "
"formula for :math:`n = 6` and :math:`x = 0.70`, locate the line on the "
"spreadsheet that has the 8-bit value 179 and R value 0.7. Multiplying by "
"6 gives 4.2. Subtracting 1/2 gives 3.7, which rounds up to 4.4 divided by"
" 5 = 0.8. Thus, f(0.7, 6) = 0.8 or an 8-bit value of 204. You can see "
"that this same 8-bit value is output for a range of input values."
msgstr ""
"Інколи використання згаданої таблиці може допомогти зрозуміти, як класти "
"ці вузли поряд для отримання бажаного для вас результату. Рухаючись "
"покроково по цій формулі для :math:`n = 6` та :math:`x = 0.70`, знайдіть "
"рядок таблиці, що містить 8-бітне значення 179 та значення R як 0.7. "
"Множення останнього на 6 дає 4.2. Далі, віднімання 1/2 дає 3.7, яке "
"округлюється до 4.4 і ділиться на 5 = 0.8. Таким чином, f(0.7, 6) = 0.8 "
"або 8-бітне значення 204. Ви можете бачити, що це саме 8-бітне значення є"
" виводом для діапазону увідних значень."

#: ../../manual/compositing/types/converter/math.rst:187
msgid "Reality"
msgstr "Реальність"

#: ../../manual/compositing/types/converter/math.rst:189
msgid ""
"To implement this function in Blender, consider the node setup above. "
"First, feed the image to the Separate RGB node. For the Red channel, we "
"string the math nodes into a function that takes each red color, "
"multiplies (scales) it up by the desired number of divisions (6), offsets"
" it by 0.5, rounds the value to the nearest whole number, and then "
"divides the image pixel color by 5. So, the transformation is {0 to 1} "
"becomes {0 to 6}, subtracting centers the medians to {-0.5 to 5.5} and "
"the rounding to the nearest whole number produces {0, 1, 2, 3, 4, 5} "
"since the function rounds down, and then dividing by five results in six "
"values {0.0, 0.2, 0.4, 0.6, 0.8, 1.0}."
msgstr ""
"Для втілення цієї функції у Blender'і, розглянемо уклад вузлів нижче. "
"Спершу, подамо зображення на вузол «Розділяння RGB» -- Separate RGB. Для "
"каналу Червоного R ми навішаємо математичні вузли у функцію, що приймає "
"кожен червоний колір, множить (масштабує) його на бажану кількість "
"розділень (6), зсуває його на 0.5, округлює це значення до найближчого "
"цілого числа, а потім ділить колір пікселя зображення на 5. Отже, "
"трасформування {0 до 1} стає {0 до 6}, віднімає середини до {-0.5 to 5.5}"
" та округлює до найближчого цілого числа, що продукує {0, 1, 2, 3, 4, 5},"
" оскільки ця функція округлює до меншого, а потім ділиться на п'ять "
"результатів у шести значеннях {0.0, 0.2, 0.4, 0.6, 0.8, 1.0}."

#: ../../manual/compositing/types/converter/math.rst:199
#, fuzzy
msgid ""
"The result is that the output value can only be one of a certain set of "
"values, stair-stepped, because of the rounding function of the math node."
" Copying this one channel to operate on Green and Blue gives the node "
"setup below. To get the 6:6:7, we set the three Multiply Nodes to {6, 6, "
"7} and the divide nodes to {5, 5, 6}."
msgstr ""
"Результатом є те, що вивідне значення може бути тільки одним з певного "
"набору значень, покроковим, оскільки є функція округлення цього укладу "
"вузлів «Математика». Копіювання цього одного каналу для оперування "
"зеленим і синім дає нижче наведений уклад вузлів. Для отримання 6:6:7 ми "
"установлюємо три вузли «Математика: Множення» -- Math: Multiply як {6, 6,"
" 7} та ділимо ці вузли у {5, 5, 6}."

#: ../../manual/compositing/types/converter/math.rst:206
msgid ""
"If you make this into a node group, you can easily reuse this setup from "
"project to project. When you do, consider using a math node to drive the "
"different values that you would have to otherwise set manually, just to "
"error-proof your work."
msgstr ""
"Якщо ви згрупуєте це у групу вузлів, то зможете легко повторно "
"використовувати цей уклад у багатьох проектах. Коли ви це зробите, "
"розгляньте використання вузла «Математика» -- Math для керування різними "
"значеннями, щоб ви могли мати і інший набір, просто для виявлення "
"можливих помилок у роботі."

#: ../../manual/compositing/types/converter/math.rst:212
msgid "Summary"
msgstr "Підсумок"

#: ../../manual/compositing/types/converter/math.rst:214
msgid ""
"Normally, an output render consists of 32- or 24-bit color depth, and "
"each pixel can be one of the millions of possible colors. This node setup"
" example takes each of the Red, Green and Blue channels and normalizes "
"them to one of a few values. When all three channels are combined back "
"together, each color can only be one of 256 possible values."
msgstr ""
"Зазвичай, вивідний зображ, рендер має 32- або 24-бітну глибину кольору і "
"кожен піксель може бути один на мільйони можливих кольорів. Цей приклад "
"укладу вузлів бере кожен з каналів Червоного, Зеленого та Синього і "
"нормалізує їх в одне з кількох значень. Коли усі три канали комбінуються "
"назад разом, кожен колір може бути тільки одним з можливих 256 значень."

#: ../../manual/compositing/types/converter/math.rst:221
msgid ""
"While this example uses the Separate/Combine RGB to create distinct "
"colors, other Separate/Combine nodes can be used as well. If using the "
"YUV values, remember that U and V vary between (-0.5 to +0.5), so you "
"will have to first add on a half to bring the range between 0 and 1, and "
"then after dividing, subtract a half to bring in back into standard "
"range."
msgstr ""
"Хоча цей приклад використовує вузол «Розділяння/Комбінування RGB» -- "
"Separate/Combine RGB для створення відокремлених кольорів, однак, для "
"цього можуть застосовуватися і інші вузли категорії "
"Розділяння/Комбінування. Якщо використовуються значення YUV, пам'ятайте, "
"що U та V варіюються між (-0.5 to +0.5), а тому ви маєте спершу додати "
"половину для приведення діапазону до між 0 і 1, а потім після ділення "
"відніміть половину для привнесення його назад у стандартний діапазон."

#: ../../manual/compositing/types/converter/math.rst:227
#, fuzzy
msgid ""
"The ``JPG`` or ``PNG`` image format will store each of the colors "
"according to their image standard for color depth (e.g. ``JPG`` is "
"24-bit), but the image will be very small since reducing color depth and "
"quantizing colors are essentially what the ``JPEG`` compression algorithm"
" accomplishes."
msgstr ""
"Формат зображення ``JPG`` або ``PNG`` буде зберігати кожен з цих кольорів"
" відповідно до свого стандарту для глибини кольору (наприклад для ``JPG``"
" -- це 24-біт), але зображення буде дуже дуже маленьким, оскільки "
"скорочення глибини кольору та квантування кольорів є базово тим самим, що"
" робить алгоритм стиснення ``JPEG``."

#: ../../manual/compositing/types/converter/math.rst:232
msgid ""
"You do not have to reduce the color depth of each channel evenly. For "
"example, if blue was the dominant color in an image, to preserve image "
"quality, you could reduce Red to 2 values, Green to 4, and let the blue "
"take on :math:`256/(2 × 4)` or 32 values. If using the HSV, you could "
"reduce the Saturation and Value to 2 values (0 or 1.0) by Multiply by 2 "
"and Divide by 2, and restrict the Hue to 64 possible values."
msgstr ""
"Ви не маєте скорочувати глибину кольору однаково для кожного каналу. "
"Наприклад, якщо синій був домінантним кольором у зображенні, то для "
"збереження якості зображення ви повинні скоротити Червоний до 2 значень, "
"Зелений до 4 та дати Синьому :math:`256/(2 × 4)` або 32 values. Якщо "
"використовується HSV, ви можете скоротити Насиченість - Saturation і "
"Значення світлості -- Value до 2 значень (0 або 1.0), Помноживши -- "
"Multiply на 2 та Поділивши -- Divide на 2, та вимежувавши Відтінок -- Hue"
" можливими 64-ма значеннями."

#: ../../manual/compositing/types/converter/math.rst:238
msgid ""
"You can use this node setup to quantize any channel; alpha, speed "
"(vector), z-values, and so forth."
msgstr ""
"Ви можете використовувати цей уклад вузлів для квантування будь-якого "
"іншого каналу: альфа, швидкість (вектор), z-значення і так далі."

