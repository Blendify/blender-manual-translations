# SOME DESCRIPTIVE TITLE.
# Copyright (C) : This page is public domain as CC0
# This file is distributed under the same license as the Blender Reference
# Manual package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
# urko <urkokul@gmail.com>, 2018.
#
msgid ""
msgstr ""
"Project-Id-Version: Blender 2.78 Manual 2.78\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-19 21:38-0400\n"
"PO-Revision-Date: 2018-01-23 18:08+0200\n"
"Last-Translator: urko <urkokul@gmail.com>\n"
"Language: uk\n"
"Language-Team: \n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.3\n"

#: ../../manual/render/freestyle/python.rst:5
msgid "Python Scripting Mode"
msgstr "Режим Скриптування на Python -- Python Scripting Mode"

#: ../../manual/render/freestyle/python.rst:7
#, fuzzy
msgid ""
"The Python Scripting mode offers full programmable line stylizes. In this"
" control mode, all styling operations are written as Python scripts "
"referred to as style modules in the Freestyle terminology. The input to a"
" style module is a view map (i.e. a set of detected feature edges), and "
"the output is a set of stylized strokes."
msgstr ""
"Режим Скриптування на Python -- Python Scripting Mode пропонує повну "
"програмовність для стилізації ліній. У цьому режимі керування -- control "
"mode усі операції стилізації пишуться як скрипти на Python, що відомі як "
"модулі стилю -- style module в термінології Freestyle. Увід у модуль "
"стилю -- це карта огляду (тобто набір визначених вирізнених країв), а "
"вивід -- це набір стилізованих штрихів."

#: ../../manual/render/freestyle/python.rst:12
msgid ""
"A style module is composed of successive calls of five basic operators: "
"selection, chaining, splitting, sorting and stroke creation. The "
"selection operator identifies a subset of input feature edges based on "
"one or more user-defined selection conditions (predicates). The selected "
"edges are processed with the chaining, splitting and sorting operators to"
" build chains of feature edges. These operators are also controlled by "
"user-supplied predicates and functions in order to determine how to "
"transform the feature edges into chains. Finally, the chains are "
"transformed into stylized strokes by the stroke creation operator, which "
"takes a list of user-defined stroke shaders."
msgstr ""
"Модуль стилю складається з послідовних викликів п'яти базових операторів:"
" виділення -- selection, зчіплювання -- chaining, розділення -- "
"splitting, сортування -- sorting та створення штриха -- stroke creation. "
"Оператор виділення -- selection ідентифікує піднабір уводу вирізнених "
"країв на основі однієї чи кількох визначених користувачем умов виділення "
"(предикатів, тверджень). Виділені краї обробляються операторами "
"зчіплювання, розділення та сортування для побудови ланцюгів вирізнених "
"країв. Ці оператори також керуються заданими користувачем предикатами та "
"функціями, щоб визначати, як трансформувати вирізнені краї у ланцюги. "
"Нарешті, ланцюги трансформуються у стилізовані штрихи оператором "
"створення штриха, який приймає список визначених користувачем "
"відтінювачів штриха."

#: ../../manual/render/freestyle/python.rst:21
msgid ""
"Python style modules are stored within blend-files as text data-blocks. "
"External style module files first need to be loaded in the Text Editor. "
"Then the select menu within an entry of the style module stack allows you"
" to select a module from the list of loaded style modules."
msgstr ""
"Модулі стилю Python зберігаються у межах blend-файлів як блоки даних "
"тексту. Зовнішні файли модулів стилю спершу необхідно завантажити у "
"Редактор Тексту -- Text Editor. Далі меню вибору у межах запису стеку "
"модулів стилю дозволяє вам обрати модуль зі списку завантажених модулів "
"стилю."

#: ../../manual/render/freestyle/python.rst:28
msgid ""
"A screen capture of a style module (cartoon.py) loaded in the Text Editor"
" (left), as well as Freestyle options in the Python Scripting mode in the"
" Render Layers buttons (right)."
msgstr ""
"Екранознімок модуля стилю (cartoon.py) завантажено у Text Editor (зліва),"
" а також опції Freestyle у режимі Python Scripting у вкладці Render "
"Layers (справа)."

#: ../../manual/render/freestyle/python.rst:31
msgid ""
"Freestyle for Blender comes with a number of Python style modules that "
"can serve as a starting point of your own style module writing. See also "
"the section of the Freestyle Python API in the Blender Python API "
"reference manual for the full detail of style module constructs."
msgstr ""
"Freestyle для Blender поставляється з низкою модулів стилю Python, що "
"можуть слугувати відправною точкою для написання вашого власного модуля "
"стилю. Дивіться підрозділ Freestyle Python API у посібнику Blender Python"
" API про деталі конструювання модуля стилю."

#: ../../manual/render/freestyle/python.rst:40
#: ../../manual/render/freestyle/python.rst:47
msgid "By T.K. using the Python Scripting mode."
msgstr "Від T.K. використання режиму Python Scripting."

#: ../../manual/render/freestyle/python.rst:42
msgid ""
"(`File:Turning_Pages.zip "
"<https://wiki.blender.org/index.php/File:Turning_Pages.zip>`__, CC0)."
msgstr ""
"(`File:Turning_Pages.zip "
"<https://wiki.blender.org/index.php/File:Turning_Pages.zip>`__, CC0)."

#: ../../manual/render/freestyle/python.rst:49
msgid ""
"(`File:Lily_Broken_Topology.zip "
"<https://wiki.blender.org/index.php/File:Lily_Broken_Topology.zip>`__, "
"CC0)."
msgstr ""
"(`File:Lily_Broken_Topology.zip "
"<https://wiki.blender.org/index.php/File:Lily_Broken_Topology.zip>`__, "
"CC0)."

#: ../../manual/render/freestyle/python.rst:53
msgid "Writing Style Modules"
msgstr "Написання модулів стилю"

#: ../../manual/render/freestyle/python.rst:55
msgid ""
"A style module is a piece of code responsible for the stylization of "
"Freestyle line drawing. The input of a style module is a set of feature "
"edges called view map (ViewMap). The output is a set of stylized lines "
"also referred to as strokes. A style module is structured as a pipeline "
"of operations that allow for building strokes from the input edges within"
" the view map."
msgstr ""
"Модуль стилю -- це шматок коду, відповідальний за стилізацію прорису "
"ліній Freestyle. Увід модуля стилю -- це набір вирізнених країв, що "
"називається картою огляду -- view map (ViewMap). Вивід -- це набір "
"стилізованих ліній, що також відомі, як штрихи. Модуль стилю "
"структурований як конвеєр операцій, що дозволяють вибудовувати штрихи з "
"увідних країв у межах карти огляду."

#: ../../manual/render/freestyle/python.rst:61
msgid ""
"There are five kinds of operations (listed with corresponding operator "
"functions):"
msgstr ""
"Існує п'ять видів операцій (перераховані з відповідними функціями "
"оператора):"

#: ../../manual/render/freestyle/python.rst:63
msgid "Selection ``Operators.select()``"
msgstr "Виділення -- Selection ``Operators.select()``"

#: ../../manual/render/freestyle/python.rst:64
msgid "Chaining ``Operators.chain(), Operators.bidirectional_chain()``"
msgstr ""
"Зчіплювання -- Chaining ``Operators.chain(), "
"Operators.bidirectional_chain()``"

#: ../../manual/render/freestyle/python.rst:65
msgid "Splitting ``Operators.sequential_split(), Operators.recursive_split()``"
msgstr ""
"Розділення -- Splitting ``Operators.sequential_split(), "
"Operators.recursive_split()``"

#: ../../manual/render/freestyle/python.rst:66
msgid "Sorting ``Operators.sort()``"
msgstr "Сортування -- Sorting ``Operators.sort()``"

#: ../../manual/render/freestyle/python.rst:67
msgid "Stroke creation ``Operators.create()``"
msgstr "Створення штриха -- Stroke creation ``Operators.create()``"

#: ../../manual/render/freestyle/python.rst:69
msgid ""
"The input view map is populated with a set of ViewEdge objects. The "
"selection operation is used to pick up ViewEdges of interest to artists "
"based on user-defined selection conditions (predicates). Chaining "
"operations take the subset of ViewEdges and build Chains by concatenating"
" ViewEdges according to user-defined predicates and functions. The Chains"
" can be further refined by splitting them into smaller pieces (e.g. at "
"points where edges make an acute turn) and selecting a fraction of them "
"(e.g. to keep only those longer than a length threshold). The sorting "
"operation is used to arrange the stacking order of chains to draw one "
"line on top of another. The chains are finally transformed into stylized "
"strokes by the stroke creation operation applying a series of stroke "
"shaders to individual chains."
msgstr ""
"Увідна карта огляду заповнюється набором об'єктів ViewEdge. Операція "
"виділення використовується для вибору ViewEdges, що представляють інтерес"
" для митців на основі визначених користувачем умов (предикатів) "
"виділення. Операції зчіплювання приймають піднабір ViewEdges та будують "
"Ланцюги, зчіплюючи ViewEdges відповідно до визначених користувачем "
"предикатів та функцій. Ці Ланцюги можуть бути далі уточнені, розділенням "
"їх на менші шматки (наприклад, у точках, де краї роблять гострий поворот)"
" та виділенням частини їх (наприклад, для збереження тільки тих, що "
"довші, ніж поріг довжини). Операція сортування використовується для "
"впорядкування ланцюгів у стеку для прорису однієї лінії поверхн іншої. "
"Ланцюги фінально трансформуються у стилізовані штрихи операцією створення"
" штрихів шляхом застосування серії відтінювачів штрихів до окремих "
"ланцюгів."

#: ../../manual/render/freestyle/python.rst:80
msgid ""
"ViewEdges, Chains and Strokes are generically referred to as one-"
"dimensional (1D) elements. A 1D element is a polyline that is a series of"
" connected straight lines. Vertices of 1D elements are called 0D elements"
" in general."
msgstr ""
"ViewEdges, Chains та Strokes загалом називаються одновимірними (1D) "
"елементами. 1D елемент -- це полілінія, що є серією з'єднаних прямих "
"ліній. Вершини 1D елементів називаються 0D елементами, у загальному."

#: ../../manual/render/freestyle/python.rst:84
msgid ""
"All the operators act on a set of active 1D elements. The initial active "
"set is the set of ViewEdges in the input view map. The active set is "
"updated by the operators."
msgstr ""
"Усі оператори діють на наборі активних 1D елементів. Початковий активний "
"набір -- це набір ViewEdges в увідній карті огляду. Активний набір "
"оновлюється операторами."

#: ../../manual/render/freestyle/python.rst:90
msgid "Selection"
msgstr "Виділення -- Selection"

#: ../../manual/render/freestyle/python.rst:92
msgid ""
"The selection operator goes through every element of the active set and "
"keeps only the ones satisfying a certain predicate. The "
"``Operators.select()`` method takes as the argument a unary predicate "
"that works on any ``Interface1D`` that represents a 1D element. For "
"example::"
msgstr ""
"Оператор виділення, вибору проходить через кожен елемент активного набору"
" та зберігає тільки ті, які задовільняють вимоги певного предиката. Метод"
" ``Operators.select()`` приймає як аргумент одноаргументний предикат, що "
"працює на будь-якому ``Interface1D``, що представляє 1D елемент. "
"Наприклад::"

#: ../../manual/render/freestyle/python.rst:98
msgid ""
"This selection operation uses the ``QuantitativeInvisibilityUP1D`` "
"predicate to select only the visible ``ViewEdge`` (more precisely, those "
"whose quantitative invisibility is equal to 0). The selection operator is"
" intended to selectively apply the style to a fraction of the active 1D "
"elements."
msgstr ""
"Ця операція виділення використовує предикат "
"``QuantitativeInvisibilityUP1D`` для вибору тільки видимих ``ViewEdge`` "
"(більш точно тих, яких кількісна невидимість дорівнює 0). Оператор "
"виділення наміряється вибірково застосувати стиль до частини активних 1D "
"елементів."

#: ../../manual/render/freestyle/python.rst:102
msgid ""
"It is noted that ``QuantitativeInvisibilityUP1D`` is a class implementing"
" the predicate that tests line visibility, and the ``Operators.select()``"
" method takes an instance of the predicate class as argument. The testing"
" of the predicate for a given 1D element is actually done by calling the "
"predicate instance, that is, by invoking the ``__call__`` method of the "
"predicate class. In other words, the ``Operators.select()`` method takes "
"as argument a functor which in turn takes an ``Interface0D`` object as "
"argument. The Freestyle Python API employs functors extensively to "
"implement predicates, as well as functions."
msgstr ""
"Відзначено, що ``QuantitativeInvisibilityUP1D`` -- це клас реалізації "
"предиката, що перевіряє видимість лінії, а метод ``Operators.select()`` "
"приймає примірник класу предиката як аргумент. Перевірка предиката для "
"даного 1D елемента фактично робиться викликом примірника предикати, "
"тобто, залучаючи метод ``__call__`` класу предиката. Іншими словами, "
"метод ``Operators.select()`` приймає як аргумент функтор -- functor, "
"який, у свою чергу, приймає об'єкт ``Interface0D`` як аргумент. Freestyle"
" Python API широко вживає функтори для реалізації предикатів, а також "
"функцій."

#: ../../manual/render/freestyle/python.rst:111
msgid "Chaining"
msgstr "Зчіплювання -- Chaining"

#: ../../manual/render/freestyle/python.rst:113
msgid ""
"The chaining operators act on the set of active ``ViewEdge`` objects and "
"determine the topology of the future strokes. The idea is to implement an"
" iterator to traverse the ViewMap graph by marching along ViewEdges. The "
"iterator defines a chaining rule that determines the next ``ViewEdge`` to"
" follow at a given vertex (see ``ViewEdgeIterator``). Several such "
"iterators are provided as part of the Freestyle Python API (see "
"``ChainPredicateIterator`` and ``ChainSilhouetteIterator``). Custom "
"iterators can be defined by inheriting the ``ViewEdgeIterator`` class. "
"The chaining operator also takes as argument a UnaryPredicate working on "
"``Interface1D`` as a stopping criteria. The chaining stops when the "
"iterator has reached a ``ViewEdge`` satisfying this predicate during the "
"march along the graph."
msgstr ""
"Оператори зчіплювання діють на наборі активних об'єктів ``ViewEdge`` та "
"визначають топологію майбутніх штрихів. Ідея полягає в реалізації "
"повторювача -- iterator для проходження графа ViewMap шляхом пересування "
"уздовж ViewEdges. Повторювач визначає правило зчіплювання, яке визначає "
"наступний ``ViewEdge`` для слідування у задану вершину (дивіться "
"``ViewEdgeIterator``). Кілька таких повторювачів надаються як частина "
"Freestyle Python API (дивіться ``ChainPredicateIterator`` та "
"``ChainSilhouetteIterator``). Власні користувацькі повторювачі можуть "
"визначатися успадковуванням класу ``ViewEdgeIterator``. Оператор "
"зчіплювання також приймає як аргумент UnaryPredicate, що працює на "
"``Interface1D``, як критерій зупинки. Зчіплювання зупиняється, коли "
"повторювач досяг задоволення ``ViewEdge`` умов цього предикату у ході "
"пересування по графу."

#: ../../manual/render/freestyle/python.rst:124
msgid ""
"Chaining can be either unidirectional ``Operators.chain()`` or "
"bidirectional ``Operators.bidirectional_chain()``. In the latter case, "
"the chaining will propagate in the two directions from the starting edge."
msgstr ""
"Зчіплювання може бути однонапрямним ``Operators.chain()`` або "
"двонапрямним ``Operators.bidirectional_chain()``. В останньому випадку, "
"зчіплювання буде поширюватися у двох напрямках від стартового краю."

#: ../../manual/render/freestyle/python.rst:127
msgid "The following is a code example of bidirectional chaining::"
msgstr "Наступне є прикладом коду двонапрямного зчіплювання:"

#: ../../manual/render/freestyle/python.rst:134
msgid ""
"The chaining operator uses the ``ChainSilhouetteIterator`` as the "
"chaining rule and stops chaining as soon as the iterator has come to an "
"invisible ``ViewEdge``."
msgstr ""
"Оператор зчіплювання використовує ``ChainSilhouetteIterator`` як правило "
"зчіплювання та зупиняє зчіплювання зразу ж, як повторювач прийшов до "
"невидимого ``ViewEdge``."

#: ../../manual/render/freestyle/python.rst:137
msgid ""
"The chaining operators process the set of active ``ViewEdge`` objects in "
"order. The active ViewEdges can be previously sorted using the "
"``Operators.sort()`` method (see below). It starts a chain with the first"
" ``ViewEdge`` of the active set. All ViewEdges that have already been "
"involved in the chaining process are marked (in the case of the example "
"above, the time stamp of each ``ViewEdge`` is modified by default), in "
"order not to process the same ``ViewEdge`` twice. Once the chaining "
"reaches a ``ViewEdge`` that satisfies the stopping predicate, the chain "
"is terminated. Then a new chain is started from the first unmarked "
"``ViewEdge`` in the active set. This operation is repeated until the last"
" unmarked ``ViewEdge`` of the active set was processed. At the end of the"
" chaining operation, the active set is set to the Chains that have just "
"been constructed."
msgstr ""
"Оператори зчіплювання обробляють набір активних об'єктів ``ViewEdge`` за "
"порядком. Активні ViewEdges можуть попередньо бути сортовані за допомогою"
" методу ``Operators.sort()`` (дивіться нижче). Він запускає ланцюг з "
"першого ``ViewEdge`` активного набору. Усі ViewEdges, що вже були "
"залучені у процес зчіплювання, позначаються (у випадку прикладу вище, "
"штамп часу кожного ``ViewEdge`` модифікується стандартно), щоб не "
"обробляти двічі один і той же ``ViewEdge``. Після того, як зчіплювання "
"досягає ``ViewEdge``, що задовільняє умовам предиката зупинки, ланцюг "
"завершується. Далі новий ланцюг починається з першого непозначеного "
"``ViewEdge`` в активному наборі. Ця операція повторюється, допоки "
"останній непозначений ``ViewEdge`` з активного набору не буде оброблено. "
"У кінці операції зчіплювання, активний набір -- це набір Ланцюгів, що "
"були побудовані."

#: ../../manual/render/freestyle/python.rst:151
msgid "Splitting"
msgstr "Розділення -- Splitting"

#: ../../manual/render/freestyle/python.rst:153
msgid ""
"The splitting operation is used to refine the topology of each Chain. "
"Splitting is performed either sequentially or recursively. Sequential "
"splitting ``Operators.sequentialSplit()`` in its basic form, parses the "
"Chain at a given arbitrary resolution and evaluates a unary predicate "
"(working on 0D elements) at each point along the Chain. Every time the "
"predicate is satisfied, the chain is split into two chains. At the end of"
" the sequential split operation, the active set of chains is set to the "
"new chains. ::"
msgstr ""
"Операція розділення використовується для уточнення топології кожного "
"Ланцюга. Розділення здійснюється послідовно або рекурсивно. Послідовне "
"розділення ``Operators.sequentialSplit()`` у своїй базовій формі, "
"аналізує Ланцюг у заданій довільній роздільності та оцінює "
"одноаргументний предикат (працюючи на 0D елементах) у кожній точці уздовж"
" цього Ланцюга. Кожен раз, при задоволенні предиката, ланцюг розділюється"
" на два ланцюги. У кінці операції послідовного розділення активний набір "
"ланцюгів є набором нових ланцюгів. ::"

#: ../../manual/render/freestyle/python.rst:164
#, fuzzy
msgid ""
"In this example, the chain is split every 2 units. A more elaborated "
"version uses two predicates instead of one: One to determine the starting"
" point of the new chain and the other to determine its ending point. This"
" second version can lead to a set of Chains that are disjoint or that "
"overlap if the two predicates are different (see "
"``Operators.sequentialSplit()`` for more details)."
msgstr ""
"У цьому прикладі, ланцюг розділяється кожні 2 одиниці. Більш розроблена "
"версія використовує два предикати замість одного: один для визначення "
"стартової точки нового ланцюга та другий для визначення його кінцевої "
"точки. Ця друга версія може призвести до набору Ланцюгів, що є "
"роз'єднаними або що перекриваються, якщо два ці предикати є різними. "
"(дивіться детальніше ``Operators.sequentialSplit()``)."

#: ../../manual/render/freestyle/python.rst:170
msgid ""
"Recursive splitting ``Operators.recursiveSplit()`` evaluates a function "
"on the 0D elements along the Chain at a given resolution and find the "
"point that gives the maximum value for the function. The Chain is then "
"split into two at that point. This process is recursively repeated on "
"each of the two new Chains, until the input Chain satisfies a user-"
"specified stopping condition. ::"
msgstr ""
"Рекурсивне розділення ``Operators.recursiveSplit()`` оцінює функцію на 0D"
" елементах уздовж Ланцюга у заданій роздільності та знаходить точку, що "
"дає максимальне значення для цієї функції. Ланцюг далі розділяється на "
"два у цій точці. Цей процес рекурсивно повторюється на кожному з двох "
"нових Ланцюгів, допоки увідний Ланцюг не буде задовольняти визначеній "
"користувачем умові зупинення. ::"

#: ../../manual/render/freestyle/python.rst:180
msgid ""
"In the code example above, the Chains are recursively split at points of "
"the highest 2D curvature. The curvature is evaluated at points along the "
"Chain at a resolution of 5 units. Chains shorter than 5 units will not be"
" split anymore."
msgstr ""
"У прикладі коду вище, Ланцюги рекурсивно розділяються у точках найвищої "
"2D кривини. Ця кривина оцінюється у точках уздовж Ланцюга з роздільністю "
"5 одиниць. Ланцюги, коротші, ніж 5 одиниць, не будуть більше розділятися."

#: ../../manual/render/freestyle/python.rst:187
msgid "Sorting"
msgstr "Сортування -- Sorting"

#: ../../manual/render/freestyle/python.rst:189
msgid ""
"The sorting operator ``Operators.sort()`` arranges the stacking order of "
"active 1D elements. It takes as argument a binary predicate used as a "
"\"smaller than\" operator to order two 1D elements. ::"
msgstr ""
"Оператор сортування ``Operators.sort()`` впорядковує порядок нашарування "
"активних 1D елементів. Він приймає як аргумент двоаргументний предикат, "
"використовуваний як оператор «менше ніж» до порядку 1D елементів. ::"

#: ../../manual/render/freestyle/python.rst:195
msgid ""
"In this code example, the sorting uses the ``Length2DBP1D`` binary "
"predicate to sort the ``Interface1D`` objects in the ascending order in "
"terms of 2D length."
msgstr ""
"У цьому прикладі коду, сортування використовує двоаргументний предикат "
"``Length2DBP1D`` для сортування об'єктів ``Interface1D`` у висхідному "
"порядку у термінах 2D довжини."

#: ../../manual/render/freestyle/python.rst:198
msgid ""
"The sorting is particularly useful when combined with causal density. "
"Indeed, the causal density evaluates the density of the resulting image "
"as it is modified. If we wish to use such a tool to decide to remove "
"strokes whenever the local density is too high, it is important to "
"control the order in which the strokes are drawn. In this case, we would "
"use the sorting operator to ensure that the most \"important\" lines are "
"drawn first."
msgstr ""
"Сортування особливо корисне, коли комбінується з щільністю причин. "
"Дійсно, щільність причин оцінює щільність результатного зображення при "
"його модифікації. Якщо ми бажаємо використати такий інструмент для "
"вирішення того, що слід вилучити штрихи кожен раз, коли локальна "
"щільність є надто високою, то важливо контролювати порядок, в якому ці "
"штрихи прорисовуються. У цьому випадку, ми скористаємося оператором "
"сортування для гарантування, що більш «важливі» лінії прорисуються "
"першими."

#: ../../manual/render/freestyle/python.rst:206
msgid "Stroke Creation"
msgstr "Створення Штриха -- Stroke Creation"

#: ../../manual/render/freestyle/python.rst:208
msgid ""
"Finally, the stroke creation operator ``Operators.create()`` takes the "
"active set of Chains as input and build Strokes. The operator takes two "
"arguments. The first is a unary predicate that works on ``Interface1D`` "
"that is designed to make a last selection on the set of chains. A Chain "
"that does not satisfy the condition will not lead to a Stroke. The second"
" input is a list of shaders that will be responsible for the shading of "
"each built stroke. ::"
msgstr ""
"Фінально, оператор створення штрихів ``Operators.create()`` приймає "
"активний набір Ланцюгів як увід та будує Штрихи. Цей оператор приймає два"
" аргументи. Перший -- це одноаргументний предикат, що працює на "
"``Interface1D``, який призначений для зроблення останнього виділення на "
"наборі ланцюгів. Ланцюг, що не задовільняє цій умові, не перейде далі у "
"Штрих. Другий увід -- це список відтінювачів, що будуть відповідати за "
"відтінення кожного побудованого штриха. ::"

#: ../../manual/render/freestyle/python.rst:222
msgid ""
"In this example, the ``DensityUP1D`` predicate is used to remove all "
"Chains whose mean density is higher than 0.1. Each chain is transformed "
"into a stroke by resampling it so as to have a point every 5 units and "
"assigning to it a constant thickness of 2 units and a dark gray constant "
"color."
msgstr ""
"У цьому прикладі, предикат ``DensityUP1D`` використовується для вилучення"
" усіх Ланцюгів, які мають середню щільність, вище за 0.1. Кожен ланцюг "
"трансформується у штрих шляхом повторного відбору так, щоб мати точку "
"через кожні 5 одиниць, призначення для нього постійної товщини у 2 "
"одиниці та темно-сірого постійного кольору."

#: ../../manual/render/freestyle/python.rst:229
msgid "User Control on the Pipeline Definition"
msgstr "Керування користувачем конвеєром визначення"

#: ../../manual/render/freestyle/python.rst:231
msgid ""
"Style module writing offers different types of user control, even though "
"individual style modules have a fixed pipeline structure. One is the "
"sequencing of different pipeline control structures, and another is "
"through the definition of functor objects that are passed as argument all"
" along the pipeline."
msgstr ""
"Написання модуля стилю пропонує різні типи керування користувачем, навіть"
" хоча окремі модулі стилю мають фіксовану структуру конвеєра. Одним з них"
" є задання послідовності різних керувальних структур конвеєра, а іншим --"
" через визначення об'єктів функторів, що передаються як аргумент уздовж "
"усього конвеєра."

#: ../../manual/render/freestyle/python.rst:236
msgid ""
"Different pipeline control structures can be defined by sequencing the "
"selection, chaining, splitting, and sorting operations. The stroke "
"creation is always the last operation that concludes a style module."
msgstr ""
"Різні структури керування конвеєром можуть бути визначені заданням "
"операцій виділення, зчіплювання, розділення та сортування. Створення "
"штриха є завжди останньою операцією, що завершує модуль стилю."

#: ../../manual/render/freestyle/python.rst:240
msgid ""
"Predicates, functions, chaining iterators, and stroke shaders can be "
"defined by inheriting base classes and overriding appropriate methods. "
"See the reference manual entries of the following base classes for more "
"information on the user-scriptable constructs."
msgstr ""
"Предикати, функції, повторювачі зчіплювання та відтінювачі штрихів можуть"
" визначатися успадковуванням базових класів та перевизначенням "
"відповідних методів. Для отримання додаткової інформації про визначувані "
"користувачем конструкції дивіться відповідні записи про наступні базові "
"класи."

#: ../../manual/render/freestyle/python.rst:246
#, fuzzy
msgid ""
"Predicates, functions, chaining iterators, and stroke shaders can be "
"defined by inheriting base classes and overriding appropriate methods. "
"See :mod:`Freestyle python module <blender_api:freestyle>` for more "
"information on the user-scriptable constructs."
msgstr ""
"Предикати, функції, повторювачі зчіплювання та відтінювачі штрихів можуть"
" визначатися успадковуванням базових класів та перевизначенням "
"відповідних методів. Для отримання додаткової інформації про визначувані "
"користувачем конструкції дивіться відповідні записи про наступні базові "
"класи."

#~ msgid "``UnaryPredicate0D``"
#~ msgstr "``UnaryPredicate0D``"

#~ msgid "``UnaryPredicate1D``"
#~ msgstr "``UnaryPredicate1D``"

#~ msgid "``BinaryPredicate0D``"
#~ msgstr "``BinaryPredicate0D``"

#~ msgid "``BinaryPredicate1D``"
#~ msgstr "``BinaryPredicate1D``"

#~ msgid "``UnaryFunction0DDouble``"
#~ msgstr "``UnaryFunction0DDouble``"

#~ msgid "``UnaryFunction0DEdgeNature``"
#~ msgstr "``UnaryFunction0DEdgeNature``"

#~ msgid "``UnaryFunction0DFloat``"
#~ msgstr "``UnaryFunction0DFloat``"

#~ msgid "``UnaryFunction0DId``"
#~ msgstr "``UnaryFunction0DId``"

#~ msgid "``UnaryFunction0DMaterial``"
#~ msgstr "``UnaryFunction0DMaterial``"

#~ msgid "``UnaryFunction0DUnsigned``"
#~ msgstr "``UnaryFunction0DUnsigned``"

#~ msgid "``UnaryFunction0DVec2f``"
#~ msgstr "``UnaryFunction0DVec2f``"

#~ msgid "``UnaryFunction0DVec3f``"
#~ msgstr "``UnaryFunction0DVec3f``"

#~ msgid "``UnaryFunction0DVectorViewShape``"
#~ msgstr "``UnaryFunction0DVectorViewShape``"

#~ msgid "``UnaryFunction0DViewShape``"
#~ msgstr "``UnaryFunction0DViewShape``"

#~ msgid "``UnaryFunction1DDouble``"
#~ msgstr "``UnaryFunction1DDouble``"

#~ msgid "``UnaryFunction1DEdgeNature``"
#~ msgstr "``UnaryFunction1DEdgeNature``"

#~ msgid "``UnaryFunction1DFloat``"
#~ msgstr "``UnaryFunction1DFloat``"

#~ msgid "``UnaryFunction1DUnsigned``"
#~ msgstr "``UnaryFunction1DUnsigned``"

#~ msgid "``UnaryFunction1DVec2f``"
#~ msgstr "``UnaryFunction1DVec2f``"

#~ msgid "``UnaryFunction1DVec3f``"
#~ msgstr "``UnaryFunction1DVec3f``"

#~ msgid "``UnaryFunction1DVectorViewShape``"
#~ msgstr "``UnaryFunction1DVectorViewShape``"

#~ msgid "``UnaryFunction1DVoid``"
#~ msgstr "``UnaryFunction1DVoid``"

#~ msgid "``ViewEdgeIterator``"
#~ msgstr "``ViewEdgeIterator``"

#~ msgid "``StrokeShader``"
#~ msgstr "``StrokeShader``"

