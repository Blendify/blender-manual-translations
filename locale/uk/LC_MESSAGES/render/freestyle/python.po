# SOME DESCRIPTIVE TITLE.
# Copyright (C) : This page is public domain as CC0
# This file is distributed under the same license as the Blender Reference
# Manual package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
# urko <urkokul@gmail.com>, 2018.
#
msgid ""
msgstr ""
"Project-Id-Version: Blender 2.78 Manual 2.78\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-12-04 22:59+1100\n"
"PO-Revision-Date: 2018-01-23 18:08+0200\n"
"Last-Translator: urko <urkokul@gmail.com>\n"
"Language: uk\n"
"Language-Team: \n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"
"X-Generator: Poedit 2.0.6\n"

#: ../../manual/render/freestyle/python.rst:4
msgid "Python Scripting Mode"
msgstr "Режим Скриптування на Python -- Python Scripting Mode"

#: ../../manual/render/freestyle/python.rst:7
msgid "The Python Scripting mode offers full programmability for line stylization. In this control mode, all stylization operations are written as Python scripts referred to as style modules in the Freestyle terminology. The input to a style module is a view map (i.e. a set of detected feature edges), and the output is a set of stylized strokes."
msgstr "Режим Скриптування на Python -- Python Scripting Mode пропонує повну програмовність для стилізації ліній. У цьому режимі керування -- control mode усі операції стилізації пишуться як скрипти на Python, що відомі як модулі стилю -- style module в термінології Freestyle. Увід у модуль стилю -- це карта огляду (тобто набір визначених вирізнених країв), а вивід -- це набір стилізованих штрихів."

#: ../../manual/render/freestyle/python.rst:12
msgid "A style module is composed of successive calls of five basic operators: selection, chaining, splitting, sorting and stroke creation. The selection operator identifies a subset of input feature edges based on one or more user-defined selection conditions (predicates). The selected edges are processed with the chaining, splitting and sorting operators to build chains of feature edges. These operators are also controlled by user-supplied predicates and functions in order to determine how to transform the feature edges into chains. Finally, the chains are transformed into stylized strokes by the stroke creation operator, which takes a list of user-defined stroke shaders."
msgstr "Модуль стилю складається з послідовних викликів п'яти базових операторів: виділення -- selection, зчіплювання -- chaining, розділення -- splitting, сортування -- sorting та створення штриха -- stroke creation. Оператор виділення -- selection ідентифікує піднабір уводу вирізнених країв на основі однієї чи кількох визначених користувачем умов виділення (предикатів, тверджень). Виділені краї обробляються операторами зчіплювання, розділення та сортування для побудови ланцюгів вирізнених країв. Ці оператори також керуються заданими користувачем предикатами та функціями, щоб визначати, як трансформувати вирізнені краї у ланцюги. Нарешті, ланцюги трансформуються у стилізовані штрихи оператором створення штриха, який приймає список визначених користувачем відтінювачів штриха."

#: ../../manual/render/freestyle/python.rst:21
msgid "Python style modules are stored within blend-files as text data-blocks. External style module files first need to be loaded in the Text Editor. Then the select menu within an entry of the style module stack allows you to select a module from the list of loaded style modules."
msgstr "Модулі стилю Python зберігаються у межах blend-файлів як блоки даних тексту. Зовнішні файли модулів стилю спершу необхідно завантажити у Редактор Тексту -- Text Editor. Далі меню вибору у межах запису стеку модулів стилю дозволяє вам обрати модуль зі списку завантажених модулів стилю."

#: ../../manual/render/freestyle/python.rst:28
msgid "A screen capture of a style module (cartoon.py) loaded in the Text Editor (left), as well as Freestyle options in the Python Scripting mode in the Render Layers buttons (right)."
msgstr "Екранознімок модуля стилю (cartoon.py) завантажено у Text Editor (зліва), а також опції Freestyle у режимі Python Scripting у вкладці Render Layers (справа)."

#: ../../manual/render/freestyle/python.rst:31
msgid "Freestyle for Blender comes with a number of Python style modules that can serve as a starting point of your own style module writing. See also the section of the Freestyle Python API in the Blender Python API reference manual for the full detail of style module constructs."
msgstr "Freestyle для Blender поставляється з низкою модулів стилю Python, що можуть слугувати відправною точкою для написання вашого власного модуля стилю. Дивіться підрозділ Freestyle Python API у посібнику Blender Python API про деталі конструювання модуля стилю."

#: ../../manual/render/freestyle/python.rst:40 ../../manual/render/freestyle/python.rst:47
msgid "By T.K. using the Python Scripting mode."
msgstr "Від T.K. використання режиму Python Scripting."

#: ../../manual/render/freestyle/python.rst:42
msgid "(`File:Turning_Pages.zip <https://wiki.blender.org/index.php/File:Turning_Pages.zip>`__, CC0)."
msgstr "(`File:Turning_Pages.zip <https://wiki.blender.org/index.php/File:Turning_Pages.zip>`__, CC0)."

#: ../../manual/render/freestyle/python.rst:49
msgid "(`File:Lily_Broken_Topology.zip <https://wiki.blender.org/index.php/File:Lily_Broken_Topology.zip>`__, CC0)."
msgstr "(`File:Lily_Broken_Topology.zip <https://wiki.blender.org/index.php/File:Lily_Broken_Topology.zip>`__, CC0)."

#: ../../manual/render/freestyle/python.rst:52
msgid "Writing Style Modules"
msgstr "Написання модулів стилю"

#: ../../manual/render/freestyle/python.rst:55
msgid "A style module is a piece of code responsible for the stylization of Freestyle line drawing. The input of a style module is a set of feature edges called view map (ViewMap). The output is a set of stylized lines also referred to as strokes. A style module is structured as a pipeline of operations that allow for building strokes from the input edges within the view map."
msgstr "Модуль стилю -- це шматок коду, відповідальний за стилізацію прорису ліній Freestyle. Увід модуля стилю -- це набір вирізнених країв, що називається картою огляду -- view map (ViewMap). Вивід -- це набір стилізованих ліній, що також відомі, як штрихи. Модуль стилю структурований як конвеєр операцій, що дозволяють вибудовувати штрихи з увідних країв у межах карти огляду."

#: ../../manual/render/freestyle/python.rst:61
msgid "There are five kinds of operations (listed with corresponding operator functions):"
msgstr "Існує п'ять видів операцій (перераховані з відповідними функціями оператора):"

#: ../../manual/render/freestyle/python.rst:63
msgid "Selection ``Operators.select()``"
msgstr "Виділення -- Selection ``Operators.select()``"

#: ../../manual/render/freestyle/python.rst:64
msgid "Chaining ``Operators.chain(), Operators.bidirectional_chain()``"
msgstr "Зчіплювання -- Chaining ``Operators.chain(), Operators.bidirectional_chain()``"

#: ../../manual/render/freestyle/python.rst:65
msgid "Splitting ``Operators.sequential_split(), Operators.recursive_split()``"
msgstr "Розділення -- Splitting ``Operators.sequential_split(), Operators.recursive_split()``"

#: ../../manual/render/freestyle/python.rst:66
msgid "Sorting ``Operators.sort()``"
msgstr "Сортування -- Sorting ``Operators.sort()``"

#: ../../manual/render/freestyle/python.rst:67
msgid "Stroke creation ``Operators.create()``"
msgstr "Створення штриха -- Stroke creation ``Operators.create()``"

#: ../../manual/render/freestyle/python.rst:69
msgid "The input view map is populated with a set of ViewEdge objects. The selection operation is used to pick up ViewEdges of interest to artists based on user-defined selection conditions (predicates). Chaining operations take the subset of ViewEdges and build Chains by concatenating ViewEdges according to user-defined predicates and functions. The Chains can be further refined by splitting them into smaller pieces (e.g. at points where edges make an acute turn) and selecting a fraction of them (e.g. to keep only those longer than a length threshold). The sorting operation is used to arrange the stacking order of chains to draw one line on top of another. The chains are finally transformed into stylized strokes by the stroke creation operation applying a series of stroke shaders to individual chains."
msgstr "Увідна карта огляду заповнюється набором об'єктів ViewEdge. Операція виділення використовується для вибору ViewEdges, що представляють інтерес для митців на основі визначених користувачем умов (предикатів) виділення. Операції зчіплювання приймають піднабір ViewEdges та будують Ланцюги, зчіплюючи ViewEdges відповідно до визначених користувачем предикатів та функцій. Ці Ланцюги можуть бути далі уточнені, розділенням їх на менші шматки (наприклад, у точках, де краї роблять гострий поворот) та виділенням частини їх (наприклад, для збереження тільки тих, що довші, ніж поріг довжини). Операція сортування використовується для впорядкування ланцюгів у стеку для прорису однієї лінії поверхн іншої. Ланцюги фінально трансформуються у стилізовані штрихи операцією створення штрихів шляхом застосування серії відтінювачів штрихів до окремих ланцюгів."

#: ../../manual/render/freestyle/python.rst:80
msgid "ViewEdges, Chains and Strokes are generically referred to as one-dimensional (1D) elements. A 1D element is a polyline that is a series of connected straight lines. Vertices of 1D elements are called 0D elements in general."
msgstr "ViewEdges, Chains та Strokes загалом називаються одновимірними (1D) елементами. 1D елемент -- це полілінія, що є серією з'єднаних прямих ліній. Вершини 1D елементів називаються 0D елементами, у загальному."

#: ../../manual/render/freestyle/python.rst:84
msgid "All the operators act on a set of active 1D elements. The initial active set is the set of ViewEdges in the input view map. The active set is updated by the operators."
msgstr "Усі оператори діють на наборі активних 1D елементів. Початковий активний набір -- це набір ViewEdges в увідній карті огляду. Активний набір оновлюється операторами."

#: ../../manual/render/freestyle/python.rst:89
msgid "Selection"
msgstr "Виділення -- Selection"

#: ../../manual/render/freestyle/python.rst:92
msgid "The selection operator goes through every element of the active set and keeps only the ones satisfying a certain predicate. The ``Operators.select()`` method takes as the argument a unary predicate that works on any ``Interface1D`` that represents a 1D element. For example::"
msgstr "Оператор виділення, вибору проходить через кожен елемент активного набору та зберігає тільки ті, які задовільняють вимоги певного предиката. Метод ``Operators.select()`` приймає як аргумент одноаргументний предикат, що працює на будь-якому ``Interface1D``, що представляє 1D елемент. Наприклад::"

#: ../../manual/render/freestyle/python.rst:98
msgid "This selection operation uses the ``QuantitativeInvisibilityUP1D`` predicate to select only the visible ``ViewEdge`` (more precisely, those whose quantitative invisibility is equal to 0). The selection operator is intended to selectively apply the style to a fraction of the active 1D elements."
msgstr "Ця операція виділення використовує предикат ``QuantitativeInvisibilityUP1D`` для вибору тільки видимих ``ViewEdge`` (більш точно тих, яких кількісна невидимість дорівнює 0). Оператор виділення наміряється вибірково застосувати стиль до частини активних 1D елементів."

#: ../../manual/render/freestyle/python.rst:102
msgid "It is noted that ``QuantitativeInvisibilityUP1D`` is a class implementing the predicate that tests line visibility, and the ``Operators.select()`` method takes an instance of the predicate class as argument. The testing of the predicate for a given 1D element is actually done by calling the predicate instance, that is, by invoking the ``__call__`` method of the predicate class. In other words, the ``Operators.select()`` method takes as argument a functor which in turn takes an ``Interface0D`` object as argument. The Freestyle Python API employs functors extensively to implement predicates, as well as functions."
msgstr "Відзначено, що ``QuantitativeInvisibilityUP1D`` -- це клас реалізації предиката, що перевіряє видимість лінії, а метод ``Operators.select()`` приймає примірник класу предиката як аргумент. Перевірка предиката для даного 1D елемента фактично робиться викликом примірника предикати, тобто, залучаючи метод ``__call__`` класу предиката. Іншими словами, метод ``Operators.select()`` приймає як аргумент функтор -- functor, який, у свою чергу, приймає об'єкт ``Interface0D`` як аргумент. Freestyle Python API широко вживає функтори для реалізації предикатів, а також функцій."

#: ../../manual/render/freestyle/python.rst:110
msgid "Chaining"
msgstr "Зчіплювання -- Chaining"

#: ../../manual/render/freestyle/python.rst:113
msgid "The chaining operators act on the set of active ``ViewEdge`` objects and determine the topology of the future strokes. The idea is to implement an iterator to traverse the ViewMap graph by marching along ViewEdges. The iterator defines a chaining rule that determines the next ``ViewEdge`` to follow at a given vertex (see ``ViewEdgeIterator``). Several such iterators are provided as part of the Freestyle Python API (see ``ChainPredicateIterator`` and ``ChainSilhouetteIterator``). Custom iterators can be defined by inheriting the ``ViewEdgeIterator`` class. The chaining operator also takes as argument a UnaryPredicate working on ``Interface1D`` as a stopping criteria. The chaining stops when the iterator has reached a ``ViewEdge`` satisfying this predicate during the march along the graph."
msgstr "Оператори зчіплювання діють на наборі активних об'єктів ``ViewEdge`` та визначають топологію майбутніх штрихів. Ідея полягає в реалізації повторювача -- iterator для проходження графа ViewMap шляхом пересування уздовж ViewEdges. Повторювач визначає правило зчіплювання, яке визначає наступний ``ViewEdge`` для слідування у задану вершину (дивіться ``ViewEdgeIterator``). Кілька таких повторювачів надаються як частина Freestyle Python API (дивіться ``ChainPredicateIterator`` та ``ChainSilhouetteIterator``). Власні користувацькі повторювачі можуть визначатися успадковуванням класу ``ViewEdgeIterator``. Оператор зчіплювання також приймає як аргумент UnaryPredicate, що працює на ``Interface1D``, як критерій зупинки. Зчіплювання зупиняється, коли повторювач досяг задоволення ``ViewEdge`` умов цього предикату у ході пересування по графу."

#: ../../manual/render/freestyle/python.rst:124
msgid "Chaining can be either unidirectional ``Operators.chain()`` or bidirectional ``Operators.bidirectional_chain()``. In the latter case, the chaining will propagate in the two directions from the starting edge."
msgstr "Зчіплювання може бути однонапрямним ``Operators.chain()`` або двонапрямним ``Operators.bidirectional_chain()``. В останньому випадку, зчіплювання буде поширюватися у двох напрямках від стартового краю."

#: ../../manual/render/freestyle/python.rst:127
msgid "The following is a code example of bidirectional chaining::"
msgstr "Наступне є прикладом коду двонапрямного зчіплювання:"

#: ../../manual/render/freestyle/python.rst:134
msgid "The chaining operator uses the ``ChainSilhouetteIterator`` as the chaining rule and stops chaining as soon as the iterator has come to an invisible ``ViewEdge``."
msgstr "Оператор зчіплювання використовує ``ChainSilhouetteIterator`` як правило зчіплювання та зупиняє зчіплювання зразу ж, як повторювач прийшов до невидимого ``ViewEdge``."

#: ../../manual/render/freestyle/python.rst:137
msgid ""
"The chaining operators process the set of active ``ViewEdge`` objects in order. The active ViewEdges can be previously sorted using the ``Operators.sort()`` method (see below). It starts a chain with the first ``ViewEdge`` of the active set. All ViewEdges that have already been involved in the chaining process are marked (in the case of the example above, the time stamp of each ``ViewEdge`` is modified by default), in order not to process the same ``ViewEdge`` twice. Once the chaining reaches a ``ViewEdge`` that satisfies the stopping predicate, the chain is terminated. Then a new chain is started from the first unmarked ``ViewEdge`` in the active set. This operation is repeated until the last unmarked ``ViewEdge`` of the active set was processed. At the end of the chaining operation, the active set is set to the Chains that have just been "
"constructed."
msgstr "Оператори зчіплювання обробляють набір активних об'єктів ``ViewEdge`` за порядком. Активні ViewEdges можуть попередньо бути сортовані за допомогою методу ``Operators.sort()`` (дивіться нижче). Він запускає ланцюг з першого ``ViewEdge`` активного набору. Усі ViewEdges, що вже були залучені у процес зчіплювання, позначаються (у випадку прикладу вище, штамп часу кожного ``ViewEdge`` модифікується стандартно), щоб не обробляти двічі один і той же ``ViewEdge``. Після того, як зчіплювання досягає ``ViewEdge``, що задовільняє умовам предиката зупинки, ланцюг завершується. Далі новий ланцюг починається з першого непозначеного ``ViewEdge`` в активному наборі. Ця операція повторюється, допоки останній непозначений ``ViewEdge`` з активного набору не буде оброблено. У кінці операції зчіплювання, активний набір -- це набір Ланцюгів, що були побудовані."

#: ../../manual/render/freestyle/python.rst:150
msgid "Splitting"
msgstr "Розділення -- Splitting"

#: ../../manual/render/freestyle/python.rst:153
msgid "The splitting operation is used to refine the topology of each Chain. Splitting is performed either sequentially or recursively. Sequential splitting ``Operators.sequentialSplit()`` in its basic form, parses the Chain at a given arbitrary resolution and evaluates a unary predicate (working on 0D elements) at each point along the Chain. Every time the predicate is satisfied, the chain is split into two chains. At the end of the sequential split operation, the active set of chains is set to the new chains. ::"
msgstr "Операція розділення використовується для уточнення топології кожного Ланцюга. Розділення здійснюється послідовно або рекурсивно. Послідовне розділення ``Operators.sequentialSplit()`` у своїй базовій формі, аналізує Ланцюг у заданій довільній роздільності та оцінює одноаргументний предикат (працюючи на 0D елементах) у кожній точці уздовж цього Ланцюга. Кожен раз, при задоволенні предиката, ланцюг розділюється на два ланцюги. У кінці операції послідовного розділення активний набір ланцюгів є набором нових ланцюгів. ::"

#: ../../manual/render/freestyle/python.rst:164
msgid "In this example, the chain is split every 2 units. A more elaborated version uses two predicates instead of one: One to determine the starting point of the new chain and the other to determine its ending point. This second version can lead to a set of Chains that are disjoint or that overlap if the two predicates are different. (see ``Operators.sequentialSplit()`` for more details)."
msgstr "У цьому прикладі, ланцюг розділяється кожні 2 одиниці. Більш розроблена версія використовує два предикати замість одного: один для визначення стартової точки нового ланцюга та другий для визначення його кінцевої точки. Ця друга версія може призвести до набору Ланцюгів, що є роз'єднаними або що перекриваються, якщо два ці предикати є різними. (дивіться детальніше ``Operators.sequentialSplit()``)."

#: ../../manual/render/freestyle/python.rst:170
msgid "Recursive splitting ``Operators.recursiveSplit()`` evaluates a function on the 0D elements along the Chain at a given resolution and find the point that gives the maximum value for the function. The Chain is then split into two at that point. This process is recursively repeated on each of the two new Chains, until the input Chain satisfies a user-specified stopping condition. ::"
msgstr "Рекурсивне розділення ``Operators.recursiveSplit()`` оцінює функцію на 0D елементах уздовж Ланцюга у заданій роздільності та знаходить точку, що дає максимальне значення для цієї функції. Ланцюг далі розділяється на два у цій точці. Цей процес рекурсивно повторюється на кожному з двох нових Ланцюгів, допоки увідний Ланцюг не буде задовольняти визначеній користувачем умові зупинення. ::"

#: ../../manual/render/freestyle/python.rst:180
msgid "In the code example above, the Chains are recursively split at points of the highest 2D curvature. The curvature is evaluated at points along the Chain at a resolution of 5 units. Chains shorter than 5 units will not be split anymore."
msgstr "У прикладі коду вище, Ланцюги рекурсивно розділяються у точках найвищої 2D кривини. Ця кривина оцінюється у точках уздовж Ланцюга з роздільністю 5 одиниць. Ланцюги, коротші, ніж 5 одиниць, не будуть більше розділятися."

#: ../../manual/render/freestyle/python.rst:186
msgid "Sorting"
msgstr "Сортування -- Sorting"

#: ../../manual/render/freestyle/python.rst:189
msgid "The sorting operator ``Operators.sort()`` arranges the stacking order of active 1D elements. It takes as argument a binary predicate used as a \"smaller than\" operator to order two 1D elements. ::"
msgstr "Оператор сортування ``Operators.sort()`` впорядковує порядок нашарування активних 1D елементів. Він приймає як аргумент двоаргументний предикат, використовуваний як оператор «менше ніж» до порядку 1D елементів. ::"

#: ../../manual/render/freestyle/python.rst:195
msgid "In this code example, the sorting uses the ``Length2DBP1D`` binary predicate to sort the ``Interface1D`` objects in the ascending order in terms of 2D length."
msgstr "У цьому прикладі коду, сортування використовує двоаргументний предикат ``Length2DBP1D`` для сортування об'єктів ``Interface1D`` у висхідному порядку у термінах 2D довжини."

#: ../../manual/render/freestyle/python.rst:198
msgid "The sorting is particularly useful when combined with causal density. Indeed, the causal density evaluates the density of the resulting image as it is modified. If we wish to use such a tool to decide to remove strokes whenever the local density is too high, it is important to control the order in which the strokes are drawn. In this case, we would use the sorting operator to ensure that the most \"important\" lines are drawn first."
msgstr "Сортування особливо корисне, коли комбінується з щільністю причин. Дійсно, щільність причин оцінює щільність результатного зображення при його модифікації. Якщо ми бажаємо використати такий інструмент для вирішення того, що слід вилучити штрихи кожен раз, коли локальна щільність є надто високою, то важливо контролювати порядок, в якому ці штрихи прорисовуються. У цьому випадку, ми скористаємося оператором сортування для гарантування, що більш «важливі» лінії прорисуються першими."

#: ../../manual/render/freestyle/python.rst:205
msgid "Stroke Creation"
msgstr "Створення Штриха -- Stroke Creation"

#: ../../manual/render/freestyle/python.rst:208
msgid "Finally, the stroke creation operator ``Operators.create()`` takes the active set of Chains as input and build Strokes. The operator takes two arguments. The first is a unary predicate that works on ``Interface1D`` that is designed to make a last selection on the set of chains. A Chain that does not satisfy the condition will not lead to a Stroke. The second input is a list of shaders that will be responsible for the shading of each built stroke. ::"
msgstr "Фінально, оператор створення штрихів ``Operators.create()`` приймає активний набір Ланцюгів як увід та будує Штрихи. Цей оператор приймає два аргументи. Перший -- це одноаргументний предикат, що працює на ``Interface1D``, який призначений для зроблення останнього виділення на наборі ланцюгів. Ланцюг, що не задовільняє цій умові, не перейде далі у Штрих. Другий увід -- це список відтінювачів, що будуть відповідати за відтінення кожного побудованого штриха. ::"

#: ../../manual/render/freestyle/python.rst:222
msgid "In this example, the ``DensityUP1D`` predicate is used to remove all Chains whose mean density is higher than 0.1. Each chain is transformed into a stroke by resampling it so as to have a point every 5 units and assigning to it a constant thickness of 2 units and a dark gray constant color."
msgstr "У цьому прикладі, предикат ``DensityUP1D`` використовується для вилучення усіх Ланцюгів, які мають середню щільність, вище за 0.1. Кожен ланцюг трансформується у штрих шляхом повторного відбору так, щоб мати точку через кожні 5 одиниць, призначення для нього постійної товщини у 2 одиниці та темно-сірого постійного кольору."

#: ../../manual/render/freestyle/python.rst:228
msgid "User Control on the Pipeline Definition"
msgstr "Керування користувачем конвеєром визначення"

#: ../../manual/render/freestyle/python.rst:231
msgid "Style module writing offers different types of user control, even though individual style modules have a fixed pipeline structure. One is the sequencing of different pipeline control structures, and another is through the definition of functor objects that are passed as argument all along the pipeline."
msgstr "Написання модуля стилю пропонує різні типи керування користувачем, навіть хоча окремі модулі стилю мають фіксовану структуру конвеєра. Одним з них є задання послідовності різних керувальних структур конвеєра, а іншим -- через визначення об'єктів функторів, що передаються як аргумент уздовж усього конвеєра."

#: ../../manual/render/freestyle/python.rst:236
msgid "Different pipeline control structures can be defined by sequencing the selection, chaining, splitting, and sorting operations. The stroke creation is always the last operation that concludes a style module."
msgstr "Різні структури керування конвеєром можуть бути визначені заданням операцій виділення, зчіплювання, розділення та сортування. Створення штриха є завжди останньою операцією, що завершує модуль стилю."

#: ../../manual/render/freestyle/python.rst:240
msgid "Predicates, functions, chaining iterators, and stroke shaders can be defined by inheriting base classes and overriding appropriate methods. See the reference manual entries of the following base classes for more information on the user-scriptable constructs."
msgstr "Предикати, функції, повторювачі зчіплювання та відтінювачі штрихів можуть визначатися успадковуванням базових класів та перевизначенням відповідних методів. Для отримання додаткової інформації про визначувані користувачем конструкції дивіться відповідні записи про наступні базові класи."

#: ../../manual/render/freestyle/python.rst:249
msgid "``UnaryPredicate0D``"
msgstr "``UnaryPredicate0D``"

#: ../../manual/render/freestyle/python.rst:250
msgid "``UnaryPredicate1D``"
msgstr "``UnaryPredicate1D``"

#: ../../manual/render/freestyle/python.rst:251
msgid "``BinaryPredicate0D``"
msgstr "``BinaryPredicate0D``"

#: ../../manual/render/freestyle/python.rst:252
msgid "``BinaryPredicate1D``"
msgstr "``BinaryPredicate1D``"

#: ../../manual/render/freestyle/python.rst:253
msgid "``UnaryFunction0DDouble``"
msgstr "``UnaryFunction0DDouble``"

#: ../../manual/render/freestyle/python.rst:254
msgid "``UnaryFunction0DEdgeNature``"
msgstr "``UnaryFunction0DEdgeNature``"

#: ../../manual/render/freestyle/python.rst:255
msgid "``UnaryFunction0DFloat``"
msgstr "``UnaryFunction0DFloat``"

#: ../../manual/render/freestyle/python.rst:256
msgid "``UnaryFunction0DId``"
msgstr "``UnaryFunction0DId``"

#: ../../manual/render/freestyle/python.rst:257
msgid "``UnaryFunction0DMaterial``"
msgstr "``UnaryFunction0DMaterial``"

#: ../../manual/render/freestyle/python.rst:258
msgid "``UnaryFunction0DUnsigned``"
msgstr "``UnaryFunction0DUnsigned``"

#: ../../manual/render/freestyle/python.rst:259
msgid "``UnaryFunction0DVec2f``"
msgstr "``UnaryFunction0DVec2f``"

#: ../../manual/render/freestyle/python.rst:260
msgid "``UnaryFunction0DVec3f``"
msgstr "``UnaryFunction0DVec3f``"

#: ../../manual/render/freestyle/python.rst:261
msgid "``UnaryFunction0DVectorViewShape``"
msgstr "``UnaryFunction0DVectorViewShape``"

#: ../../manual/render/freestyle/python.rst:262
msgid "``UnaryFunction0DViewShape``"
msgstr "``UnaryFunction0DViewShape``"

#: ../../manual/render/freestyle/python.rst:263
msgid "``UnaryFunction1DDouble``"
msgstr "``UnaryFunction1DDouble``"

#: ../../manual/render/freestyle/python.rst:264
msgid "``UnaryFunction1DEdgeNature``"
msgstr "``UnaryFunction1DEdgeNature``"

#: ../../manual/render/freestyle/python.rst:265
msgid "``UnaryFunction1DFloat``"
msgstr "``UnaryFunction1DFloat``"

#: ../../manual/render/freestyle/python.rst:266
msgid "``UnaryFunction1DUnsigned``"
msgstr "``UnaryFunction1DUnsigned``"

#: ../../manual/render/freestyle/python.rst:267
msgid "``UnaryFunction1DVec2f``"
msgstr "``UnaryFunction1DVec2f``"

#: ../../manual/render/freestyle/python.rst:268
msgid "``UnaryFunction1DVec3f``"
msgstr "``UnaryFunction1DVec3f``"

#: ../../manual/render/freestyle/python.rst:269
msgid "``UnaryFunction1DVectorViewShape``"
msgstr "``UnaryFunction1DVectorViewShape``"

#: ../../manual/render/freestyle/python.rst:270
msgid "``UnaryFunction1DVoid``"
msgstr "``UnaryFunction1DVoid``"

#: ../../manual/render/freestyle/python.rst:271
msgid "``ViewEdgeIterator``"
msgstr "``ViewEdgeIterator``"

#: ../../manual/render/freestyle/python.rst:272
msgid "``StrokeShader``"
msgstr "``StrokeShader``"
