# SOME DESCRIPTIVE TITLE.
# Copyright (C) : This page is licensed under a CC-BY-SA 4.0 Int. License
# This file is distributed under the same license as the Blender 2.78 Manual
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
msgid ""
msgstr ""
"Project-Id-Version: Blender 2.78 Manual 2.78\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-08-08 02:49+0800\n"
"PO-Revision-Date: 2019-08-11 10:17+0800\n"
"Last-Translator: \n"
"Language: zh\n"
"Language-Team: \n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"
"X-Generator: Poedit 2.2.3\n"

#: ../../manual/animation/drivers/workflow_examples.rst:4
msgid "Workflow & Examples"
msgstr "工作流程 & 范例"

#: ../../manual/animation/drivers/workflow_examples.rst:6
msgid "Simple Drivers can be configured from the pop-over that appears when adding a new Driver."
msgstr "简单驱动器可以通过弹窗添加。"

#: ../../manual/animation/drivers/workflow_examples.rst:8
msgid ""
"When adding multiple Drivers or for more advanced configurations, it is useful to have open the :"
"doc:`Drivers Editor </editors/drivers_editor>`."
msgstr "当有多个驱动器或者更高级的设置时，可以使用 :doc:`驱动器编辑器 </editors/drivers_editor>` 。"

#: ../../manual/animation/drivers/workflow_examples.rst:14
msgid "Transform Driver"
msgstr "变换驱动器"

#: ../../manual/animation/drivers/workflow_examples.rst:16
msgid ""
"Control a property with an object's transform. In this example, the Y rotation of Object 2 will be "
"driven by the X position of Object 1."
msgstr "利用物体的变换来控制属性。在此例中，物体2的Y轴旋转被物体1的X轴位移驱动。"

#: ../../manual/animation/drivers/workflow_examples.rst:19
msgid "Starting from a simple setup with two objects:"
msgstr "首先，简单设置下两个物体："

#: ../../manual/animation/drivers/workflow_examples.rst:21
msgid ""
"Add a Driver to the *Rotation Y* property of the second object via the context menu or with :kbd:"
"`Ctrl-D`."
msgstr ""
"通过上下文菜单(右键菜单)或使用快捷键 :kbd:`Ctrl-D` ，在第二个物体的Y轴旋转属性上添加驱动器。"

#: ../../manual/animation/drivers/workflow_examples.rst:25
msgid "Open the *Drivers Editor* and select the *Y Euler Rotation* property in the channels region."
msgstr "打开 *驱动器编辑器* ，然后在左侧通道里选择 *Y欧拉旋转* 。"

#: ../../manual/animation/drivers/workflow_examples.rst:26
msgid "Open the Sidebar region and select the *Drivers* tab."
msgstr "按下 :kbd:`N` 打开侧栏，选择 *驱动器* 选项卡。"

#: ../../manual/animation/drivers/workflow_examples.rst:27
msgid "Configure the driver to be the *Averaged Value* of a *Transform Channel* of the first object."
msgstr "驱动器类型选择平均化值，选择 *变换通道* ，在 物体一栏里选择第一个物体。"

#: ../../manual/animation/drivers/workflow_examples.rst:31
msgid ""
"Experiment with moving the first object and notice how it affects the Y rotation of the second "
"object."
msgstr "试着移动物体1，并注意它是如何影响物体2的。"

#: ../../manual/animation/drivers/workflow_examples.rst:36
msgid "Scripted Expression - Orbit a Point"
msgstr "脚本表达式——轨道点"

#: ../../manual/animation/drivers/workflow_examples.rst:38
msgid ""
"Orbit an object's position around a point with a custom *Scripted Expression*. The object's "
"position will change when scrubbing the timeline."
msgstr "使用 *脚本表达式* ，控制物体在轨道上运动。当时间轴移动时，物体发生位置变化。"

#: ../../manual/animation/drivers/workflow_examples.rst:41
msgid ""
"Using trigonometry, circular motion can be defined in 2D using the sinus and cosine functions. "
"(See `Unit Circle <https://en.wikipedia.org/wiki/Unit_circle>`__.)"
msgstr ""
"利用三角函数，可以使用正弦和余弦函数在2D中定义圆周运动。 (详见 `单位圆 <https://en.wikipedia.org/"
"wiki/Unit_circle>`__.)"

#: ../../manual/animation/drivers/workflow_examples.rst:44
msgid ""
"In this example, the current frame is used as the variable that induces the motion. ``frame`` is "
"a :ref:`Simple Expression <drivers-simple-expressions>` that corresponds to ``bpy.context.scene."
"frame_current``."
msgstr ""
"在此例中，当前帧作为控制变量。 ``frame`` 是一个 :ref:`简单表达式 <drivers-simple-expressions>` 对"
"应 ``bpy.context.scene.frame_current``。"

#: ../../manual/animation/drivers/workflow_examples.rst:50
msgid "Add a driver to the X Location property."
msgstr "在物体X轴位置属性上添加驱动器。"

#: ../../manual/animation/drivers/workflow_examples.rst:52
msgid "Set the *Driver Type* to *Scripted Expression*."
msgstr "将驱动器 *类型* 设置为 *脚本表达式* 。"

#: ../../manual/animation/drivers/workflow_examples.rst:53
msgid "Add the expression ``0 + (sin(frame / 8) * 4)``, where:"
msgstr "添加表达式 ``0 + (sin(frame / 8) * 4)``："

#: ../../manual/animation/drivers/workflow_examples.rst:55
msgid "``frame/8`` : is the current frame of the animation, divided by 8 to slow the orbit down."
msgstr "``frame/8`` : 是但前帧数除以8，除8是为了减速。"

#: ../../manual/animation/drivers/workflow_examples.rst:56
msgid "``(sin( )*4)`` : multiplies the result of ``sin(frame/8)`` by 4 for a bigger circle."
msgstr "``(sin( )*4)`` : 将结果 ``sin(frame/8)`` 乘以4得到一个更大的圆形。"

#: ../../manual/animation/drivers/workflow_examples.rst:57
msgid "``0 +`` : is used to control the offset to the orbit center point."
msgstr "``0 +`` : 控制偏移量。"

#: ../../manual/animation/drivers/workflow_examples.rst:59
msgid "Add a driver to the Y Location property with the expression ``0 + (cos(frame / 8) * 4)``."
msgstr "用同样的方法，在物体Y轴位置属性上添加驱动器，脚本公式为 ``0 + (sin(frame / 8) * 4)``。"

#: ../../manual/animation/drivers/workflow_examples.rst:60
msgid ""
"Scrub the timeline to see the effect. Experiment with the variables to control the size and center "
"of the orbit."
msgstr "移动时间轴观察物体位移变化，尝试改变变量来影响轨道大小和中心。"

#: ../../manual/animation/drivers/workflow_examples.rst:68
msgid "Custom Function - Square Value"
msgstr ""

#: ../../manual/animation/drivers/workflow_examples.rst:70
msgid ""
"Create a custom function to get the square of a value (i.e. *value*\\ :sup:`2`). Adding the "
"function to the *Driver Namespace* allows it to be used from driver expressions."
msgstr ""

#: ../../manual/animation/drivers/workflow_examples.rst:73
msgid ""
"The *Driver Namespace* has a list of built-in functions for use in driver expressions, as well as "
"constants such as π and e. These can be inspected via the Python Console::"
msgstr ""

#: ../../manual/animation/drivers/workflow_examples.rst:85
msgid ""
"To add a new function to the *Driver Namespace*, the function itself needs to be implemented and "
"then added to the ``bpy.app.driver_namespace``."
msgstr ""

#: ../../manual/animation/drivers/workflow_examples.rst:88
msgid "Add the following to the Text Editor inside Blender and press *Run Script*. ::"
msgstr ""

#: ../../manual/animation/drivers/workflow_examples.rst:99
msgid "Add a driver with a *Scripted Expression* such as ``square(frame)``."
msgstr ""

#: ../../manual/animation/drivers/workflow_examples.rst:100
msgid "Observe the effect when scrubbing the timeline."
msgstr ""

#: ../../manual/animation/drivers/workflow_examples.rst:102
msgid ""
"There are more custom function examples available in Blender's Text Editor :menuselection:"
"`Templates --> Python --> Driver Functions`."
msgstr ""

#: ../../manual/animation/drivers/workflow_examples.rst:105
msgid ""
"Since :ref:`Simple Expressions <drivers-simple-expressions>` cannot access custom functions, using "
"them only makes sense for complex computations."
msgstr ""

#: ../../manual/animation/drivers/workflow_examples.rst:112
msgid "Shape Key Drivers"
msgstr "形态键驱动器"

#: ../../manual/animation/drivers/workflow_examples.rst:115
msgid "Improved Mesh Deformation"
msgstr "改进网络变形"

#: ../../manual/animation/drivers/workflow_examples.rst:117
msgid ""
"Fix intersection problems that happen when using armatures and weight painting, especially at "
"joints. Shape keys can also be used to tweak and refine a rig, for example to suggest muscle "
"formations. In this example, a shape key is used to improve the deformation at the elbow of a "
"rudimentary arm."
msgstr ""
"修复在使用骨骼和绘制权重时发生的交叉点问题，特别是在关节处。形态键可以调整和改进物体，例如形成肌"
"肉。在该示例中，形态键用于改善手臂弯曲时肘部的变形。"

#: ../../manual/animation/drivers/workflow_examples.rst:123
msgid "Left: Skeletal mesh deformation without correction. Right: Corrective shape key applied"
msgstr "左：网络变形未修正。 右：应用形态键修正"

#: ../../manual/animation/drivers/workflow_examples.rst:134
msgid "Setup"
msgstr "新建"

#: ../../manual/animation/drivers/workflow_examples.rst:128
msgid "Add a mesh (in this example, a cylinder with loop cuts)."
msgstr "添加一个物体(此例中，圆柱体进行了环切)。"

#: ../../manual/animation/drivers/workflow_examples.rst:129
msgid "Add an armature with a chain of bones."
msgstr "添加骨骼链。"

#: ../../manual/animation/drivers/workflow_examples.rst:130
msgid "Skin the mesh to the armature using weight painting."
msgstr "在物体上添加权重。"

#: ../../manual/animation/drivers/workflow_examples.rst:132
msgid ""
"(Note: to parent the mesh to the armature: select the mesh first, then the armature and use :kbd:"
"`Ctrl-P` to parent with auto weights.)"
msgstr "(注意：先选择物体，按住shift，再选择骨骼，按下 :kbd:`Ctrl-P` ，选择自动权重。)"

#: ../../manual/animation/drivers/workflow_examples.rst:136
msgid ""
"Experiment with posing the armature and observe the deformation at the joint. To fix intersection "
"problems or angles that look unsatisfactory, you can associate a :doc:`Shape Key </animation/"
"shape_keys/index>` with a pose."
msgstr ""
"尝试改变骨骼姿态并观察关节处的形变。要修复看起来不满的交叉点或角度，可以将 :doc:`形态键 </"
"animation/shape_keys/index>` 与姿态关联。"

#: ../../manual/animation/drivers/workflow_examples.rst:154
msgid "Shape Key"
msgstr "形态键"

#: ../../manual/animation/drivers/workflow_examples.rst:142
msgid ""
"Pose the armature such that the problems are visible. Be sure to cover the extreme poses that you "
"want to support for the rig."
msgstr "调整骨骼姿态，把骨骼调整带你需要弯曲的最大值。"

#: ../../manual/animation/drivers/workflow_examples.rst:144
msgid ""
"With the mesh selected, add a new *Shape Key* in addition to the *Basis* key. :menuselection:"
"`Properties --> Mesh tab --> Shape Keys`"
msgstr ""
"选择物体，添加形态键，除 *Basis* 外再添加一个形态 *Key 1* 。. :menuselection:`Properties --> Mesh "
"tab --> Shape Keys`"

#: ../../manual/animation/drivers/workflow_examples.rst:146
msgid ""
"In order to author the shape key on top of the armature deformation, enable both *Edit Mode "
"Display* and *Cage Editing* in the armature modifier. :menuselection:`Properties --> Modifiers tab "
"--> Armature Modifier --> Header`"
msgstr ""

#: ../../manual/animation/drivers/workflow_examples.rst:149
msgid ""
"Enter Edit Mode and select the new shape key in the properties panel. Adjust the vertices as "
"desired. Select the *Basis* key to toggle between the original mesh and your edits. (Note: be "
"careful to apply edits only to your shape and not to the original mesh or other existing keys.)"
msgstr ""
"进入编辑模式，然后在属性面板中选择新的形态键“Key1”，根据需要调整顶点。选择 *Basis* 键可在原始形状和"
"编辑之后的形状之间切换。(注意：只对需要调整的地方进行编辑，而不是对原始网络或其它形态键进行编"
"辑。)"

#: ../../manual/animation/drivers/workflow_examples.rst:156
msgid ""
"Once you are satisfied with how the deformation looks for the problematic pose, you'll need to "
"configure a driver to activate the shape smoothly when entering that position."
msgstr "当你调整好形状后，要配置一个驱动器，以便可以平滑的改变形状。"

#: ../../manual/animation/drivers/workflow_examples.rst:223
msgid "Driver"
msgstr "驱动器"

#: ../../manual/animation/drivers/workflow_examples.rst:161
msgid "Add a driver to the *Value* of the shape key you've created."
msgstr "在形态键的值上添加驱动器。"

#: ../../manual/animation/drivers/workflow_examples.rst:162
msgid "Open the Drivers Editor and select the driver."
msgstr "打开驱动器编辑器并选择驱动通道。"

#: ../../manual/animation/drivers/workflow_examples.rst:192
msgid "Method 1 -- Direct mapping to a bone rotation value"
msgstr "方法1 — 直接映射到骨骼旋转值"

#: ../../manual/animation/drivers/workflow_examples.rst:165
msgid ""
"A simple way to configure the driver is with a direct correspondence of the value of a bone's "
"rotation channel to the shape key activation *Value*. This method has the disadvantage of relying "
"on a single channel of a bone's rotation which might be insufficient to precisely express the "
"condition under which the shape key should be activated."
msgstr ""
"一种简单的方法是将骨骼的旋转属性直接与形态键 *值* 对应。缺点是依赖单一数值，不足以精确的控制形态键"
"的激活条件。"

#: ../../manual/animation/drivers/workflow_examples.rst:171
msgid "In the Drivers tab, select the *Averaged Value* of the rotation of the bone you're posing."
msgstr "在“驱动器”选项卡中，选择控制器类型为“平均值”。"

#: ../../manual/animation/drivers/workflow_examples.rst:174
msgid ""
"Understand the rotation axis that you're interested in by enabling axes display in the armature or "
"by observing the bone's transform values in the Properties."
msgstr "通过观察骨骼的旋转属性的值来了解你感兴趣的旋转轴。"

#: ../../manual/animation/drivers/workflow_examples.rst:177
msgid ""
"Select the rotation channel and set it to local, meaning, the bone's rotation value relative to "
"its parent bone."
msgstr "选择旋转通道，间隔设置为自身空间，即骨骼相对于父骨骼的旋转值。"

#: ../../manual/animation/drivers/workflow_examples.rst:182
msgid ""
"Manually set points in the driver curve by selecting a handle and dragging it or inserting values "
"in the *F-Curve* tab. The Y axis represents the shape key *Value*, which should go from 0.0 to "
"1.0. The X axis is usually the frame, but for this driver it represents the rotation value in "
"radians. You can have more than two points in the curve and tweak the transitions with the handles "
"in the curve view (:kbd:`G` to move)."
msgstr ""
"选择曲线控制柄并拖动它或者在 *函数曲线* 选项卡中输入数值。Y轴表示形态键的 *值* ，范围是0.0到1.0。X"
"轴通常是帧数，但在此驱动程序中它表示以弧度制的旋转值。曲线中有两个以上的点，使用曲线视图中的控制柄"
"调整过度 (:kbd:`G` 抓取)。"

#: ../../manual/animation/drivers/workflow_examples.rst:189
msgid ""
"To verify that the driver behaves correctly, deselect the option to only show drivers for selected "
"objects. This way, you can pose the armature and keep an eye on the driver."
msgstr ""

#: ../../manual/animation/drivers/workflow_examples.rst:223
msgid "Method 2 -- Rotational difference to a target bone"
msgstr "方法二：与目标骨骼的旋转差值"

#: ../../manual/animation/drivers/workflow_examples.rst:195
msgid ""
"This method requires an additional *target* or *corrective* bone, but it better expresses the "
"spatial condition in 3D space of the bone that is causing the problem."
msgstr "这种方法需要额外的 *目标* 或 *矫正* 骨骼，但它能更好地表示骨骼在3D空间中的条件。"

#: ../../manual/animation/drivers/workflow_examples.rst:199
msgid ""
"In armature Edit Mode, add a new bone extruded from Bone 1, in the position at which Bone 2 should "
"have the shape key active. This type of bones usually follow a naming convention such as \"TAR-"
"\" (target) or \"COR-\" (corrective)."
msgstr ""
"在骨骼编辑模式中，从骨骼1中挤出新骨骼，在骨骼2形态键值为1的位置。目标骨骼通常有约定的命名方法，例"
"如“TAR-”(目标)或“COR-”(矫正)。"

#: ../../manual/animation/drivers/workflow_examples.rst:204
msgid ""
"In the Drivers tab, select the *Averaged Value* of the rotational difference between the bone "
"you're rotating and the target bone. A rotational difference is the minimum angle between two "
"objects in World Space. It is therefore important that the bones have the same root, so that the "
"only thing affecting the angle between the bones is the rotation of one of them. When the "
"deformation bone (Bone 2) reaches the target rotation (TAR-Bone 2) the rotational difference will "
"be 0°."
msgstr ""
"在“驱动器”选项卡中，选择驱动类型为“平均化”值，驱动器变量类型为“旋转差值”。旋转差值是世界空间中连个"
"物体之间最小角度。因此，骨骼具有相同根基是很重要的，所以影响这个差值的唯一因素是其中一个骨骼旋转。"
"当变形骨(骨2)到达目标骨骼(TAR-Bone 2)时，旋转差为0°。"

#: ../../manual/animation/drivers/workflow_examples.rst:214
msgid ""
"Manually adjust the driver curve handles so that the shape key *Value* (Y axis) is 1.0 when the "
"rotational difference (X axis) is 0°. The *Value* should be 0.0 when the arm is extended, at which "
"point the rotational difference should be around 90° or more (in radians)."
msgstr ""
"手动调整函数曲线，使当旋转差(X轴)为0°时，形态键值(Y轴)为1.0。当臂伸直时，形态键值为0.0，此时旋"
"转差值约为90°或更大(以弧度制表示)。"

#: ../../manual/animation/drivers/workflow_examples.rst:219
msgid ""
"See the steps in Method 1 on how to adjust the curve handles and confirm that the functionality is "
"working. Pose the armature to verify that the ranges are correct."
msgstr "请参照方法1中有关如何调整控制柄并确认功能正确的步骤。调整骨骼查看设置范围是否正常。"

#: ../../manual/animation/drivers/workflow_examples.rst:226
msgid "Chained Relative Shape Keys"
msgstr ""

#: ../../manual/animation/drivers/workflow_examples.rst:228
msgid ""
"Activate different shape keys in succession. In this example, moving a single bone will activate "
"first *Key 1* and then *Key 2*. See also :ref:`relative shape keys mix additively <animation-"
"shapekeys-relative-vs-absolute>`."
msgstr ""
"连续激活不同的形态键。在此例中，移动单个骨骼将激活第一个 *Key 1* 后激活 *Key 2* 。另参见 :ref:`相对"
"或绝对形态键  <animation-shapekeys-relative-vs-absolute>` 。"

#: ../../manual/animation/drivers/workflow_examples.rst:234
msgid "Shape Keys"
msgstr "形态键"

#: ../../manual/animation/drivers/workflow_examples.rst:233
msgid "Add two shape keys to a mesh, besides the *Basis*."
msgstr "除了 *Basis* 之外，还为物体添加了两个形态键。"

#: ../../manual/animation/drivers/workflow_examples.rst:241
msgid "Basis"
msgstr "基础形状"

#: ../../manual/animation/drivers/workflow_examples.rst:246
msgid "Key 1: top faces moved up by 1m"
msgstr "键1：顶面向上移动1米"

#: ../../manual/animation/drivers/workflow_examples.rst:251
msgid "Key 2: inner top moved up by 1m"
msgstr "键2：内顶面向上移动1米"

#: ../../<generated>:1
msgid "Drivers"
msgstr "驱动器"

#: ../../manual/animation/drivers/workflow_examples.rst:255
msgid ""
"Add an armature with a single bone to control the shape keys. The goal is to activate the keys in "
"succession as this bone moves up."
msgstr "添加单段骨骼用来控制形态键。目的是骨骼向上移动的过程中连续激活形态键。"

#: ../../manual/animation/drivers/workflow_examples.rst:261
msgid ""
"As shown in the picture above, when the bone is halfway up, both *Key 1* and *Key 2* have an "
"influence. It is a matter of preference if *Key 1* should be at its maximum *Value* before *Key 2* "
"starts to become active, or how much they should overlap. This example shows a seamless blend."
msgstr ""
"如上图所示，当骨骼处于一半位置时， *Key 1* 和 *Key 2* 都会产生影响。这是一个偏好问题，如果 *Key 1* "
"在达到最大值之前， *Key 2* 便被激活，那这俩还是多少有些重叠的部分。此例是无缝混合。"

#: ../../manual/animation/drivers/workflow_examples.rst:265
msgid ""
"For a seamless blend where there is overlap, *Key 1* should have a *Value* of 0.0 when the bone is "
"at the bottom and increase linearly to 1.0 until the bone is past the midpoint height. *Key 2* "
"should have a value of 0.0 before the midpoint height and then increase at the same rate than *Key "
"1* until reaching *Value* 1.0 when the bone is at maximum height."
msgstr ""
"对于有重叠的无缝混合，当骨骼在低位置时， *Key 1* 的值为0.0，随着骨骼升高到中点高度，线性增加至"
"1.0。 *Key 2* 在骨骼到达中点高度之前的值为0.0，然后与 *Key 1* 相同的速率增加，直到骨骼到达最高点，"
"其值变为1.0."

#: ../../manual/animation/drivers/workflow_examples.rst:270
msgid ""
"Add a driver to the *Value* of *Key 1* and *Key 2*. In the *Drivers* tab, configure both drivers "
"to be the *Averaged Value* of a variable with the bone's Z location."
msgstr ""
"在 *Key 1* 和 *Key 2* 上添加驱动器。在“ *驱动器* ”选项卡中，类型选择“平均化值”，驱动器变量类型为”变"
"换通道“，物体为骨骼，类型Z位置。"

#: ../../manual/animation/drivers/workflow_examples.rst:273
msgid ""
"Determine the range of the bone's motion in the World Z axis by moving it up so that it is aligned "
"with the top of the mesh when both keys are active. Here we will use [0.0 , 2.5]."
msgstr ""
"向上移动骨骼来确定骨骼Z轴的运动范围，使其当两个Key都在激活状态时，与物体顶部对齐。这里我们使用"
"[0.0,0.25]。"

#: ../../manual/animation/drivers/workflow_examples.rst:275
msgid ""
"Configure the driver functions so that the *Value* of the shape keys (Y axis) is as desired for "
"the bone's height (X axis)."
msgstr "配置驱动器，形态键(Y轴)与骨骼期望的高度(X轴)对应。"

#: ../../manual/animation/drivers/workflow_examples.rst:278
msgid ""
"The driver functions should be linear, therefore, they can be defined analytically with a function "
"of type :math:`y = a + bx`, where :math:`a` is an offset in :math:`y` and :math:`b` is the slope."
msgstr ""
"驱动函数应该是线性的，因此，它们可以脚本表达式来定义 :math:`y = a + bx` ，其中 :math:`b` 是斜率， :"
"math:`` 是截距。"

#: ../../manual/animation/drivers/workflow_examples.rst:282
msgid "In the *Modifiers* tab, add a *Generator* of type *Extended Polynomial* for both drivers."
msgstr "在 *修改器* 选项卡中，为两个驱动器添加 *生成器* 修改器。"

#: ../../manual/animation/drivers/workflow_examples.rst:283
msgid ""
"Play with the values of :math:`a` and :math:`b` so that the curves go from [0.0 , 1.0] in the Y "
"axis and from [0.0 , 2.5] in the X axis. The curves should overlap in the mid area of the X axis "
"and they should have the same slope (:math:`b`)."
msgstr ""
"设置 :math:`a` 和 :math:`b` 的值，因为Key 2 X轴范围为[1.0,2.5],Y轴范围为[0.0,1.0]，因此Key 2 的曲线"
"经过(1.0，0.0)和(2.5，1.0)两点；Key 1 经过(0.0，0.0)，斜率与Key 2相同。"

#: ../../manual/animation/drivers/workflow_examples.rst:287
msgid "Possible values are *Key 1*: :math:`y = 0.0 + 0.6x` and *Key 2*: :math:`y = -0.5 + 0.6x`."
msgstr "得出公式  *Key 1* ：: :math:`y = 0.0 + 0.6x` 和 *Key 2*: :math:`y = -0.5 + 0.6x` 。"

#: ../../manual/animation/drivers/workflow_examples.rst:292
msgid ""
"Note that the functions go outside the range [0.0 , 1.0] for the shape keys' *Value*, but that has "
"no effect because *Value* is clamped in a *Range* in the *Shape Keys* panel."
msgstr ""
"请注意，对于形态键的 *值* ，如果超出[0.0,1.0]，不会产生多余的效果，因为 *值* 已经被限制在”形态键“ *"
"面板* 的范围中。"

#~ msgid "Shape Key Driver. Click to enlarge."
#~ msgstr "形态键驱动器。单击放大。"

#~ msgid "These are some driver examples and workflow."
#~ msgstr "这里有几个驱动器范例和工作流程。"

#~ msgid "Workflow"
#~ msgstr "工作流程"

#~ msgid ""
#~ "This example shows you how setup a transform driver. First make sure you are in the Front Ortho "
#~ "view. :kbd:`Numpad5`, :kbd:`Numpad1`."
#~ msgstr ""
#~ "这个例子展示了如何建立一个变换驱动器。首先确保你用的是正交前视图。 :kbd:`Numpad5`, :kbd:"
#~ "`Numpad1`."

#~ msgid ""
#~ "In object mode, select then duplicate the default Cube. :kbd:`Shift-D`. Move \"Cube.001\" to a "
#~ "new location."
#~ msgstr "在物体模式，选择并复制默认立方体。 :kbd:`Shift-D` ，将 \"Cube.001\" 移到一边。"

#~ msgid "With \"Cube.001\" selected, add a single driver to the *Rotation Y* property."
#~ msgstr "选中 \"Cube.001\" ，对 *旋转 Y* 属性添加单个驱动器。"

#~ msgid "Open the *Graph Editor*, set the Mode to *Drivers*."
#~ msgstr "打开 *曲线编辑器* ，设置模式为 *驱动器*。"

#~ msgid "*Show Only Selected* is useful disabled for drivers, marked green in the picture."
#~ msgstr "禁用图中绿框标记的 *仅显示选中* 按钮。"

#~ msgid ""
#~ "Change the *Type* to *Averaged Value*, this will return the averaged value of the driver "
#~ "variables."
#~ msgstr "修改 *类型* 为 *平均化值* ，这将返回所有驱动器变量的平均值。"

#~ msgid "Modify the driver variable settings:"
#~ msgstr "修改驱动器变量设置："

#~ msgid "Type -- Transform Channel"
#~ msgstr "类型 -- 变换"

#~ msgid "Ob/Bone -- Cube"
#~ msgstr "物体 -- Cube"

#~ msgid "Transform Type -- X Location"
#~ msgstr "变换类型 -- X 位移"

#~ msgid "Transform Space -- World Space"
#~ msgstr "变换空间 -- 世界空间"

#~ msgid ""
#~ "When finished, \"Cube.001\" should rotate on the Y axis when moving \"Cube\" left to right."
#~ msgstr "结束之后，从左向右移动 \"Cube\"时，\"Cube.001\" 会绕Y轴旋转。"

#~ msgid "Driver Expression"
#~ msgstr "驱动器表达式"

#~ msgid "Here are some examples using the scripted expression Expr to set the Driver Value."
#~ msgstr "这里是一些使用脚本表达式设置驱动器值的范例。"

#~ msgid "Object rotation example."
#~ msgstr "物体旋转。"

#~ msgid "Orbit a Point"
#~ msgstr "环绕一个点"

#~ msgid "Here two drivers have been added to the Cube, X Location and Y Location."
#~ msgstr "这里对立方体的X位移和Y位移分别添加驱动器。"

#~ msgid "The scripted expressions are being used to set the object location."
#~ msgstr "使用脚本表达式设置物体位置。"

#~ msgid "X Location Expr"
#~ msgstr "X位移表达式"

#~ msgid ""
#~ "``(frame/8)`` : is the current frame of the animation, divided by 8 to slow the orbit down. "
#~ "``(sin( )*4)`` : This returns the sine of (frame/8), then multiplies by 4 for a bigger circle. "
#~ "``0 +`` : is used to control the X Location offset of the orbit."
#~ msgstr ""
#~ "``(frame/8)`` : 表示当前动画帧除以8，降低环绕速度。 ``(sin( )*4)`` : 返回 (frame/8)的正弦值，再"
#~ "乘以4，放大环绕半径。 ``0 +`` : 用于控制环绕时 X 位移偏移量。"

#~ msgid "Y Location Expr"
#~ msgstr "Y位移表达式"

#~ msgid "``0 + (cos(frame / 8) * 4)``"
#~ msgstr "``0 + (cos(frame / 8) * 4)``"

#~ msgid ""
#~ "``(frame / 8)`` : is the current frame of the animation, divided by 8 to slow the orbit down. "
#~ "``(cos( ) * 4)`` : This returns the cosine of (frame/8), then multiplies by 4 for a bigger "
#~ "circle. ``0 +`` : is used to control the Y Location offset of the orbit."
#~ msgstr ""
#~ "``(frame/8)`` : 表示当前动画帧除以8，降低环绕速度。 ``(cos( )*4)`` : 返回 (frame/8)的余弦值，再"
#~ "乘以4，放大环绕半径。 ``0 +`` : 用于控制环绕时 Y 位移偏移量。"

#~ msgid "``frame`` is the same as bpy.context.scene.frame_current."
#~ msgstr "``frame`` 与 bpy.context.scene.frame_current 等价。"

#~ msgid "Driver Namespace"
#~ msgstr "驱动器命名空间"

#~ msgid ""
#~ "There is a list of built-in driver functions and properties. These can be displayed via the "
#~ "Python Console:"
#~ msgstr "内置的驱动器函数和属性是一个列表。可以使用Python控制台显示出来:"

#~ msgid ""
#~ "This script will add a function to the driver namespace, which can then be used in the "
#~ "expression ``driver_func(frame)``"
#~ msgstr ""
#~ "下面的脚本用于添加一个函数到驱动器命名空间，接下来可以在表达式中使用 ``driver_func(frame)``"

#~ msgid "Examples"
#~ msgstr "范例"

#~ msgid "In the channels region, select the *Y Euler Rotation* property."
#~ msgstr "在通道区域，选择 *Y欧拉旋转* 属性。"

#~ msgid "This example is a shape key driver. The driver was added to the shape key Value."
#~ msgstr "这是一个形态键驱动器的范例，即对形态键数值添加驱动器。"

#~ msgid "Shape key driver example."
#~ msgstr "形态键驱动器。"

#~ msgid ""
#~ "This example uses the Armature Bone \"b\" 's Z Rotation to control the Value of a Shape Key. "
#~ "The bone rotation mode is set to XYZ Euler."
#~ msgstr "该例子使用骨架的骨骼 \"b\" 的Z旋转控制形态键数值。骨骼旋转模式设置为XYZ欧拉。"

#~ msgid "The Driver F-Curve is mapped like so:"
#~ msgstr "驱动器函数曲线映射如下："

#~ msgid "Bone Z Rotation 0.0 (0.0): Shape Key value 0.0"
#~ msgstr "骨骼Z旋转 0.0 (0.0): 形态键数值 0.0"

#~ msgid "Bone Z Rotation -2.09 (-120.0): Shape Key value 1.0"
#~ msgstr "骨骼Z旋转 -2.09 (-120.0): 形态键数值 1.0"

#~ msgid "This kind of driver can also be setup with the Variable Type Rotational Difference."
#~ msgstr "这种类型的驱动器还可以使用旋转差值变量类型设置。"

#~ msgid "See :doc:`Shape Keys </animation/shape_keys/index>` for more info."
#~ msgstr "更多信息参考 :doc:`形态键 </animation/shape_keys/index>` 。"

#~ msgid "Drivers and Multiple Relative Shape Keys"
#~ msgstr "驱动器和多重相关形态键"

#~ msgid ""
#~ "The following screenshots illustrate combining shape keys, bones, and drivers to make multiple "
#~ "chained relative shape keys sharing a single root. While it lacks the convenience of the single "
#~ "Evaluation Time of an absolute shape key, it allows you to have more complex relationships "
#~ "between your shape keys."
#~ msgstr ""
#~ "下面的屏幕截图展示了结合形态键，骨骼和驱动器，来制作共用基型的多重链状相关形态键。尽管这样没有使"
#~ "用绝对形态键的单一时间计算来的方便，但却可以做出更复杂的形态键关系。"

#~ msgid ""
#~ "The Basis shape key has the stacks fully retracted. Key1 has the base fully extended. Key2A has "
#~ "the left stack fully extended. Key2B has the right stack fully extended. Key2A and Key2B are "
#~ "both relative to Key1 (as you can see in the field in the bottom right of the Shape Keys panel)."
#~ msgstr ""
#~ "作为基型的形态键的挤出面完全缩回，Key1的基底完全挤出，Key2A挤出左侧凸起，Key2B挤出右侧凸起。"
#~ "Key2A和2B都和Key1相关(如右下角的形态键面板所见)。"

#~ msgid "Basis shape key."
#~ msgstr "Basis 形态键。"

#~ msgid "Key1 shape key."
#~ msgstr "Key1 形态键。"

#~ msgid "Key2A shape key."
#~ msgstr "Key2A 形态键。"

#~ msgid "Key2B shape key."
#~ msgstr "Key2B 形态键。"

#~ msgid "Key1 must handle conflicting values from the two bones."
#~ msgstr "Key1需要处理来自两个骨骼的数值冲突。"

#~ msgid ""
#~ "Key2A has different generator coefficients so it is activated in a different range of the "
#~ "bone's position."
#~ msgstr "Key2A有不同的生成器系数，所以会在骨骼的另外一段位置范围内才被激活。"

#~ msgid "Key2B is the same as Key2A, but is controlled by the second bone."
#~ msgstr "Key2B和Key2A类似，但是被第二根骨骼控制。"

#~ msgid ""
#~ "The *Value* of *Key1* is bound to the position of two different bones by a driver with two "
#~ "variables. Each variable uses the world Z coordinate of a bone and uses the maximum value to "
#~ "determine how much the base should be extended. The generator polynomial is crafted such that "
#~ "the top of the dominant stack should line up with the bone for that stack."
#~ msgstr ""
#~ "Key1的值通过一个包含两个变量的驱动器，与两个骨骼的位置属性绑定。每一个变量使用的都是骨骼的全局Z"
#~ "坐标，然后取最大值决定基底的挤出量。多项式生成器用于使基底的上表面与骨骼对齐。"

#~ msgid ""
#~ "The *Value* of *Key2A* is bound to the position of \"Bone.L\". Its generator parameters are "
#~ "crafted such that when *Key1*'s *Value* reaches 1, the *Value* of *Key2A* starts increasing "
#~ "beyond zero. In this way, the top of the left stack will move with bone.L (mostly)."
#~ msgstr ""
#~ "Key2A的值与 ``Bone.L`` 的位置绑定。生成器的参数使得当Key1的值增加到1时，Key2A 才开始从0增长。这"
#~ "样的话，左侧凸起顶部会与 bone.L 一起移动(基本上)。"

#~ msgid ""
#~ "The *Value* of *Key2B* is bound to the position of \"Bone.R\". Its generator parameters are "
#~ "similar to *Key2A* so that the top of the right stack will move with bone.R (mostly)."
#~ msgstr ""
#~ "Key2B的值与 ``Bone.R`` 的位置绑定。它的生成参数和Key2A类似，右边的凸起会随着bone.R一起移动(基本"
#~ "上)。"

#~ msgid "When both bones are low, Key2B and Key2A are deactivated and Key1 is at low influence."
#~ msgstr "当骨骼所有骨骼调低时，Key2B 和 Key2A 不被激活，Key1处于低影响。"

#~ msgid ""
#~ "Since it is quite easy for bone.L and bone.R to be in positions that indicate conflicting "
#~ "values for *Key1* there will be times when the bones do not line up with the tops of their "
#~ "respective stacks. If the driver for *Key1* was to use Average or Minimum instead of Maximum to "
#~ "determine the value of the shape key then \"conflicts\" between bone.L and bone.R would be "
#~ "resolved differently. You will choose according to the needs of your animation."
#~ msgstr ""
#~ "由于bone.L 和 bone.R很容易出现位置差异，这意味着Key1的值会导致冲突，有时骨骼无法与对应的凸起对"
#~ "齐。如果Key1的驱动器使用平均值或最小值，而非最大值，来确定形变键的值， bone.L 和 bone.R 的“冲"
#~ "突”则会断然不同。用户可以视动画需求进行选择。"
