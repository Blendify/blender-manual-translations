# SOME DESCRIPTIVE TITLE.
# Copyright (C) : This page is public domain as CC0
# This file is distributed under the same license as the Blender Reference
# Manual package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
msgid ""
msgstr ""
"Project-Id-Version: Blender Reference Manual 2.76\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-07-05 13:47-0400\n"
"PO-Revision-Date: 2018-04-25 22:28+0800\n"
"Last-Translator: \n"
"Language: zh\n"
"Language-Team: \n"
"Plural-Forms: nplurals=1; plural=0\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../manual/compositing/types/converter/math.rst:11
msgid "Math Node"
msgstr "运算节点"

#: ../../manual/compositing/types/converter/math.rst:16
msgid "Math node."
msgstr "运算节点。"

#: ../../manual/compositing/types/converter/math.rst:18
msgid "The *Math Node* performs math operations."
msgstr "*运算节点* 的功能是执行数学运算。"

#: ../../manual/compositing/types/converter/math.rst:22
msgid "Inputs"
msgstr "输入"

#: ../../manual/compositing/types/converter/math.rst:25
#: ../../manual/compositing/types/converter/math.rst:31
#: ../../manual/compositing/types/converter/math.rst:48
msgid "Value"
msgstr "值"

#: ../../manual/compositing/types/converter/math.rst:25
msgid ""
"First numerical value. The trigonometric functions accept values in "
"radians."
msgstr "第一个数值。可以输入三角法则定义的弧度数值。"

#: ../../manual/compositing/types/converter/math.rst:28
msgid ""
"Second numerical value. This value is **not** used in functions that "
"accept only one parameter like the trigonometric functions, Round and "
"Absolute."
msgstr "第二个数值。这个数值不仅可输入三角函数值，还可以输入四舍五入及绝对值。"

#: ../../manual/compositing/types/converter/math.rst:34
msgid "Properties"
msgstr "属性"

#: ../../manual/compositing/types/converter/math.rst:37
msgid "Operation"
msgstr "操作"

#: ../../manual/compositing/types/converter/math.rst:37
msgid ""
"Add, Subtract, Multiply, Divide, Sine, Cosine, Tangent, Arcsine, "
"Arccosine, Arctangent, Power, Logarithm, Minimum, Maximum, Round, Less "
"Than, Greater Than, Modulo, Absolute."
msgstr "添加，相减，相乘（软件界面翻译成正片叠底，这个是在图层模式才有的说法），相除，正弦，反正弦，反余弦，乘幂运算，对数运算，最小值，最大值，四舍五入，小于，大于，模数，绝对值。"

#: ../../manual/compositing/types/converter/math.rst:41
msgid "Clamp"
msgstr "限定"

#: ../../manual/compositing/types/converter/math.rst:40
msgid "Limits the output to the range (0 to 1). See :term:`clamp`."
msgstr "限定输出数值的范围（0到1）。参看  :term:`clamp`。"

#: ../../manual/compositing/types/converter/math.rst:44
msgid "Outputs"
msgstr "输出"

#: ../../manual/compositing/types/converter/math.rst:47
msgid "Numerical value output."
msgstr "数值输出。"

#: ../../manual/compositing/types/converter/math.rst:51
msgid "Examples"
msgstr "范例"

#: ../../manual/compositing/types/converter/math.rst:54
msgid "Manual Z-Mask"
msgstr "自定义Z深度通道节点设置"

#: ../../manual/compositing/types/converter/math.rst:58
msgid "Minimum and maximum function example."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:60
#, fuzzy
msgid ""
"This example has one scene input by the top *Render Layers* node, which "
"has a cube that is about 10 BU from the camera. The bottom *Render "
"Layers* node inputs a scene with a plane that covers the left half of the"
" view and is 7 BU from the camera. Both are fed through their respective "
"*Map Value* nodes to divide the Z-buffer by 20 (multiply by 0.05, as "
"shown in the Size field) and clamped to be a min/max of 0.0/1.0 "
"respectively."
msgstr ""
"此范例场景输入数据由 *渲染层* "
"节点提供，距离摄影机10BU左右有个矩形物体。在另一个渲染层节点底部的输入连接端口上连有一个覆盖视图左半部距离摄影机7BU单位的平面。两个渲染层节点通过映射值节点分离Z缓冲区（Z深度）为20（乘以0.5，输入框如图所示）并且最小值/最大值的范围限分别限定在"
" 0.0/1.0。"

#: ../../manual/compositing/types/converter/math.rst:68
#, fuzzy
msgid ""
"For the minimum function, the node selects those Z values where the "
"corresponding pixel is closer to the camera; so it chooses the Z values "
"for the plane and part of the cube. The background has an infinite Z "
"value, so it is clamped to 1.0 (shown as white). In the maximum example, "
"the Z values of the cube are greater than the plane, so they are chosen "
"for the left side, but the plane *Render Layers* Z are infinite (mapped "
"to 1.0) for the right side, so they are chosen."
msgstr "“使用最小值”功能是依据靠近摄影机的像素将Z深度值选择出来；也可以选择矩形部分的平面Z深度值。背景有个初始的Z深度值，值限定为1.0（显示为白色）。在“使用最大值”范例中，矩形的Z深度值比图像平面要大，因此更靠近左侧，但是图像平面(FlyCam)渲染层Z值初始在右侧（对应于1.0），因此他们被选择。"

#: ../../manual/compositing/types/converter/math.rst:78
msgid "Using Sine Function to Pulsate"
msgstr "使用正弦功能得到不断循环的变化数"

#: ../../manual/compositing/types/converter/math.rst:82
#, fuzzy
msgid "Using sine function example."
msgstr "使用正弦功能得到不断循环的变化数"

#: ../../manual/compositing/types/converter/math.rst:84
msgid ""
"This example has a *Time* node putting out a linear sequence from 0 to 1 "
"over the course of 101 frames. At frame 25, the output value is 0.25. "
"That value is multiplied by 2 × pi (6.28) and converted to 1.0 by the "
"Sine function, since we all know that :math:`sin(2 × pi/ 4) = sin(pi/ 2) "
"= +1.0`."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:89
msgid ""
"Since the sine function can put out values between (-1.0 to 1.0), the "
"*Map Value* node scales that to 0.0 to 1.0 by taking the input (-1 to 1),"
" adding 1 (making 0 to 2), and multiplying the result by one-half (thus "
"scaling the output between 0 to 1). The default *Color Ramp* converts "
"those values to a gray-scale. Thus, medium gray corresponds to a 0.0 "
"output by the sine, black to -1.0, and white to 1.0. As you can see, "
":math:`sin(pi/ 2) = 1.0`. Like having your own visual color calculator! "
"Animating this node setup provides a smooth cyclic sequence through the "
"range of grays."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:97
msgid ""
"Use this function to vary, for example, the alpha channel of an image to "
"produce a fading in/out effect. Alter the Z channel to move a scene "
"in/out of focus. Alter a color channel value to make a color \"pulse\"."
msgstr "将这个功能引申,比如，图片的alpha通道形成渐入/渐出特效。改变Z深度通道的景深位置。改变颜色通道值使其有规律的进行色彩变化。"

#: ../../manual/compositing/types/converter/math.rst:104
#, fuzzy
msgid "Brightening (Scaling) a Channel"
msgstr "提亮/缩放通道"

#: ../../manual/compositing/types/converter/math.rst:108
msgid "Scaling a channel example."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:110
#, fuzzy
msgid ""
"This example has a *Math (Multiply)* node increasing the luminance "
"channel (Y) of the image to make it brighter. Note that you should use a "
"*Map Value node* with min() and max() enabled to clamp the output to "
"valid values. With this approach, you could use a logarithmic function to"
" make a high dynamic range image. For this particular example, there is "
"also a *Bright/Contrast node* that might give simpler control over "
"brightness."
msgstr ""
"范例中有一个 *运算: 相乘* 节点增加图像的亮度通道（Y）使其颜色变得更亮。使用 *映射值* 节点的 “使用最小值” 和 "
"“使用最大值”复选框来限定颜色的输出值在合理的区间范围之内。用这个方法，用户可以在高动态范围图像（HDRI）上应用对数函数。在这个特定范例中，使用一个"
" *亮度/对比度 节点* 对亮度进行简单控制。"

#: ../../manual/compositing/types/converter/math.rst:119
msgid "Restrict Color Selection (Posterization)"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:123
msgid "Posterization example."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:125
msgid ""
"In this example, we restrict the color values to be one of the six "
"values: 0, 0.2, 0.4, 0.6, 0.8, 1."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:127
msgid ""
"To split up a continuous range of values between 0 and 1 to certain set "
"of values, the following function is used: :math:`round(x × n - 0.5) / (n"
" - 1)`, where \"n\" is the number of possible output values, and \"x\" is"
" the input pixel color. `Read more about this function "
"<https://en.blender.org/index.php/Doc:2.4/Manual/Composite_Nodes/Types/Convertor#Quantize.2FRestrict_Color_Selection>`__."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:133
msgid ""
"To implement this function in Blender, consider the node setup above. We "
"string the math nodes into a function that takes each color (values from "
"0 to 1), multiplies it up by six, the desired number of divisions (values"
" becomes from 0 to 6), offsets it by 0.5 (-0.5 to 5.5), rounds the value "
"to the nearest whole number (produces 0, 1, 2, 3, 4, 5), and then divides"
" the image pixel color by five (0.0, 0.2, 0.4, 0.6, 0.8, 1.0)."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:140
msgid ""
"In the case of a color image, you need split it into separate RGB "
"channels using *Separate/Combine RGBA* nodes and perform this operation "
"on each channel independently."
msgstr ""

#~ msgid "Example."
#~ msgstr "范例。"

#~ msgid ""
#~ "This example has a *Time* node "
#~ "putting out a linear sequence from "
#~ "0 to 1 over the course of "
#~ "101 frames. The green vertical line "
#~ "in the curve widget shows that "
#~ "frame 25 is being put out, or "
#~ "a value of 0.25. That value is "
#~ "multiplied by 2 × pi and converted"
#~ " to 1.0 by the Sine function, "
#~ "since we all know that :math:`sin(2 "
#~ "× pi/ 4) = sin(pi/ 2) = "
#~ "+1.0`. Since the sine function can "
#~ "put out values between (-1.0 to "
#~ "1.0), the *Map Value* node scales "
#~ "that to 0.0 to 1.0 by taking "
#~ "the input (-1 to 1), adding 1 "
#~ "(making 0 to 2), and multiplying "
#~ "the result by one-half (thus "
#~ "scaling the output between 0 to "
#~ "1). The default *Color Ramp* converts"
#~ " those values to a gray-scale. "
#~ "Thus, medium gray corresponds to a "
#~ "0.0 output by the sine, black to"
#~ " -1.0, and white to 1.0. As you"
#~ " can see, :math:`sin(pi/ 2) = 1.0`."
#~ " Like having your own visual color"
#~ " calculator! Animating this node setup "
#~ "provides a smooth cyclic sequence "
#~ "through the range of grays."
#~ msgstr ""
#~ "在这个例子中，*时间* "
#~ "节点，在101帧范围内生成一个从0到1的线性序列。垂直方向上的绿色曲线控件显示第25帧输出，或者说值为0.25的结果被输出。这个值被正弦节点进行"
#~ " 2 × pi运算转化为正弦范围内的1.0，如我们所熟知的：`sin(2 × pi/"
#~ " 4) = sin(pi/ 2) = +1.0` "
#~ "。因为结果值在（-1.0到1.0）之间，*映射值* "
#~ "节点通过将输入（-1，1）限定在0.0到1.0区间内，再加上1（使其数值在0到2f范围内），将所得结果乘以二分之一（因此缩放值在0到1之间）。默认"
#~ "  *颜色渐变* 节点将这些数值映射到一个灰度值区间内。 "
#~ "引测，中度灰色和0.0值相匹配，黑色为-1.0，白色为1.0。我们可以看到， :math:`sin(pi/ 2)"
#~ " = 1.0`。就像是有了用户自己的可见光颜色计算器一样！这个节点装配通过灰度范围提供了一个平滑周期性的序列值。"

#~ msgid "Quantize/Restrict Color Selection"
#~ msgstr "量子化/重限定颜色选取"

#~ msgid ""
#~ "In this example, we want to "
#~ "restrict the color output to only "
#~ "256 possible values. Possible use of "
#~ "this is to see what the image "
#~ "will look like on an 8-bit cell"
#~ " phone display. To do this, we "
#~ "want to restrict the R, G and "
#~ "B values of any pixel to be "
#~ "one of a certain value, such that"
#~ " when they are combined, will not "
#~ "result in more than 256 possible "
#~ "values. The number of possible values"
#~ " of an output is the number of"
#~ " channel values multiplied by each "
#~ "other, or Q = R × G × "
#~ "B."
#~ msgstr ""
#~ "在这个例子中，我们要重新限定颜色输出值为256色。运用这种设置使显示看起来就像是图像在手机中显示的效果。想实现这个效果，我们要重新将像素的R,G,B值限定在一个范围中，不如当三个光学三原色混合时，颜色结果值不会超过256种变化。颜色输出值的变化范围是三个通道值彼此相乘，Q"
#~ " = R × G × B。"

#~ msgid ""
#~ "Since there are three channels and "
#~ "256 values, we have some flexibility "
#~ "how to quantize each channel, since "
#~ "there are a lot of combinations of"
#~ " R × G × B that would "
#~ "equal 256. For example, if {R, G,"
#~ " B} = {4, 4, 16}, then :math:`4"
#~ " × 4 × 16 = 256`. Also, "
#~ "{6, 6, 7} would give 252 possible"
#~ " values. The difference in appearance "
#~ "between {4, 4, 16} and {6, 6, "
#~ "7} is that the first set {4, "
#~ "4, 16} would have fewer shades of"
#~ " red and green, but lots of "
#~ "shades of blue. The set {6, 6, "
#~ "7} would have a more even "
#~ "distribution of colors. To get better"
#~ " image quality with fewer color "
#~ "values, give possible values to the "
#~ "predominant colors in the image."
#~ msgstr ""
#~ "现在有三个颜色通道256个颜色值，我们可以灵活的量化每个颜色通道的取值，因为有很多种 R × G "
#~ "× B的数学组合结果是256。比如，{R, G, B} = {4, "
#~ "4, 16}, 然后 :math:`4 × 4 × 16"
#~ " = 256`。同理， {6, 6, 7} 给出的结果是252。在{4,"
#~ " 4, 16}和{6, 6, 7}颜色结果的差异是，将其首先设置为(4, 4, "
#~ "16}产生一个带有少量红和绿，大量蓝的颜色结果。设置为{6, 6, "
#~ "7}将产生一个个颜色通道平均分布的颜色结果。为了用较少的颜色值取得比较好的图像效果，图像中的颜色取值尽量以主要颜色为主。"

#~ msgid "Theory"
#~ msgstr "理论"

#~ msgid ""
#~ "`Two Approaches to Quantizing to six "
#~ "values <https://wiki.blender.org/index.php/File:Manual-"
#~ "Compositing-Node-Math_ColorBand>`__."
#~ msgstr ""
#~ "量化留个值的两种方法 <https://wiki.blender.org/index.php/File:Manual-"
#~ "Compositing-Node-Math_ColorBand>`__。"

#~ msgid ""
#~ "To accomplish this quantization of an"
#~ " image to 256 possible values, let"
#~ " us use the set {6, 6, 7}. "
#~ "To split up a continuous range of"
#~ " values between 0 and 1 (the "
#~ "full Red spectrum) into six values, "
#~ "we need to construct an algorithm "
#~ "or function that takes any input "
#~ "value but only puts out six "
#~ "possible values, as illustrated by the"
#~ " image to the right. We want to"
#~ " include zero as true black, with "
#~ "five other colors in between. The "
#~ "approach shown produces {0, 0.2, 0.4,"
#~ " 0.6, 0.8, 1}. Dividing 1.0 by "
#~ "5 equals 0.2, which tells how far"
#~ " apart each quantified value is from"
#~ " the other."
#~ msgstr ""
#~ "将图像量化到256色，设置三通道颜色值为{6, 6, "
#~ "7}。切分出一块范围在0到1之间的连续范围（红色光谱）到六个值，我们需要构建当输入任何一个数值可以输出为六个数值的运算法则，就像如图所示的那样。将0值和黑色颜色值匹配，其他五个颜色在中间。如显示那样，这个方法产生{0,"
#~ " 0.2, 0.4, 0.6, 0.8, "
#~ "1}。1.0被5除得到的结果是0.2，这个表明了量化值彼此之间的颜色差距离。"

#~ msgid ""
#~ "So, to get good even shading, we"
#~ " want to take values that are "
#~ "0.16 or less and map them to "
#~ "0.0; values between 0.16 and 0.33 "
#~ "get fixed to 0.2; color values "
#~ "between 0.33 and 0.5 get quantized "
#~ "to 0.4, and so on up to "
#~ "values between 0.83 and 1.0 get "
#~ "mapped to 1.0."
#~ msgstr "为得到平滑的颜色过渡，我们要将低于0.16的数值映射为0.0；在0.16和0.33之间的数值映射为0.2；在0.33和0.5之间的数值量化为0.4，在0.83和1.0之间的数值映射为1.0。"

#~ msgid "Function f(x)"
#~ msgstr "函数 f(x)"

#~ msgid ""
#~ "An algebraic function is made up "
#~ "of primitive mathematical operations (add, "
#~ "subtract, multiply, sine, cosine, etc.) "
#~ "that operate on an input value to"
#~ " provide the desired output value."
#~ msgstr "此函数的数学功能由基本的数学操作（加，减，乘，正弦，余弦等等）对输入值进行运算，输出所需要的输出值。"

#~ msgid ""
#~ "`Spreadsheet showing a function "
#~ "<https://wiki.blender.org/index.php/File:Manual-Compositing-"
#~ "Node-Math_spreadsheet>`__."
#~ msgstr ""
#~ "`电子表格表述此函数功能 <https://wiki.blender.org/index.php/File:Manual-"
#~ "Compositing-Node-Math_spreadsheet>`__。"

#~ msgid ""
#~ "The theory behind this function is "
#~ "scaled truncation. Suppose we want a "
#~ "math function that takes in a "
#~ "range of values between 0 and 1,"
#~ " such as 0.552, but only outputs "
#~ "a value of 0.0, 0.2, 0.4, etc. "
#~ "We can imagine then that we need"
#~ " to get that range 0 to 1 "
#~ "powered up to something 0 to 6 "
#~ "so that we can chop off and "
#~ "make it a whole number. So, with"
#~ " six divisions, how can we do "
#~ "that? The answer is we multiply "
#~ "the range by 6. The output of "
#~ "that first math Multiply Node is a"
#~ " range of values between 0 and "
#~ "6. To get even divisions, because "
#~ "we are using the rounding function "
#~ "(see documentation above), we want any"
#~ " number plus or minus around a "
#~ "whole number will get rounded to "
#~ "that number. So, we subtract a "
#~ "half, which shifts everything over. The"
#~ " round() function then makes that "
#~ "range 0 to 5. We then divide "
#~ "by 5 to get back a range of"
#~ " numbers between 0 and 1 which "
#~ "can then be combined back with the"
#~ " other color channels. Thus, you get"
#~ " the function :math:`f(x, n) = "
#~ "round(x × n - 0.5)/ (n - 1)`"
#~ " where \"n\" is the number of "
#~ "possible output values, and \"x\" is "
#~ "the input pixel color and :math:`f(x,"
#~ " n)` is the output value. There "
#~ "is only one slight problem, and "
#~ "that is for the value exactly "
#~ "equal to 1, the formula result is"
#~ " 1.2, which is an invalid value. "
#~ "This is because the round function "
#~ "is actually a roundup function, and "
#~ "exactly 5.5 is rounded up to 6."
#~ " So, by subtracting 0.501, we "
#~ "compensate and thus 5. 499 is "
#~ "rounded to 5. At the other end "
#~ "of the spectrum, pure black, or 0,"
#~ " when 0.501 subtracted, rounds up to"
#~ " 0 since the Round() function does"
#~ " not return a negative number."
#~ msgstr ""
#~ "此函数背后的理论是按比例截取数值。比如我们需要一个将数值限定在0到1这个范围的数学函数，比如0.552，但是输出值为，0.2，0.4等等。我们可以想象到我们将0到1范围之间的数进行乘方，比如从0此方到6次方，以便于将结果化为整数。因此将数值进行六次分离，我们要怎样操作呢？答案是对一个数值范围乘以6.运算节点的第一个数值是在0到6的范围内。为了得到平滑均等的分离效果，使用四舍五入功能（参看前文），我们可以将任何数值进行加减将整个数值四舍五入到那个数值。因此，我们将数值减去一半，整个操作就结束了。round()函数功能使数值范围限定在0到5之间。然后将数值除以5得到在0和1之间的取值范围，然后再将结果和其他颜色通道进行合并。因此我们得到的函数是"
#~ " :math:`f(x, n) = round(x × n -"
#~ " 0.5)/ (n - 1)`，“n”代表可能的输出值，“x”代表输入的像素颜色值，函数 "
#~ ":math:`f(x, n)` "
#~ "是输出值。有个小问题，那就是数值等于1的时候，公式结果为1.2，这是个非法值。这是因为四舍五入函数是向上取整，5.5将取整为6。因此，当将此数值减去0.501时，将结果5.499向上取整为5.在其他光谱范围内，是纯黑色，或者数值表示为0，当0.501被减去时，向上取整为0，因为四舍五入函数Round()功能不会返回一个负数结果值。"

#~ msgid ""
#~ "Sometimes using a spreadsheet can help"
#~ " you figure out how to put "
#~ "these nodes together to get the "
#~ "result that you want. Stepping you "
#~ "through the formula for :math:`n = "
#~ "6` and :math:`x = 0.70`, locate "
#~ "the line on the spreadsheet that "
#~ "has the 8-bit value 179 and R "
#~ "value 0.7. Multiplying by 6 gives "
#~ "4.2. Subtracting 1/2 gives 3.7, which"
#~ " rounds up to 4.4 divided by 5"
#~ " = 0.8. Thus, f(0.7, 6) = 0.8"
#~ " or an 8-bit value of 204. You"
#~ " can see that this same 8-bit "
#~ "value is output for a range of "
#~ "input values."
#~ msgstr ""
#~ "有时候通过电子表格可以帮助用户这些节点放在一起计算出想要的结果值。通过公式 :math:`n = 6`"
#~ " 和 :math:`x = 0.70`，定位到电子表格相应位置，得到8-bit "
#~ "颜色值179和R值0.7。乘以6得到结果为4.2。减去1/2得到结果为3.7，向上取整为4。将4除以5得到结果为0.8。因此， "
#~ "f(0.7, 6) = 0.8 "
#~ "或一个8-bit数值204。可以将一个范围的颜色输入值输出为同一个 8-bit输出值。"

#~ msgid "Reality"
#~ msgstr "实际应用"

#~ msgid ""
#~ "To implement this function in Blender,"
#~ " consider the node setup above. "
#~ "First, feed the image to the "
#~ "Separate RGB node. For the Red "
#~ "channel, we string the math nodes "
#~ "into a function that takes each "
#~ "red color, multiplies (scales) it up "
#~ "by the desired number of divisions "
#~ "(6), offsets it by 0.5, rounds the"
#~ " value to the nearest whole number,"
#~ " and then divides the image pixel "
#~ "color by 5. So, the transformation "
#~ "is {0 to 1} becomes {0 to "
#~ "6}, subtracting centers the medians to"
#~ " {-0.5 to 5.5} and the rounding "
#~ "to the nearest whole number produces "
#~ "{0, 1, 2, 3, 4, 5} since the"
#~ " function rounds down, and then "
#~ "dividing by five results in six "
#~ "values {0.0, 0.2, 0.4, 0.6, 0.8, "
#~ "1.0}."
#~ msgstr ""
#~ "考虑到上述节点设置在Blender的实际应用，将图像的连入分离RGB节点。比如红色通道，我们将运算节点连入获取每个红色的数值，乘以（比例缩放）其数值为六个单独部分，偏移0.5个数值，四舍五入到最近的整数值，然后将图像颜色像素除以5。将变化范围由{0"
#~ " to 1} 改为 {0 to "
#~ "6}，减去中间的数值，数值范围变化为{-0.5 to 5.5}四舍五入到最近的整数，结果为{0, 1,"
#~ " 2, 3, 4, 5}，因为函数向下取整，被5除后的六个数值分别为{0.0, "
#~ "0.2, 0.4, 0.6, 0.8, 1.0}。"

#~ msgid ""
#~ "The result is that the output "
#~ "value can only be one of a "
#~ "certain set of values, stair-stepped,"
#~ " because of the rounding function of"
#~ " the math node. Copying this one "
#~ "channel to operate on Green and "
#~ "Blue gives the node setup below. "
#~ "To get the 6:6:7, we set the "
#~ "three Multiply Nodes to {6, 6, 7}"
#~ " and the divide nodes to {5, 5,"
#~ " 6}."
#~ msgstr ""
#~ "因为运算节点的四舍五入功能的缘故，输出值是固定范围中阶梯性的结果值。拷贝这个节点装配到绿色和蓝色通道。得到 "
#~ "6:6:7，我们设置三个进行相乘操作的运算节点为 {6, 6, 7}，相除运算的节点设置为 "
#~ "{5, 5, 6}。"

#~ msgid ""
#~ "If you make this into a node "
#~ "group, you can easily reuse this "
#~ "setup from project to project. When "
#~ "you do, consider using a math node"
#~ " to drive the different values that"
#~ " you would have to otherwise set "
#~ "manually, just to error-proof your "
#~ "work."
#~ msgstr "如果将此节点装配放入一个群组节点之中，可以在不同的项目之间简单的重复使用这个功能。在操作中，考虑到一个运算节点要驱动不同的数值，其他的一些要手动设置，以避免出现误差。"

#~ msgid "Summary"
#~ msgstr "总结"

#~ msgid ""
#~ "Normally, an output render consists of"
#~ " 32- or 24-bit color depth, and "
#~ "each pixel can be one of the "
#~ "millions of possible colors. This node"
#~ " setup example takes each of the "
#~ "Red, Green and Blue channels and "
#~ "normalizes them to one of a few"
#~ " values. When all three channels are"
#~ " combined back together, each color "
#~ "can only be one of 256 possible"
#~ " values."
#~ msgstr "正常情况下，一个输出渲染值由32位或24位颜色位深，每个像素的颜色值取值在数百万色之中的某个值。这个节点装配范例将红，绿，蓝三个颜色通道的取值统一到一个很小的颜色区间内，当三个颜色通道的数值混合在一起，每种颜色只有256种颜色其中之一。"

#~ msgid ""
#~ "While this example uses the "
#~ "Separate/Combine RGB to create distinct "
#~ "colors, other Separate/Combine nodes can "
#~ "be used as well. If using the "
#~ "YUV values, remember that U and V"
#~ " vary between (-0.5 to +0.5), so "
#~ "you will have to first add on "
#~ "a half to bring the range between"
#~ " 0 and 1, and then after "
#~ "dividing, subtract a half to bring "
#~ "in back into standard range."
#~ msgstr ""
#~ "当这个节点装配使用 分离/合并 RGB节点创建一种具体的颜色。其他的 分离/合并 "
#~ "节点依然可以继续使用。使用YUV（一种颜色编码方法）值，记住U值和V值的变化范围在（-0.5，0.5），因此用户可以首先加上1/2使其区间范围在0和1之间，然后进行除法运算，减去1/2,使其颜色在标准范围区间内。"

#~ msgid ""
#~ "The ``JPG`` or ``PNG`` image format "
#~ "will store each of the colors "
#~ "according to its image standard for "
#~ "color depth (e.g. ``JPG`` is 24-bit),"
#~ " but the image will be very "
#~ "small since reducing color depth and "
#~ "quantizing colors are essentially what "
#~ "the ``JPEG`` compression algorithm "
#~ "accomplishes."
#~ msgstr ""
#~ "``JPG`` 或 ``PNG`` 图像格式依据颜色位深(比如： ``JPG`` "
#~ "是 24位颜色位深)存储每个颜色值，但是生成图像体积非常小的原因是依据 ``JPEG`` "
#~ "压缩算法减少颜色位深和量化颜色范围。"

#~ msgid ""
#~ "You do not have to reduce the "
#~ "color depth of each channel evenly. "
#~ "For example, if blue was the "
#~ "dominant color in an image, to "
#~ "preserve image quality, you could reduce"
#~ " Red to 2 values, Green to 4,"
#~ " and let the blue take on "
#~ ":math:`256/(2 × 4)` or 32 values. "
#~ "If using the HSV, you could reduce"
#~ " the Saturation and Value to 2 "
#~ "values (0 or 1.0) by Multiply by"
#~ " 2 and Divide by 2, and "
#~ "restrict the Hue to 64 possible "
#~ "values."
#~ msgstr ""
#~ "用户需要均匀的较少颜色的位深，比如，在一幅蓝色为主色调的图片上，保持图像的品质，需要减少红色通道值2个单位，绿色通道值4个单位，让蓝色颜色值为"
#~ " :math:`256/(2 × 4)` 或 "
#~ "值为32。如果使用HSV（一种颜色空间）色彩空间，用户需要通过乘以2和除以2分别减少饱和度和亮度2个单位（0或1.0），将颜色的色相值重新限定为64。"

#~ msgid ""
#~ "You can use this node setup to "
#~ "quantize any channel; alpha, speed "
#~ "(vector), Z values, and so forth."
#~ msgstr "用户可以使用此节点装配量化任何通道：alpha,速度（矢量），z深度值等等。"

