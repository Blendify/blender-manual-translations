#
msgid ""
msgstr ""
"Project-Id-Version: Blender Reference Manual 2.76\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-11-20 13:32+1100\n"
"PO-Revision-Date: 1971-01-02 00:00-0000\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../../manual/game_engine/physics/types/dynamic.rst:4
msgid "Dynamic Physics"
msgstr ""

#: ../../manual/game_engine/physics/types/dynamic.rst:6
msgid ""
"*Dynamic* objects give or receive collisions, but when they do so they "
"themselves do not rotate in response. So, a Dynamic ball will hit a ramp "
"and slide down, while a Rigid Body ball would begin rotating."
msgstr ""

#: ../../manual/game_engine/physics/types/dynamic.rst:10
msgid ""
"If you do not need the rotational response the Dynamic type can save the "
"extra computation."
msgstr ""

#: ../../manual/game_engine/physics/types/dynamic.rst:12
msgid ""
"Note that these objects can still be rotated with :doc:`Logic Bricks "
"</game_engine/logic/index>` or Python code. Their physics meshes will "
"update when you do these rotations -- so collisions will be based on the "
"new orientations."
msgstr ""

#: ../../manual/game_engine/physics/types/dynamic.rst:15
msgid ""
"For more documentation, see the general :doc:`physics page "
"</game_engine/physics/index>`."
msgstr ""

#: ../../manual/game_engine/physics/types/dynamic.rst:19
msgid "Options"
msgstr ""

#: ../../manual/game_engine/physics/types/dynamic.rst:21
msgid "See :doc:`/game_engine/physics/types/rigid_body`."
msgstr ""

#~ msgid ""
#~ msgstr ""

#~ msgid "**Basic**"
#~ msgstr ""

#~ msgid "**Radius= 1.5**"
#~ msgstr ""

#~ msgid "**Unapplied Scale**"
#~ msgstr ""

#~ msgid "**Applied Scale**"
#~ msgstr ""

#~ msgid "**Collision Bounds**"
#~ msgstr ""

#~ msgid "The `x extent`, then, is half of the distance between the x min/max."
#~ msgstr ""

#~ msgid "A convex hull sketch"
#~ msgstr ""

#~ msgid "Velocity- Limit the speed of an object 0 - 1000."
#~ msgstr ""

#~ msgid "Capsule - A cylinder with hemispherical caps, like a pill."
#~ msgstr ""

#~ msgid ""
#~ "Which is a cylinder with hemispherical"
#~ " caps, like a pill. Radius of "
#~ "the hemispheres is the greater of "
#~ "the x or y extent. Height is "
#~ "the z bounds."
#~ msgstr ""

#~ msgid "The x,y,z bounding box, as defined above."
#~ msgstr ""

#~ msgid ""
#~ "Enables detection by Near and Radar "
#~ "Sensors. Python property: ``obj.game.use_actor``"
#~ msgstr ""

#~ msgid ""
#~ "Does not display, the same as "
#~ "setting the object to unrendered (such"
#~ " as unchecking the \"Camera\" icon in"
#~ " the :doc:`Outliner </editors/outliner>`. Python"
#~ " property: ``obj.use_render``"
#~ msgstr ""

#~ msgid ""
#~ "Materials can have physics settings on"
#~ " them as well: Friction, Elasticity, "
#~ "Force Field (positive or negative "
#~ "force), and also Dampening to other "
#~ "materials. When you turn on this "
#~ "checkbox, you are enabling the Material"
#~ " to exhibit this spring force. Python"
#~ " property: ``obj.game.use_material_physics_fh``"
#~ msgstr ""

#~ msgid "Todo Python property: ``obj.game.use_rotate_from_normal``"
#~ msgstr ""

#~ msgid ""
#~ "Prevents simulation meshes from sleeping. "
#~ "When an object has a linear "
#~ "velocity or angular velocity, it is "
#~ "in motion. It will detect collisions,"
#~ " receive gravity, etc. Once these "
#~ "thresholds are close to zero, it "
#~ "will cease these calculations -- until"
#~ " another object interacts with it "
#~ "wake it up. Python property: "
#~ "``obj.game.use_sleep``"
#~ msgstr ""

#~ msgid ""
#~ "Affects the reaction due to collision"
#~ " between objects -- more massive "
#~ "objects have more inertia. Will also "
#~ "affect material force fields. Will also"
#~ " change behaviors if you are using"
#~ " the suspension and steering portions "
#~ "of Bullet physics. Python property: "
#~ "``obj.game.mass``"
#~ msgstr ""

#~ msgid ""
#~ "If you have the \"Collision Bounds: "
#~ "Sphere\" set explicitly (or implicitly "
#~ "through having the Collision Bounds "
#~ "subpanel unchecked), this will multiply "
#~ "with the Object's (unapplied) Scale. "
#~ "Note that none of the other bounds"
#~ " types are affected. Also note that"
#~ " in the 3D View the display "
#~ "will show this for all types, even"
#~ " though it is only actually used "
#~ "with Sphere. Python property: "
#~ "``obj.game.radius``"
#~ msgstr ""

#~ msgid ""
#~ "For affecting the Inertia Tensor. The"
#~ " higher the value, the greater the"
#~ " rotational inertia, and thus the "
#~ "more resistant to torque. You might "
#~ "think this is strange, considering "
#~ "Dynamic types do not have torque "
#~ "in response to collisions -- but "
#~ "you can still see this value's "
#~ "effects when you manually apply Torque."
#~ " Python property: ``obj.game.form_factor``"
#~ msgstr ""

#~ msgid ""
#~ "Isotropic friction is identical at all"
#~ " angles. Anisotropic is directionally-"
#~ "dependant. Here you can vary the "
#~ "coefficients for the three axes "
#~ "individually, or disable friction entirely."
#~ " Python properties: "
#~ "``obj.game.use_anisotropic_friction`` (boolean) and "
#~ "``obj.game.friction_coefficients`` (a 3-element "
#~ "array)."
#~ msgstr ""

#~ msgid "Limit the speed of an object 0 - 1000."
#~ msgstr ""

#~ msgid ""
#~ "The object is allowed to be at "
#~ "complete rest, but as soon as it"
#~ " accelerates it will immediately jump "
#~ "to the minimum speed. Python property:"
#~ " ``obj.game.velocity_min``"
#~ msgstr ""

#~ msgid "Top speed of the object.  Python property: ``obj.game.velocity_max``"
#~ msgstr ""

#~ msgid ""
#~ "Resist movement 0 - 1. At \"1\""
#~ " the object is completely immobile. "
#~ "Python property: ``obj.game.damping``"
#~ msgstr ""

#~ msgid ""
#~ "Resist rotation, but not the kind "
#~ "of rotation that comes from a "
#~ "collision. For example, if a Motion "
#~ "Controller applies Torque to an object,"
#~ " this damping will be a factor. "
#~ "Python property: ``obj.game.rotation_damping``"
#~ msgstr ""

#~ msgid "X Python property: ``obj.game.lock_location_x``"
#~ msgstr ""

#~ msgid "Y Python property: ``obj.game.lock_location_y``"
#~ msgstr ""

#~ msgid "Z Python property: ``obj.game.lock_location_z``"
#~ msgstr ""

#~ msgid "X Python property: ``obj.game.lock_rotation_x``"
#~ msgstr ""

#~ msgid "Y Python property: ``obj.game.lock_rotation_y``"
#~ msgstr ""

#~ msgid "Z Python property: ``obj.game.lock_rotation_z``"
#~ msgstr ""

#~ msgid ""
#~ "\"Add children to form compound "
#~ "collision object.\" Basically, if you "
#~ "have a child object and do not "
#~ "have this enabled, the child's "
#~ "collisions will not have an effect "
#~ "on that object \"family\" (though it "
#~ "will still push other objects around)."
#~ " If you do have it checked, the"
#~ " parent's physics will respond to the"
#~ " child's collision (thus updating the "
#~ "whole family). Python property: "
#~ "``obj.game.use_collision_compound``"
#~ msgstr ""

#~ msgid ""
#~ "Dynamic objects in the :doc:`Game Engine"
#~ " </game_engine/index>` give/receive collisions, "
#~ "but when they do so they "
#~ "themselves do not rotate in response."
#~ " So, a Dynamic ball will hit a"
#~ " ramp and slide down, while a "
#~ "Rigid Body ball would begin rotating."
#~ msgstr ""

#~ msgid ""
#~ "For more documentation, see the "
#~ ":doc:`Top BGE Physics page "
#~ "</game_engine/physics/index>`."
#~ msgstr ""

#~ msgid "bpy Access"
#~ msgstr ""

#~ msgid ""
#~ "Note that most of these properties "
#~ "are accessible through the non- BGE "
#~ "scripting API via "
#~ "``bpy.data.objects[\"ObjectName\"].game``, which is "
#~ "of type ``bpy.types.GameObjectSetting``. This "
#~ "is useful so you can, for example,"
#~ " set a range of objects to have"
#~ " gradated values via a for-loop."
#~ msgstr ""

#~ msgid "Actor"
#~ msgstr ""

#~ msgid "Enables detection by Near and Radar Sensors."
#~ msgstr ""

#~ msgid "Ghost"
#~ msgstr ""

#~ msgid ""
#~ "Disables collisions completely, similar to "
#~ ":doc:`No collision "
#~ "</game_engine/physics/types/no_collision>`."
#~ msgstr ""

#~ msgid "Invisible"
#~ msgstr ""

#~ msgid ""
#~ "Does not display, the same as "
#~ "setting the object to unrendered (such"
#~ " as unchecking the \"Camera\" icon in"
#~ " the :doc:`Outliner </editors/outliner>`."
#~ msgstr ""

#~ msgid "Use Material Force Field"
#~ msgstr ""

#~ msgid ""
#~ "Materials can have physics settings on"
#~ " them as well: Friction, Elasticity, "
#~ "Force Field (positive or negative "
#~ "force), and also Dampening to other "
#~ "materials. When you turn on this "
#~ "checkbox, you are enabling the Material"
#~ " to exhibit this spring force."
#~ msgstr ""

#~ msgid "Rotate From Normal"
#~ msgstr ""

#~ msgid "Todo."
#~ msgstr ""

#~ msgid "No Sleeping"
#~ msgstr ""

#~ msgid ""
#~ "Prevents simulation meshes from sleeping. "
#~ "When an object has a linear "
#~ "velocity or angular velocity, it is "
#~ "in motion. It will detect collisions,"
#~ " receive gravity, etc. Once these "
#~ "thresholds are close to zero, it "
#~ "will cease these calculations -- until"
#~ " another object interacts with it "
#~ "wake it up."
#~ msgstr ""

#~ msgid "Mass"
#~ msgstr ""

#~ msgid ""
#~ "Affects the reaction due to collision"
#~ " between objects -- more massive "
#~ "objects have more inertia. Will also "
#~ "affect material force fields. Will also"
#~ " change behaviors if you are using"
#~ " the suspension and steering portions "
#~ "of Bullet physics."
#~ msgstr ""

#~ msgid "Radius"
#~ msgstr ""

#~ msgid ""
#~ "If you have the \"Collision Bounds: "
#~ "Sphere\" set explicitly (or implicitly "
#~ "through having the Collision Bounds "
#~ "subpanel unchecked), this will multiply "
#~ "with the Object's (unapplied) Scale. "
#~ "Note that none of the other bounds"
#~ " types are affected. Also note that"
#~ " in the 3D View the display "
#~ "will show this for all types, even"
#~ " though it is only actually used "
#~ "with Sphere."
#~ msgstr ""

#~ msgid "Basic"
#~ msgstr ""

#~ msgid "Radius= 1.5"
#~ msgstr ""

#~ msgid "Unapplied Scale"
#~ msgstr ""

#~ msgid "Applied Scale"
#~ msgstr ""

#~ msgid "Collision Bounds"
#~ msgstr ""

#~ msgid "Rolls, radius of 1 BU"
#~ msgstr ""

#~ msgid "Rolls, radius of 1.5 BU (after \"popping\" upward)"
#~ msgstr ""

#~ msgid "Rolls, radius of 1.5 BU"
#~ msgstr ""

#~ msgid "Rolls, radius of 1 BU (!)"
#~ msgstr ""

#~ msgid "Default (which is Sphere)"
#~ msgstr ""

#~ msgid "Slides, extent of 1 BU"
#~ msgstr ""

#~ msgid "Box"
#~ msgstr ""

#~ msgid "\"\""
#~ msgstr ""

#~ msgid "Convex Hull"
#~ msgstr ""

#~ msgid "Slides, extent of 1 BU (but with more friction than above)"
#~ msgstr ""

#~ msgid "Acts insane"
#~ msgstr ""

#~ msgid "Slides extent of 1.5 BU"
#~ msgstr ""

#~ msgid "Triangle Mesh"
#~ msgstr ""

#~ msgid "Form Factor"
#~ msgstr ""

#~ msgid ""
#~ "For affecting the Inertia Tensor. The"
#~ " higher the value, the greater the"
#~ " rotational inertia, and thus the "
#~ "more resistant to torque. You might "
#~ "think this is strange, considering "
#~ "Dynamic types do not have torque "
#~ "in response to collisions -- but "
#~ "you can still see this value's "
#~ "effects when you manually apply Torque."
#~ msgstr ""

#~ msgid "Anisotropic Friction"
#~ msgstr ""

#~ msgid ""
#~ "Isotropic friction is identical at all"
#~ " angles. Anisotropic is directionally-"
#~ "dependant. Here you can vary the "
#~ "coefficients for the three axes "
#~ "individually, or disable friction entirely."
#~ msgstr ""

#~ msgid "Velocity"
#~ msgstr ""

#~ msgid "Limit the speed of an object."
#~ msgstr ""

#~ msgid "Minimum"
#~ msgstr ""

#~ msgid ""
#~ "The object is allowed to be at "
#~ "complete rest, but as soon as it"
#~ " accelerates it will immediately jump "
#~ "to the minimum speed."
#~ msgstr ""

#~ msgid "Maximum"
#~ msgstr ""

#~ msgid "Top speed of the object."
#~ msgstr ""

#~ msgid "Damping- Increase the \"sluggishness\" of the object."
#~ msgstr ""

#~ msgid "Translation"
#~ msgstr ""

#~ msgid "Resist movement 0 - 1. At \"1\" the object is completely immobile."
#~ msgstr ""

#~ msgid "Rotation"
#~ msgstr ""

#~ msgid ""
#~ "Resist rotation, but not the kind "
#~ "of rotation that comes from a "
#~ "collision. For example, if a Motion "
#~ "Controller applies Torque to an object,"
#~ " this damping will be a factor."
#~ msgstr ""

#~ msgid "Lock Translation"
#~ msgstr ""

#~ msgid ""
#~ "Seize the object in the world "
#~ "along one or more axes. Note that"
#~ " this is global coordinates, not "
#~ "local or otherwise."
#~ msgstr ""

#~ msgid "Lock Rotation"
#~ msgstr ""

#~ msgid "Same, but for rotation (also with respect to the global coordinates)."
#~ msgstr ""

#~ msgid ""
#~ "The first thing you must understand "
#~ "is the idea of the 3D Bounding "
#~ "Box. If you run through all the"
#~ " vertices of a mesh and record "
#~ "the lowest and highest x values, "
#~ "you have found the *x min/max* the"
#~ " complete boundary for all x values"
#~ " within the mesh. Do this again "
#~ "for y and z, then make a "
#~ "rectangular prism out of these values,"
#~ " and you have a *Bounding Box*. "
#~ "This box could be oriented relative "
#~ "globally to the world or locally "
#~ "to the object's rotation."
#~ msgstr ""

#~ msgid ""
#~ "Demonstration of a Local Bounding Box"
#~ " (left) and a Global Bounding Box "
#~ "(right)."
#~ msgstr ""

#~ msgid "The *x extent*, then, is half of the distance between the x min/max."
#~ msgstr ""

#~ msgid ""
#~ "Throughout all of this you must be"
#~ " cognizant of the Object Origin. For"
#~ " the Game engine, the default :kbd"
#~ ":`Ctrl-Alt-Shift-C`, :kbd:`3` or "
#~ ":menuselection:`Set Origin --> Origin to "
#~ "Geometry` is unlikely to get the "
#~ "desired placement of the Collision "
#~ "Bounds that you want. Instead, you "
#~ "should generally set the origin by "
#~ "looking at the Tool Shelf after "
#~ "you do the *Set Origin*, and "
#~ "changing the *Center* from *Median "
#~ "Center* to *Bounds Center*. Blender will"
#~ " remember this change for future :kbd"
#~ ":`Ctrl-Alt-Shift-C` executions."
#~ msgstr ""

#~ msgid ""
#~ "All Collision Bounds are centered on "
#~ "this origin. All boxes are oriented "
#~ "locally, so object rotation matters."
#~ msgstr ""

#~ msgid "Setting the origin to Bounds Center instead of Median Center."
#~ msgstr ""

#~ msgid ""
#~ "A final introductory comment: When you"
#~ " set the Collision Bounds on an "
#~ "object, Blender will attempt to display"
#~ " a visualization of the bounds in "
#~ "the form of a dotted outline. "
#~ "Currently, there is a bug: *The 3D"
#~ " View* does not display this bounds"
#~ " preview where it actually will be"
#~ " during the game. To see it, go"
#~ " to :menuselection:`Game --> Show Physics"
#~ " Visualization` and look for the "
#~ "white (or green, if sleeping) geometry."
#~ msgstr ""

#~ msgid ""
#~ "Now we can explain the various "
#~ "options for the *Collision Bounds* "
#~ "settings:"
#~ msgstr ""

#~ msgid "Default"
#~ msgstr ""

#~ msgid ""
#~ "For Dynamic and Static objects, it "
#~ "is a Triangle Mesh (see below). "
#~ "For everything else, it is a "
#~ "Sphere (see below)."
#~ msgstr ""

#~ msgid "Capsule"
#~ msgstr ""

#~ msgid ""
#~ "Which is a cylinder with hemispherical"
#~ " caps, like a pill. Radius of "
#~ "the hemispheres is the greater of "
#~ "the X or Y extent. Height is "
#~ "the Z bounds."
#~ msgstr ""

#~ msgid "The X, Y, Z bounding box, as defined above."
#~ msgstr ""

#~ msgid "Sphere"
#~ msgstr ""

#~ msgid ""
#~ "Radius is defined by the object's "
#~ "scale (visible in the N properties "
#~ "panel) times the physics radius (can "
#~ "be found in :menuselection:`Physics --> "
#~ "Attributes --> Radius`. Note: This is"
#~ " the only bounds that respects the"
#~ " Radius option."
#~ msgstr ""

#~ msgid "Cylinder"
#~ msgstr ""

#~ msgid "Radius is the greater of the x or y extent. Height is the z bounds."
#~ msgstr ""

#~ msgid "Cone"
#~ msgstr ""

#~ msgid ""
#~ "Base radius is the greater of the"
#~ " x or y extent. Height is the"
#~ " z bounds."
#~ msgstr ""

#~ msgid "Forms a shrink-wrapped, simplified geometry around the object."
#~ msgstr ""

#~ msgid "A convex hull sketch."
#~ msgstr ""

#~ msgid "Triangle mesh"
#~ msgstr ""

#~ msgid ""
#~ "Most expensive, but most precise. "
#~ "Collision will happen with all of "
#~ "triangulated polygons, instead of using "
#~ "a virtual mesh to approximate that "
#~ "collision."
#~ msgstr ""

#~ msgid "By Hand"
#~ msgstr ""

#~ msgid ""
#~ "This is not an option in the "
#~ "Physics tab's Collision Bounds settings, "
#~ "but a different approach, entirely. You"
#~ " create a second mesh, which is "
#~ "invisible, to be the physics "
#~ "representation. This becomes the parent "
#~ "for your display object. Then, your "
#~ "display object is set to ghost so"
#~ " it does not fight with the "
#~ "parent object. This method allows you"
#~ " to strike a balance between the "
#~ "accuracy of *Triangle Mesh* with the "
#~ "efficiency of some of the others. "
#~ "See the demo of this in the "
#~ "dune buggy to the right."
#~ msgstr ""

#~ msgid "Another way to create Collision Bounds -- By hand."
#~ msgstr ""

#~ msgid "There are only two options in the Collision Bounds subpanel."
#~ msgstr ""

#~ msgid "Margin"
#~ msgstr ""

#~ msgid ""
#~ "\"Add extra margin around object for "
#~ "collision detection, small amount required "
#~ "for stability.\" If you find your "
#~ "objects are getting stuck in places "
#~ "they should not, try increasing this "
#~ "to, say, 0.06."
#~ msgstr ""

#~ msgid ""
#~ "Sometimes 0.06 is the default (such "
#~ "as on the Default Cube), but "
#~ "sometimes it is not. You have to"
#~ " keep an eye on the setting, or"
#~ " else learn the symptoms so you "
#~ "can respond when it gives you "
#~ "trouble. If you are "
#~ "lazy/paranoid/unsure/diligent/bored, you can always"
#~ " run this on the Python Console "
#~ "to bump all 0.0 margins to 0.06:"
#~ " for ``obj`` in ``bpy.data.objects``: "
#~ "``obj.game.collision_margin = obj.game.collision_margin``"
#~ " or 0.06"
#~ msgstr ""

#~ msgid "Compound"
#~ msgstr ""

#~ msgid ""
#~ "\"Add children to form compound "
#~ "collision object.\" Basically, if you "
#~ "have a child object and do not "
#~ "have this enabled, the child's "
#~ "collisions will not have an effect "
#~ "on that object \"family\" (though it "
#~ "will still push other objects around)."
#~ " If you do have it checked, the"
#~ " parent's physics will respond to the"
#~ " child's collision (thus updating the "
#~ "whole family)."
#~ msgstr ""

#~ msgid "Create Obstacle"
#~ msgstr ""

#~ msgid "Todo"
#~ msgstr ""

