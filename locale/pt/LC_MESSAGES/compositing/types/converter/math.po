# SOME DESCRIPTIVE TITLE.
# Copyright (C) : This page is public domain as CC0
# This file is distributed under the same license as the Blender 2.77 Manual
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
msgid ""
msgstr ""
"Project-Id-Version: Blender 2.77 Manual 2.77\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-09-26 17:52-0400\n"
"PO-Revision-Date: 2016-12-30 10:19-0300\n"
"Last-Translator: Ivan Paulos Tomé <greylica@gmail.com>\n"
"Language-Team: Ivan Paulos Tomé <greylica@gmail.com>\n"
"MIME-Version: 1.0\n"
"Language: pt_BR\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Poedit-Language: Portuguese\n"
"X-Poedit-Country: BRAZIL\n"

#: ../../manual/compositing/types/converter/math.rst:7
msgid "Math Node"
msgstr "Matemática"

#: ../../manual/compositing/types/converter/math.rst:13
msgid "Math node."
msgstr "O painel do nó tipo \"Matemática\"."

#: ../../manual/compositing/types/converter/math.rst:15
msgid "This node performs math operations."
msgstr "Este nó executa operações matemáticas."

#: ../../manual/compositing/types/converter/math.rst:19
msgid "Inputs"
msgstr "Entradas"

#: ../../manual/compositing/types/converter/math.rst:22
#: ../../manual/compositing/types/converter/math.rst:28
#: ../../manual/compositing/types/converter/math.rst:45
msgid "Value"
msgstr "Valor"

#: ../../manual/compositing/types/converter/math.rst:22
msgid "First numerical value. The trigonometric functions accept values in radians."
msgstr "O primeiro valor numérico. As funções trigonométricas aceitam valores em radianos."

#: ../../manual/compositing/types/converter/math.rst:25
msgid "Second numerical value. This value is **not** used in functions that accept only one parameter like the trigonometric functions, Round and Absolute."
msgstr "O segundo valor numérico. Este valor **não** é usado em funções que aceitam somente um parâmetro como as funções trigonométricas, Arredondamento e Absoluto(a)."

#: ../../manual/compositing/types/converter/math.rst:31
msgid "Properties"
msgstr "Propriedades"

#: ../../manual/compositing/types/converter/math.rst:34
msgid "Operation"
msgstr "Operação"

#: ../../manual/compositing/types/converter/math.rst:34
msgid "Add, Subtract, Multiply, Divide, Sine, Cosine, Tangent, Arcsine, Arccosine, Arctangent, Power, Logarithm, Minimum, Maximum, Round, Less Than, Greater Than, Modulo, Absolute."
msgstr "Adicionar, Subtrair, Multiplicar, Dividir, Seno, Cosseno, Tangente, Arco seno, Arco cosseno, Arco tangente, Potência, Logarítmico (valor), Mínimo, Máximo, Arredondamento, Menor que, Maior que, Módulo e Absoluto(a)."

#: ../../manual/compositing/types/converter/math.rst:38
msgid "Clamp"
msgstr "Limitar"

#: ../../manual/compositing/types/converter/math.rst:37
msgid "Limits the output to the range (0 to 1). See :term:`clamp`."
msgstr "Limita (trunca) a saída para a amplitude entre 0 e 1. Veja o termo :term:`clamp`."

#: ../../manual/compositing/types/converter/math.rst:41
msgid "Outputs"
msgstr "Saídas"

#: ../../manual/compositing/types/converter/math.rst:44
msgid "Numerical value output."
msgstr "A saída em formato de valor numérico."

#: ../../manual/compositing/types/converter/math.rst:48
msgid "Examples"
msgstr "Exemplos"

#: ../../manual/compositing/types/converter/math.rst:51
msgid "Manual Z-Mask"
msgstr "Máscara Z manual"

#: ../../manual/compositing/types/converter/math.rst:56
msgid "Example."
msgstr "Exemplo."

#: ../../manual/compositing/types/converter/math.rst:59
msgid "This example has one scene input by the top *Render Layer* node, which has a cube that is about 10 BU from the camera. The bottom Render Layer node inputs a scene (FlyCam) with a plane that covers the left half of the view and is 7 BU from the camera. Both are fed through their respective Map Value nodes to divide the Z buffer by 20 (multiply by 0.05, as shown in the Size field) and clamped to be a min/ max of 0.0/ 1.0 respectively."
msgstr "Este exemplo possui uma entrada de cena fornecida pelo nó de *Camadas de renderização* na parte de cima, que é representada por um cubo que está aproximadamente 10 Unidades Blender de distância da câmera. O nó de *Camadas de renderização* logo abaixo tem uma outra entrada de cena (um voo de câmera) com um plano que cobre a metade esquerda da visão e está a 7 Unidades Blender de distância da câmera. Ambas as entradas foram alimentadas pelos seus respectivos nós do tipo \"Mapear valores\" para dividir o buffer de profundidade Z por 20 (ou seja, multiplicam-no por 0.05, como mostrado no campo *Tamanho*) e foram limitados para estar em um intervalo máximo contido entre 0.0 e 1.0 respectivamente."

#: ../../manual/compositing/types/converter/math.rst:67
msgid "For the minimum function, the node selects those Z values where the corresponding pixel is closer to the camera; so it chooses the Z values for the plane and part of the cube. The background has an infinite Z value, so it is clamped to 1.0 (shown as white). In the maximum example, the Z values of the cube are greater than the plane, so they are chosen for the left side, but the plane (FlyCam) Render layers Z are infinite (mapped to 1.0) for the right side, so they are chosen."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:77
msgid "Using Sine Function to Pulsate"
msgstr "Usando a função senoidal para criar pulsos"

#: ../../manual/compositing/types/converter/math.rst:81
msgid "This example has a *Time* node putting out a linear sequence from 0 to 1 over the course of 101 frames. The green vertical line in the curve widget shows that frame 25 is being put out, or a value of 0.25. That value is multiplied by 2 × pi and converted to 1.0 by the Sine function, since we all know that :math:`sin(2 × pi/ 4) = sin(pi/ 2) = +1.0` Since the sine function can put out values between (-1.0 to 1.0), the *Map Value* node scales that to 0.0 to 1.0 by taking the input (-1 to 1), adding 1 (making 0 to 2), and multiplying the result by one-half (thus scaling the output between 0 to 1). The default *Color Ramp* converts those values to a grayscale. Thus, medium gray corresponds to a 0.0 output by the sine, black to -1.0, and white to 1.0. As you can see, :math:`sin(pi/ 2) = 1.0`. Like having your own visual color calculator! Animating this node setup provides a smooth cyclic sequence through the range of grays."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:93
msgid "Use this function to vary, for example, the alpha channel of an image to produce a fading in/out effect. Alter the Z channel to move a scene in/out of focus. Alter a color channel value to make a color \"pulse\"."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:100
msgid "Brightening/Scaling a Channel"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:104
msgid "This example has a *Math: Multiply* node increasing the luminance channel (Y) of the image to make it brighter. Note that you should use a *Map Value node* with min() and max() enabled to clamp the output to valid values. With this approach, you could use a logarithmic function to make a high-dynamic range image. For this particular example, there is also a *Brighten/Contrast node* that might give simpler control over brightness."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:113
msgid "Quantize/Restrict Color Selection"
msgstr "Quantização e / ou restrição de seleção de cores"

#: ../../manual/compositing/types/converter/math.rst:115
msgid "In this example, we want to restrict the color output to only 256 possible values. Possible use of this is to see what the image will look like on an 8-bit cell phone display. To do this, we want to restrict the R, G and B values of any pixel to be one of a certain value, such that when they are combined, will not result in more than 256 possible values. The number of possible values of an output is the number of channel values multiplied by each other, or Q = R × G × B."
msgstr "Neste exemplo, nós queremos restringir a saída de cores somente para 256 valores possíveis. A utilização possível desta funcionalidade é verificar como a imagem se parecerá em um telefone celular que possui uma tela (ecrã) que tem apenas 8 bits de cor. Para fazer isto, nós queremos restringir os valores R (Vermelho), G (Verde), e B (Azul) de quaisquer dos pixeis para ser de um determinado valor, de maneira que quando sejam combinados, não resultarão em mais de 256 possíveis valores. O número de valores possíveis de uma saída é o número de valores de canais multiplicados pelos outros, ou Q (cor) = R × G × B."

#: ../../manual/compositing/types/converter/math.rst:122
msgid "Since there are three channels and 256 values, we have some flexibility how to quantize each channel, since there are a lot of combinations of R × G × B that would equal 256. For example, if {R, G, B} = {4, 4, 16}, then :math:`4 × 4 × 16 = 256`. Also, {6, 6, 7} would give 252 possible values. The difference in appearance between {4, 4, 16} and {6, 6, 7} is that the first set (4, 4, 16} would have fewer shades of red and green, but lots of shades of blue. The set {6, 6, 7} would have a more even distribution of colors. To get better image quality with fewer color values, give possible values to the predominant colors in the image."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:134
msgid "Theory"
msgstr "Teoria"

#: ../../manual/compositing/types/converter/math.rst:136
msgid "`Two Approaches to Quantizing to six values <https://wiki.blender.org/index.php/File:Manual-Compositing-Node-Math_ColorBand>`__."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:139
msgid "To accomplish this quantization of an image to 256 possible values, let us use the set {6, 6, 7}. To split up a continuous range of values between 0 and 1 (the full Red spectrum) into six values, we need to construct an algorithm or function that takes any input value but only puts out six possible values, as illustrated by the image to the right. We want to include zero as true black, with five other colors in between. The approach shown produces {0, 0.2, 0.4, 0.6, 0.8, 1}. Dividing 1.0 by 5 equals 0.2, which tells how far apart each quantified value is from the other."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:147
msgid "So, to get good even shading, we want to take values that are 0.16 or less and map them to 0.0; values between 0.16 and 0.33 get fixed to 0.2; color band values between 0.33 and 0.5 get quantized to 0.4, and so on up to values between 0.83 and 1.0 get mapped to 1.0."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:153
msgid "Function f(x)"
msgstr "Função f(x)"

#: ../../manual/compositing/types/converter/math.rst:155
msgid "An algebraic function is made up of primitive mathematical operations (add, subtract, multiply, sine, cosine, etc) that operate on an input value to provide the desired output value."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:159
msgid "`Spreadsheet showing a function <https://wiki.blender.org/index.php/File:Manual-Compositing-Node-Math_spreadsheet>`__."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:162
msgid "The theory behind this function is scaled truncation. Suppose we want a math function that takes in a range of values between 0 and 1, such as 0.552, but only outputs a value of 0.0, 0.2, 0.4, etc. We can imagine then that we need to get that range 0 to 1 powered up to something 0 to 6 so that we can chop off and make it a whole number. So, with six divisions, how can we do that? The answer is we multiply the range by 6. The output of that first math Multiply Node is a range of values between 0 and 6. To get even divisions, because we are using the rounding function (see documentation above), we want any number plus or minus around a whole number will get rounded to that number. So, we subtract a half, which shifts everything over. The round() function then makes that range 0 to 5. We then divide by 5 to get back a range of numbers between 0 and 1 which can then be combined back with the other color channels. Thus, you get the function :math:`f(x, n) = round(x × n - 0.5)/ (n - 1)` where \"n\" is the number of possible output values, and \"x\" is the input pixel color and :math:`f(x, n)` is the output value. There is only one slight problem, and that is for the value exactly equal to 1, the formula result is 1.2, which is an invalid value. This is because the round function is actually a roundup function, and exactly 5.5 is rounded up to 6. So, by subtracting 0.501, we compensate and thus 5. 499 is rounded to 5. At the other end of the spectrum, pure black, or 0, when 0.501 subtracted, rounds up to 0 since the Round() function does not return a negative number."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:183
msgid "Sometimes using a spreadsheet can help you figure out how to put these nodes together to get the result that you want. Stepping you through the formula for :math:`n = 6` and :math:`x = 0.70`, locate the line on the spreadsheet that has the 8-bit value 179 and R value 0.7. Multiplying by 6 gives 4.2 . Subtracting 1/2 gives 3.7, which rounds up to 4.4 divided by 5 = 0.8. Thus, f(0.7, 6) = 0.8 or an 8-bit value of 204. You can see that this same 8-bit value is output for a range of input values."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:192
msgid "Reality"
msgstr "Realidade"

#: ../../manual/compositing/types/converter/math.rst:194
msgid "To implement this function in Blender, consider the node setup above. First, feed the image to the Separate RGB node. For the Red channel, we string the math nodes into a function that takes each red color, multiplies (scales) it up by the desired number of divisions (6), offsets it by 0.5, rounds the value to the nearest whole number, and then divides the image pixel color by 5. So, the transformation is {0 to 1} becomes {0 to 6}, subtracting centers the medians to {-0.5 to 5.5} and the rounding to the nearest whole number produces {0, 1, 2, 3, 4, 5} since the function rounds down, and then dividing by five results in six values {0.0, 0.2, 0.4, 0.6, 0.8, 1.0}."
msgstr "Para implementar esta função no Blender, considere a configuração do nó acima. Primeiramente, alimente a imagem através de um nó do tipo \"Separar RGB\". Para o canal vermelho, nós passamos aos nós de matemática uma função que obtém cada tonalidade de vermelho, a multiplica (escalona) por um número desejado de divisões (6), a deslocamos em 0.5, e arredondamos o valor para o número inteiro mais próximo, e então dividimos as cores dos pixeis da imagem por 5. Portanto, as transformações que estavam entre { 0 e 1 }  estarão agora em um intervalo entre { 0 e 6 }. Subtraindo os centros das cores medianas para valores situados entre  {-0.5 e 5.5} e arredondando para o número inteiro mais próximo produzirá valores na escala { 0, 1, 2, 3, 4, 5 } devido ao fato da função arredondar ao menor, e então a divisão por cinco resultará em seis escalas de valores: {0.0, 0.2, 0.4, 0.6, 0.8, 1.0}."

#: ../../manual/compositing/types/converter/math.rst:204
msgid "The result is that the output value can only be one of a certain set of values, stair-stepped, because of the rounding function of the math node node setup. Copying this one channel to operate on Green and Blue gives the node setup below. To get the 6:6:7, we set the three Multiply Nodes to {6, 6, 7} and the divide nodes to {5, 5, 6}."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:212
msgid "If you make this into a node group, you can easily re-use this setup from project to project. When you do, consider using a math node to drive the different values that you would have to otherwise set manually, just to error-proof your work."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:218
msgid "Summary"
msgstr "Sumário"

#: ../../manual/compositing/types/converter/math.rst:220
msgid "Normally, an output render consists of 32- or 24-bit color depth, and each pixel can be one of the millions of possible colors. This node setup example takes each of the Red, Green and Blue channels and normalizes them to one of a few values. When all three channels are combined back together, each color can only be one of 256 possible values."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:227
msgid "While this example uses the Separate/Combine RGB to create distinct colors, other Separate/Combine nodes can be used as well. If using the YUV values, remember that U and V vary between (-0.5 to +0.5), so you will have to first add on a half to bring the range between 0 and 1, and then after dividing, subtract a half to bring in back into standard range."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:233
msgid "The ``JPG`` or ``PNG`` image format will store each of the colors according to their image standard for color depth (e.g. ``JPG`` is 24-bit), but the image will be very very small since reducing color depth and quantizing colors are essentially what the ``JPEG`` compression algorithm accomplishes."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:238
msgid "You do not have to reduce the color depth of each channel evenly. For example, if blue was the dominant color in an image, to preserve image quality, you could reduce Red to 2 values, Green to 4, and let the blue take on :math:`256/(2 × 4)` or 32 values. If using the HSV, you could reduce the Saturation and Value to 2 values (0 or 1.0) by Multiply by 2 and Divide by 2, and restrict the Hue to 64 possible values."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:244
msgid "You can use this node setup to quantize any channel; alpha, speed (vector), z-values, and so forth."
msgstr ""

