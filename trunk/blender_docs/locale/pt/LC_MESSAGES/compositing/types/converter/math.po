# SOME DESCRIPTIVE TITLE.
# Copyright (C) : This page is public domain as CC0
# This file is distributed under the same license as the Blender 2.77 Manual
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
msgid ""
msgstr ""
"Project-Id-Version: Blender 2.77 Manual 2.77\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-08-02 18:32-0400\n"
"PO-Revision-Date: 2018-01-03 23:48-0300\n"
"Last-Translator: Ivan Paulos Tomé <greylica@gmail.com>\n"
"Language: pt_BR\n"
"Language-Team: Ivan Paulos Tomé <greylica@gmail.com>\n"
"Plural-Forms: nplurals=2; plural=(n > 1)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../manual/compositing/types/converter/math.rst:11
msgid "Math Node"
msgstr "Matemática"

#: ../../manual/compositing/types/converter/math.rst:16
msgid "Math node."
msgstr "O painel do nó tipo \"Matemática\"."

#: ../../manual/compositing/types/converter/math.rst:18
msgid "The *Math Node* performs math operations."
msgstr "O nó do tipo *Matemática* executa operações matemáticas."

#: ../../manual/compositing/types/converter/math.rst:22
msgid "Inputs"
msgstr "Entradas"

#: ../../manual/compositing/types/converter/math.rst:25
#: ../../manual/compositing/types/converter/math.rst:31
#: ../../manual/compositing/types/converter/math.rst:48
msgid "Value"
msgstr "Valor"

#: ../../manual/compositing/types/converter/math.rst:25
msgid ""
"First numerical value. The trigonometric functions accept values in "
"radians."
msgstr ""
"O primeiro valor numérico. As funções trigonométricas aceitam valores em "
"radianos."

#: ../../manual/compositing/types/converter/math.rst:28
msgid ""
"Second numerical value. This value is **not** used in functions that "
"accept only one parameter like the trigonometric functions, Round and "
"Absolute."
msgstr ""
"O segundo valor numérico. Este valor **não** é usado em funções que "
"aceitam somente um parâmetro como as funções trigonométricas, "
"Arredondamento e Absoluto(a)."

#: ../../manual/compositing/types/converter/math.rst:34
msgid "Properties"
msgstr "Propriedades"

#: ../../manual/compositing/types/converter/math.rst:37
msgid "Operation"
msgstr "Operação"

#: ../../manual/compositing/types/converter/math.rst:37
#, fuzzy
msgid ""
"Add, Subtract, Multiply, Divide, Sine, Cosine, Tangent, Arcsine, "
"Arccosine, Arctangent, Arctangent2, Power, Logarithm, Minimum, Maximum, "
"Round, Less Than, Greater Than, Modulo, Absolute"
msgstr ""
"Adicionar, Subtrair, Multiplicar, Dividir, Seno, Cosseno, Tangente, Arco "
"seno, Arco cosseno, Arco tangente, Potência, Logarítmico (valor), Mínimo,"
" Máximo, Arredondamento, Menor que, Maior que, Módulo e Absoluto(a)."

#: ../../manual/compositing/types/converter/math.rst:41
msgid "Clamp"
msgstr "Limitar"

#: ../../manual/compositing/types/converter/math.rst:40
msgid "Limits the output to the range (0 to 1). See :term:`clamp`."
msgstr ""
"Limita (trunca) a saída para a amplitude entre 0 e 1. Veja o termo "
":term:`Limitar`."

#: ../../manual/compositing/types/converter/math.rst:44
msgid "Outputs"
msgstr "Saídas"

#: ../../manual/compositing/types/converter/math.rst:47
msgid "Numerical value output."
msgstr "A saída em formato de valor numérico."

#: ../../manual/compositing/types/converter/math.rst:51
msgid "Examples"
msgstr "Exemplos"

#: ../../manual/compositing/types/converter/math.rst:54
msgid "Manual Z-Mask"
msgstr "Máscara Z manual"

#: ../../manual/compositing/types/converter/math.rst:58
msgid "Minimum and maximum function example."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:60
#, fuzzy
msgid ""
"This example has one scene input by the top *Render Layers* node, which "
"has a cube that is about 10 BU from the camera. The bottom *Render "
"Layers* node inputs a scene with a plane that covers the left half of the"
" view and is 7 BU from the camera. Both are fed through their respective "
"*Map Value* nodes to divide the Z-buffer by 20 (multiply by 0.05, as "
"shown in the Size field) and clamped to be a min/max of 0.0/1.0 "
"respectively."
msgstr ""
"Este exemplo possui uma entrada de cena fornecida pelo nó de *Camadas de "
"renderização* na parte de cima, que é representada por um cubo que está "
"aproximadamente 10 Unidades Blender de distância da câmera. O nó de "
"*Camadas de renderização* logo abaixo tem uma outra entrada de cena (um "
"voo de câmera) com um plano que cobre a metade esquerda da visão e está a"
" 7 Unidades Blender de distância da câmera. Ambas as entradas foram "
"alimentadas pelos seus respectivos nós do tipo \"Mapear valores\" para "
"dividir o buffer de profundidade Z por 20 (ou seja, multiplicam-no por "
"0.05, como mostrado no campo *Tamanho*) e foram limitados para estar em "
"um intervalo máximo contido entre 0.0 e 1.0 respectivamente."

#: ../../manual/compositing/types/converter/math.rst:68
#, fuzzy
msgid ""
"For the minimum function, the node selects those Z values where the "
"corresponding pixel is closer to the camera; so it chooses the Z values "
"for the plane and part of the cube. The background has an infinite Z "
"value, so it is clamped to 1.0 (shown as white). In the maximum example, "
"the Z values of the cube are greater than the plane, so they are chosen "
"for the left side, but the plane *Render Layers* Z are infinite (mapped "
"to 1.0) for the right side, so they are chosen."
msgstr ""
"Para a função \"mínimo\", o nó seleciona aqueles valores de profundidade "
"Z cujos pixeis correspondentes estão mais próximos da câmera; portanto, "
"ele escolhe os valores Z para o plano e parte do cubo. O plano de fundo "
"possui um valor de Z infinito, portanto será limitado (truncado) em 1.0 "
"(mostrado na cor branca). No exemplo \"máximo\", os valores de "
"profundidade Z do cubo são maiores que os do plano, portanto eles são "
"escolhidos para o lado esquerdo, mas as profundidades Z das camadas de "
"renderização referentes ao o plano (do voo de câmera) são infinitos "
"(mapeados em 1.0) para o lado direito, portanto eles foram escolhidos."

#: ../../manual/compositing/types/converter/math.rst:78
msgid "Using Sine Function to Pulsate"
msgstr "Usando a função senoidal para criar pulsos"

#: ../../manual/compositing/types/converter/math.rst:82
#, fuzzy
msgid "Using sine function example."
msgstr "Usando a função senoidal para criar pulsos"

#: ../../manual/compositing/types/converter/math.rst:84
msgid ""
"This example has a *Time* node putting out a linear sequence from 0 to 1 "
"over the course of 101 frames. At frame 25, the output value is 0.25. "
"That value is multiplied by 2 × pi (6.28) and converted to 1.0 by the "
"Sine function, since we all know that :math:`sin(2 × pi/ 4) = sin(pi/ 2) "
"= +1.0`."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:89
msgid ""
"Since the sine function can put out values between (-1.0 to 1.0), the "
"*Map Value* node scales that to 0.0 to 1.0 by taking the input (-1 to 1),"
" adding 1 (making 0 to 2), and multiplying the result by one-half (thus "
"scaling the output between 0 to 1). The default *Color Ramp* converts "
"those values to a gray-scale. Thus, medium gray corresponds to a 0.0 "
"output by the sine, black to -1.0, and white to 1.0. As you can see, "
":math:`sin(pi/ 2) = 1.0`. Like having your own visual color calculator! "
"Animating this node setup provides a smooth cyclic sequence through the "
"range of grays."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:97
msgid ""
"Use this function to vary, for example, the alpha channel of an image to "
"produce a fading in/out effect. Alter the Z channel to move a scene "
"in/out of focus. Alter a color channel value to make a color \"pulse\"."
msgstr ""
"Utilize esta função para variar, por exemplo, o canal alfa de uma imagem "
"para produzir um efeito de aparecimento (*fade in* em Inglês) ou "
"esmaecimento (*fade out*  em Inglês). altere o canal Z para mover a cena "
"para dentro ou para fora do foco. Altere os valores dos canais de cores "
"para criar uma espécie de \"pulso\" de cores. "

#: ../../manual/compositing/types/converter/math.rst:104
#, fuzzy
msgid "Brightening (Scaling) a Channel"
msgstr "Escalonando ou tornando um canal mais brilhante"

#: ../../manual/compositing/types/converter/math.rst:108
msgid "Scaling a channel example."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:110
#, fuzzy
msgid ""
"This example has a *Math (Multiply)* node increasing the luminance "
"channel (Y) of the image to make it brighter. Note that you should use a "
"*Map Value node* with min() and max() enabled to clamp the output to "
"valid values. With this approach, you could use a logarithmic function to"
" make a high dynamic range image. For this particular example, there is "
"also a *Bright/Contrast node* that might give simpler control over "
"brightness."
msgstr ""
"Este exemplo tem um nó to tipo matemática usando a função *multiplicar* "
"para aumentar o canal de luminância (Y) da imagem para torná-la mais "
"brilhante. Note que você deverá usar um nó do tipo *Mapear valores* com "
"as opções máximo() e mínimo() habilitadas para limitar a saída para "
"valores válidos. Através desta abordagem, você pode utilizar uma função "
"logarítmica para criar uma imagem de alta amplitude dinâmica (ou seja, "
"uma imagem conhecida como \"HDRI\"). Para este exemplo em particular, "
"também há um nó do tipo \"Brilho e contraste\" que pode fornecer um "
"controle mais simples sobre o brilho."

#: ../../manual/compositing/types/converter/math.rst:119
msgid "Restrict Color Selection (Posterization)"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:123
msgid "Posterization example."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:125
msgid ""
"In this example, we restrict the color values to be one of the six "
"values: 0, 0.2, 0.4, 0.6, 0.8, 1."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:127
msgid ""
"To split up a continuous range of values between 0 and 1 to certain set "
"of values, the following function is used: :math:`round(x × n - 0.5) / (n"
" - 1)`, where \"n\" is the number of possible output values, and \"x\" is"
" the input pixel color. `Read more about this function "
"<https://en.blender.org/index.php/Doc:2.4/Manual/Composite_Nodes/Types/Convertor#Quantize.2FRestrict_Color_Selection>`__."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:133
msgid ""
"To implement this function in Blender, consider the node setup above. We "
"string the math nodes into a function that takes each color (values from "
"0 to 1), multiplies it up by six, the desired number of divisions (values"
" become from 0 to 6), offsets it by 0.5 (-0.5 to 5.5), rounds the value "
"to the nearest whole number (produces 0, 1, 2, 3, 4, 5), and then divides"
" the image pixel color by five (0.0, 0.2, 0.4, 0.6, 0.8, 1.0)."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:140
msgid ""
"In the case of a color image, you need split it into separate RGB "
"channels using *Separate/Combine RGBA* nodes and perform this operation "
"on each channel independently."
msgstr ""

#~ msgid "Example."
#~ msgstr "Exemplo."

#~ msgid ""
#~ "This example has a *Time* node "
#~ "putting out a linear sequence from "
#~ "0 to 1 over the course of "
#~ "101 frames. The green vertical line "
#~ "in the curve widget shows that "
#~ "frame 25 is being put out, or "
#~ "a value of 0.25. That value is "
#~ "multiplied by 2 × pi and converted"
#~ " to 1.0 by the Sine function, "
#~ "since we all know that :math:`sin(2 "
#~ "× pi/ 4) = sin(pi/ 2) = "
#~ "+1.0`. Since the sine function can "
#~ "put out values between (-1.0 to "
#~ "1.0), the *Map Value* node scales "
#~ "that to 0.0 to 1.0 by taking "
#~ "the input (-1 to 1), adding 1 "
#~ "(making 0 to 2), and multiplying "
#~ "the result by one-half (thus "
#~ "scaling the output between 0 to "
#~ "1). The default *Color Ramp* converts"
#~ " those values to a gray-scale. "
#~ "Thus, medium gray corresponds to a "
#~ "0.0 output by the sine, black to"
#~ " -1.0, and white to 1.0. As you"
#~ " can see, :math:`sin(pi/ 2) = 1.0`."
#~ " Like having your own visual color"
#~ " calculator! Animating this node setup "
#~ "provides a smooth cyclic sequence "
#~ "through the range of grays."
#~ msgstr ""
#~ "Este exemplo possui um nó do tipo"
#~ " *Tempo* inserindo valores de uma "
#~ "sequência linear que vai de 0 a"
#~ " 1 sobre o curso de 101 "
#~ "quadros. A linha vertical verde dentro"
#~ " do assistente de curvas mostra que"
#~ " o quadro 25 está sendo inserido, "
#~ "ou, um valor de 0.25. Este valor"
#~ " é multiplicado por 2 X Pi e"
#~ " convertido para 1.0 pela função "
#~ "*seno*, devido ao fato de sabermos "
#~ "que :math:`seno(2 × pi/ 4) = "
#~ "seno(pi/ 2) = +1.0` . Devido ao"
#~ " fato da função seno poder resultar"
#~ " em valores entre (-1.0 to 1.0), "
#~ "o nó do tipo *Mapear valor* "
#~ "escalona estes valores para o intervalo"
#~ " entre 0.0 e 1.0 pela tomada "
#~ "dos valores de entrada que estão "
#~ "entre (-1 a 1), adicionando 1 "
#~ "(tornando o intervalo entre 0 e "
#~ "2), e multiplicando o resultado pela "
#~ "metade de 1 (portanto, escalonando a "
#~ "saída entre 0 e 1). O nó do"
#~ " tipo *Gradiente de cores* converte "
#~ "estes valores para uma escala de "
#~ "cinza. Portanto, os cinzas médios "
#~ "correspondem a saída de 0.0 pelo "
#~ "cálculo do seno, e o preto estará"
#~ " em -1.0, tendo o branco como "
#~ "1.0. Como você pode ver, :math:`seno(pi/"
#~ " 2) = 1.0`. Isso é como ter "
#~ "sua própria calculadora visual de cores"
#~ " ! A animação desta configuração de"
#~ " nós fornece uma sequência cíclica "
#~ "através da amplitude das escalas de "
#~ "cinza. "

#~ msgid "Quantize/Restrict Color Selection"
#~ msgstr "Quantização e / ou restrição de seleção de cores"

#~ msgid ""
#~ "In this example, we want to "
#~ "restrict the color output to only "
#~ "256 possible values. Possible use of "
#~ "this is to see what the image "
#~ "will look like on an 8-bit cell"
#~ " phone display. To do this, we "
#~ "want to restrict the R, G and "
#~ "B values of any pixel to be "
#~ "one of a certain value, such that"
#~ " when they are combined, will not "
#~ "result in more than 256 possible "
#~ "values. The number of possible values"
#~ " of an output is the number of"
#~ " channel values multiplied by each "
#~ "other, or Q = R × G × "
#~ "B."
#~ msgstr ""
#~ "Neste exemplo, nós queremos restringir a"
#~ " saída de cores somente para 256 "
#~ "valores possíveis. A utilização possível "
#~ "desta funcionalidade é verificar como a"
#~ " imagem se parecerá em um telefone"
#~ " celular que possui uma tela (ecrã)"
#~ " que tem apenas 8 bits de cor."
#~ " Para fazer isto, nós queremos "
#~ "restringir os valores R (Vermelho), G"
#~ " (Verde), e B (Azul) de quaisquer "
#~ "dos pixeis para ser de um "
#~ "determinado valor, de maneira que quando"
#~ " sejam combinados, não resultarão em "
#~ "mais de 256 possíveis valores. O "
#~ "número de valores possíveis de uma "
#~ "saída é o número de valores de "
#~ "canais multiplicados pelos outros, ou Q"
#~ " (cor) = R × G × B."

#~ msgid ""
#~ "Since there are three channels and "
#~ "256 values, we have some flexibility "
#~ "how to quantize each channel, since "
#~ "there are a lot of combinations of"
#~ " R × G × B that would "
#~ "equal 256. For example, if {R, G,"
#~ " B} = {4, 4, 16}, then :math:`4"
#~ " × 4 × 16 = 256`. Also, "
#~ "{6, 6, 7} would give 252 possible"
#~ " values. The difference in appearance "
#~ "between {4, 4, 16} and {6, 6, "
#~ "7} is that the first set {4, "
#~ "4, 16} would have fewer shades of"
#~ " red and green, but lots of "
#~ "shades of blue. The set {6, 6, "
#~ "7} would have a more even "
#~ "distribution of colors. To get better"
#~ " image quality with fewer color "
#~ "values, give possible values to the "
#~ "predominant colors in the image."
#~ msgstr ""
#~ "devido haver três canais e 256 "
#~ "valores, nós temos alguma flexibilidade "
#~ "sobre a maneira a qual quantizaremos "
#~ "cada canal, já que há uma grande"
#~ " quantidade de combinações R X G "
#~ "X B que seriam equivalentes a 256."
#~ " Por exemplo, caso {R, G, B} ="
#~ " {4, 4, 16},  então :math:`4 × "
#~ "4 × 16 = 256`. Também no "
#~ "caso de {6, 6, 7} resultaria no"
#~ " fornecimento de 252 valores possíveis. "
#~ "A diferença na aparência entre {4, "
#~ "4, 16} e {6, 6, 7} é que "
#~ "o primeiro conjunto (4, 4, 16} "
#~ "teria menos tonalidades de vermelho e"
#~ " verde, mas muitas tonalidades de "
#~ "azul. O conjunto {6, 6, 7} tem "
#~ "uma distribuição mais uniforme de cores."
#~ " Para obtenção de uma melhor "
#~ "qualidade de imagem com poucos valores"
#~ " de cor, forneça os valores possíveis"
#~ " para as cores predominantes na "
#~ "imagem."

#~ msgid "Theory"
#~ msgstr "Teoria"

#~ msgid ""
#~ "`Two Approaches to Quantizing to six "
#~ "values <https://wiki.blender.org/index.php/File:Manual-"
#~ "Compositing-Node-Math_ColorBand>`__."
#~ msgstr ""
#~ "`Duas abordagens para a quantização para"
#~ " seis valores (em Inglês) "
#~ "<https://wiki.blender.org/index.php/File:Manual-Compositing-"
#~ "Node-Math_ColorBand>`__."

#~ msgid ""
#~ "To accomplish this quantization of an"
#~ " image to 256 possible values, let"
#~ " us use the set {6, 6, 7}. "
#~ "To split up a continuous range of"
#~ " values between 0 and 1 (the "
#~ "full Red spectrum) into six values, "
#~ "we need to construct an algorithm "
#~ "or function that takes any input "
#~ "value but only puts out six "
#~ "possible values, as illustrated by the"
#~ " image to the right. We want to"
#~ " include zero as true black, with "
#~ "five other colors in between. The "
#~ "approach shown produces {0, 0.2, 0.4,"
#~ " 0.6, 0.8, 1}. Dividing 1.0 by "
#~ "5 equals 0.2, which tells how far"
#~ " apart each quantified value is from"
#~ " the other."
#~ msgstr ""
#~ "Para conseguir esta quantização de uma"
#~ " imagem com 256 valores possíveis, "
#~ "vamos utilizar o conjunto {6, 6, "
#~ "7}. Para separar um intervalo contínuo"
#~ " de valores entre 0 e 1 (o "
#~ "espectro completo do vermelho) em sei"
#~ " valores, nós precisaremos construir um "
#~ "algoritmo que toma qualquer valor de "
#~ "entrada mas que faz com que os "
#~ "valores de saída sejam apenas seis "
#~ "possíveis, como ilustrado pela imagem a"
#~ " direita. Nós queremos incluir o zero"
#~ " como o preto puro, com cinco "
#~ "outras cores nesse entremeio. A "
#~ "abordagem produz  {0, 0.2, 0.4, 0.6, "
#~ "0.8, 1}. Dividindo 1.0 por 5 "
#~ "resulta em 0.2, o que expressa a"
#~ " quantidade de separação que cada "
#~ "valor quantificado terá em relação aos"
#~ " outros."

#~ msgid ""
#~ "So, to get good even shading, we"
#~ " want to take values that are "
#~ "0.16 or less and map them to "
#~ "0.0; values between 0.16 and 0.33 "
#~ "get fixed to 0.2; color values "
#~ "between 0.33 and 0.5 get quantized "
#~ "to 0.4, and so on up to "
#~ "values between 0.83 and 1.0 get "
#~ "mapped to 1.0."
#~ msgstr ""
#~ "Portanto, para obtenção de tonalidades "
#~ "de sombreamento distribuídas de maneira "
#~ "mais equânime, nós queremos tomar "
#~ "valores que são 0.16 ou menos e"
#~ " mapeá-los para 0.0; valores entre "
#~ "0.16 e 0.33 serão fixos em 0.2;"
#~ " os valores das faixas de cores "
#~ "entre 0.33 e 0.5 serão quantizados "
#~ "para 0.4, e dessa maneira em "
#~ "diante, subindo para outros valores "
#~ "entre 0.83 e 1.0 teremos o "
#~ "mapeamento para 1.0."

#~ msgid "Function f(x)"
#~ msgstr "Função f(x)"

#~ msgid ""
#~ "An algebraic function is made up "
#~ "of primitive mathematical operations (add, "
#~ "subtract, multiply, sine, cosine, etc.) "
#~ "that operate on an input value to"
#~ " provide the desired output value."
#~ msgstr ""
#~ "Uma função algébrica é composta de "
#~ "algumas operações matemáticas primitivas "
#~ "(adicionar, subtrair, multiplicar, seno, "
#~ "cosseno, etc.) que operam em um "
#~ "valor de entrada para fornecer o "
#~ "valor de saída desejado."

#~ msgid ""
#~ "`Spreadsheet showing a function "
#~ "<https://wiki.blender.org/index.php/File:Manual-Compositing-"
#~ "Node-Math_spreadsheet>`__."
#~ msgstr ""
#~ "`Tabela de cálculo mostrando a função"
#~ " <https://wiki.blender.org/index.php/File:Manual-"
#~ "Compositing-Node-Math_spreadsheet>`__."

#~ msgid ""
#~ "The theory behind this function is "
#~ "scaled truncation. Suppose we want a "
#~ "math function that takes in a "
#~ "range of values between 0 and 1,"
#~ " such as 0.552, but only outputs "
#~ "a value of 0.0, 0.2, 0.4, etc. "
#~ "We can imagine then that we need"
#~ " to get that range 0 to 1 "
#~ "powered up to something 0 to 6 "
#~ "so that we can chop off and "
#~ "make it a whole number. So, with"
#~ " six divisions, how can we do "
#~ "that? The answer is we multiply "
#~ "the range by 6. The output of "
#~ "that first math Multiply Node is a"
#~ " range of values between 0 and "
#~ "6. To get even divisions, because "
#~ "we are using the rounding function "
#~ "(see documentation above), we want any"
#~ " number plus or minus around a "
#~ "whole number will get rounded to "
#~ "that number. So, we subtract a "
#~ "half, which shifts everything over. The"
#~ " round() function then makes that "
#~ "range 0 to 5. We then divide "
#~ "by 5 to get back a range of"
#~ " numbers between 0 and 1 which "
#~ "can then be combined back with the"
#~ " other color channels. Thus, you get"
#~ " the function :math:`f(x, n) = "
#~ "round(x × n - 0.5)/ (n - 1)`"
#~ " where \"n\" is the number of "
#~ "possible output values, and \"x\" is "
#~ "the input pixel color and :math:`f(x,"
#~ " n)` is the output value. There "
#~ "is only one slight problem, and "
#~ "that is for the value exactly "
#~ "equal to 1, the formula result is"
#~ " 1.2, which is an invalid value. "
#~ "This is because the round function "
#~ "is actually a roundup function, and "
#~ "exactly 5.5 is rounded up to 6."
#~ " So, by subtracting 0.501, we "
#~ "compensate and thus 5. 499 is "
#~ "rounded to 5. At the other end "
#~ "of the spectrum, pure black, or 0,"
#~ " when 0.501 subtracted, rounds up to"
#~ " 0 since the Round() function does"
#~ " not return a negative number."
#~ msgstr ""
#~ "A teoria por detrás desta função é"
#~ " a truncagem escalonada. Suponha que "
#~ "nós quiséssemos uma função matemática "
#~ "que toma um intervalo de valores "
#~ "entre 0 e 1, como 0.552, mas "
#~ "que somente resultasse em saídas com "
#~ "valores em passos, como 0.0, 0.2, "
#~ "0.4, etc. Nós poderíamos imaginar então"
#~ " que nós precisaremos elevar esta "
#~ "amplitude de 0 a 1 aumentando-a "
#~ "para algo entre 0 e 6 de "
#~ "maneira que possamos cortá-la em outros"
#~ " passos e torná-la novamente um "
#~ "número inteiro. Portanto, com seis "
#~ "divisões, como poderíamos fazer isso ?"
#~ " A resposta é que devemos multiplicar"
#~ " a amplitude por 6. A saída "
#~ "disso inicialmente precisará do nó do"
#~ " tipo \"Matemática\" com uma função "
#~ "de multiplicação para retornar valores "
#~ "na amplitude entre 0 e 6. Para "
#~ "obtenção de divisões equânimes, por "
#~ "estarmos usando a função de "
#~ "arredondamento (veja a documentação acima),"
#~ " nós queremos quaisquer números que "
#~ "somados ou subtraídos de números "
#~ "inteiros serão arredondados para estes "
#~ "números. Portanto, nós subtrairemos a "
#~ "metade, o que irá alterar todos os"
#~ " valores. A função *Arredondamento()* então"
#~ " tornará esta amplitude em valores "
#~ "entre 0 e 5. Então dividiremos "
#~ "isso por 5 para ter de volta "
#~ "os números na faixa entre 0 e "
#~ "1 que então poderão ser combinados "
#~ "novamente com os outros canais de "
#~ "cores. Portanto, você terá a função "
#~ "matemática :math:`f(x, n) = round(x ×"
#~ " n - 0.5)/ (n - 1)` onde "
#~ "\"n\" é o número possível dos "
#~ "valores de saída, e \"x\" é a "
#~ "cor dos pixeis de entrada e  "
#~ ":math:`f(x, n)` é o valor de "
#~ "saída. Existe um único e pequeno "
#~ "problema: Para os valores que são "
#~ "exatamente iguais a 1, o resultado "
#~ "da fórmula será 1.2, que é um "
#~ "valor inválido. Isto é por que a"
#~ " função de arredondamento é atualmente "
#~ "uma função de arredondamento para cima,"
#~ " e 5.5 é arredondado exatamente para"
#~ " 6. Portanto, pela subtração de "
#~ "0.501, nós faremos uma compensação e "
#~ "5.499 será arredondado para 5. Na "
#~ "outra ponta do espectro, a cor que"
#~ " resulta no preto puro, ou 0, "
#~ "quando 0.501 é subtraído, arredondará "
#~ "para 0 pois a função \"round()\" "
#~ "não retorna um número negativo."

#~ msgid ""
#~ "Sometimes using a spreadsheet can help"
#~ " you figure out how to put "
#~ "these nodes together to get the "
#~ "result that you want. Stepping you "
#~ "through the formula for :math:`n = "
#~ "6` and :math:`x = 0.70`, locate "
#~ "the line on the spreadsheet that "
#~ "has the 8-bit value 179 and R "
#~ "value 0.7. Multiplying by 6 gives "
#~ "4.2. Subtracting 1/2 gives 3.7, which"
#~ " rounds up to 4.4 divided by 5"
#~ " = 0.8. Thus, f(0.7, 6) = 0.8"
#~ " or an 8-bit value of 204. You"
#~ " can see that this same 8-bit "
#~ "value is output for a range of "
#~ "input values."
#~ msgstr ""
#~ "Algumas vezes, o uso de uma tabela"
#~ " de cálculo pode ajudar você a "
#~ "entender como colocar estes nós em "
#~ "conjunto para obter o resultado que "
#~ "deseja. Caminhando (traçando) a fórmula "
#~ "para  :math:`n = 6` e :math:`x ="
#~ " 0.70`, localize a linha na tabela"
#~ " de cálculo que possui o valor "
#~ "de 8 bits em 179 e o valor"
#~ " para o vermelho em 0.7. A "
#~ "multiplicação por 6 resulta em 4.2. "
#~ "A subtração de sua metade resulta "
#~ "em 3.7, o que arredonda para 4.4,"
#~ " que quando dividido por 5 , "
#~ "resulta em 0.8. Portanto, f(0.7, 6) "
#~ "= 0.8 ou um valor de 8 bits"
#~ " de 204. Você pode pode ver que"
#~ " esse mesmo valor de 8 bits é"
#~ " a saída para um intervalo de "
#~ "valores de entrada."

#~ msgid "Reality"
#~ msgstr "Realidade"

#~ msgid ""
#~ "To implement this function in Blender,"
#~ " consider the node setup above. "
#~ "First, feed the image to the "
#~ "Separate RGB node. For the Red "
#~ "channel, we string the math nodes "
#~ "into a function that takes each "
#~ "red color, multiplies (scales) it up "
#~ "by the desired number of divisions "
#~ "(6), offsets it by 0.5, rounds the"
#~ " value to the nearest whole number,"
#~ " and then divides the image pixel "
#~ "color by 5. So, the transformation "
#~ "is {0 to 1} becomes {0 to "
#~ "6}, subtracting centers the medians to"
#~ " {-0.5 to 5.5} and the rounding "
#~ "to the nearest whole number produces "
#~ "{0, 1, 2, 3, 4, 5} since the"
#~ " function rounds down, and then "
#~ "dividing by five results in six "
#~ "values {0.0, 0.2, 0.4, 0.6, 0.8, "
#~ "1.0}."
#~ msgstr ""
#~ "Para implementar esta função no Blender,"
#~ " considere a configuração do nó "
#~ "acima. Primeiramente, alimente a imagem "
#~ "através de um nó do tipo \"Separar"
#~ " RGB\". Para o canal vermelho, nós"
#~ " passamos aos nós de matemática uma"
#~ " função que obtém cada tonalidade de"
#~ " vermelho, a multiplica (escalona) por "
#~ "um número desejado de divisões (6), "
#~ "a deslocamos em 0.5, e arredondamos "
#~ "o valor para o número inteiro mais"
#~ " próximo, e então dividimos as cores"
#~ " dos pixeis da imagem por 5. "
#~ "Portanto, as transformações que estavam "
#~ "entre { 0 e 1 }  estarão "
#~ "agora em um intervalo entre { 0"
#~ " e 6 }. Subtraindo os centros "
#~ "das cores medianas para valores situados"
#~ " entre  {-0.5 e 5.5} e arredondando"
#~ " para o número inteiro mais próximo"
#~ " produzirá valores na escala { 0, "
#~ "1, 2, 3, 4, 5 } devido ao"
#~ " fato da função arredondar ao menor,"
#~ " e então a divisão por cinco "
#~ "resultará em seis escalas de valores:"
#~ " {0.0, 0.2, 0.4, 0.6, 0.8, 1.0}."

#~ msgid ""
#~ "The result is that the output "
#~ "value can only be one of a "
#~ "certain set of values, stair-stepped,"
#~ " because of the rounding function of"
#~ " the math node. Copying this one "
#~ "channel to operate on Green and "
#~ "Blue gives the node setup below. "
#~ "To get the 6:6:7, we set the "
#~ "three Multiply Nodes to {6, 6, 7}"
#~ " and the divide nodes to {5, 5,"
#~ " 6}."
#~ msgstr ""
#~ "O resultado é que o valor de "
#~ "saída pode ser apenas de um tipo"
#~ " dentre um conjunto de valores, "
#~ "usando uma escala com divisões "
#~ "definidas, por conta da função de "
#~ "arredondamento do nó do tipo "
#~ "*Matemática* e de sua configuração. A"
#~ " cópia deste canal único para operar"
#~ " nos canais Verde e Azul resulta "
#~ "na configuração do nó mostrado abaixo."
#~ " Para obter valores 6:6:7, nós "
#~ "definimos os nós de multiplicação para"
#~ " {6, 6, 7} e os nós de "
#~ "divisão para {5, 5, 6}."

#~ msgid ""
#~ "If you make this into a node "
#~ "group, you can easily reuse this "
#~ "setup from project to project. When "
#~ "you do, consider using a math node"
#~ " to drive the different values that"
#~ " you would have to otherwise set "
#~ "manually, just to error-proof your "
#~ "work."
#~ msgstr ""
#~ "Caso você torne isso em um grupo"
#~ " de nós, você poderá facilmente "
#~ "reutilizar esta configuração de projeto "
#~ "para projeto. Quando fizer isso, "
#~ "considere usar um nó do tipo "
#~ "*Matemática* para controlar os diferentes "
#~ "valores que em outros casos você "
#~ "deveria definir manualmente, simplesmente para"
#~ " tornar seu trabalho a prova de "
#~ "falhas."

#~ msgid "Summary"
#~ msgstr "Sumário"

#~ msgid ""
#~ "Normally, an output render consists of"
#~ " 32- or 24-bit color depth, and "
#~ "each pixel can be one of the "
#~ "millions of possible colors. This node"
#~ " setup example takes each of the "
#~ "Red, Green and Blue channels and "
#~ "normalizes them to one of a few"
#~ " values. When all three channels are"
#~ " combined back together, each color "
#~ "can only be one of 256 possible"
#~ " values."
#~ msgstr ""
#~ "Normalmente, uma saída de renderização "
#~ "consiste em uma profundidade de cores"
#~ " entre 24 e 32 bits, e cada "
#~ "pixel pode ser apresentado através de"
#~ " uma das milhões de cores possíveis."
#~ " Este exemplo de configuração de nó,"
#~ " toma cada um dos canais de "
#~ "vermelho, verde e azul e os "
#~ "normaliza para alguns dos poucos "
#~ "valores. Quando todos os três canais "
#~ "são combinados em conjunto, cada uma "
#~ "das cores pode ser um dos 256 "
#~ "valores possíveis."

#~ msgid ""
#~ "While this example uses the "
#~ "Separate/Combine RGB to create distinct "
#~ "colors, other Separate/Combine nodes can "
#~ "be used as well. If using the "
#~ "YUV values, remember that U and V"
#~ " vary between (-0.5 to +0.5), so "
#~ "you will have to first add on "
#~ "a half to bring the range between"
#~ " 0 and 1, and then after "
#~ "dividing, subtract a half to bring "
#~ "in back into standard range."
#~ msgstr ""
#~ "Enquanto esse exemplo utiliza os nós "
#~ "do tipo \"Combinar RGB\" e \"Separar "
#~ "RGB\" para criar cores distintas, outros"
#~ " nós para \"Separar\" e \"Combinar\" "
#~ "também podem ser usados. Caso esteja "
#~ "utilizando os valores YUV, lembre-se "
#~ "que as grandezas U e V variam "
#~ "no intervalo entre  (-0.5 to +0.5), "
#~ "portanto você deve inicialmente adicionar "
#~ "a metade de 1.0 para posicionar "
#~ "essa grandeza no intervalo entre 0 "
#~ "e 1, e então, após a divisão, "
#~ "subtrair a metade de 1 novamente "
#~ "para reposicioná-la em seu intervalo de"
#~ " amplitude padrão."

#~ msgid ""
#~ "The ``JPG`` or ``PNG`` image format "
#~ "will store each of the colors "
#~ "according to its image standard for "
#~ "color depth (e.g. ``JPG`` is 24-bit),"
#~ " but the image will be very "
#~ "small since reducing color depth and "
#~ "quantizing colors are essentially what "
#~ "the ``JPEG`` compression algorithm "
#~ "accomplishes."
#~ msgstr ""
#~ "Os formatos de imagem em  ``JPG`` "
#~ "ou ``PNG`` irão guardar cada uma "
#~ "das cores de acordo com seus "
#~ "padrões de imagem para a profundidade"
#~ " de cores  (por exemplo, ``JPG`` usa"
#~ " até 24 bits), mas a imagem "
#~ "será bem pequena,  devido ao fato "
#~ "de que a redução da profundidade "
#~ "de cores e a quantização de cores"
#~ " são essencialmente o que o algoritmo"
#~ " de compressão  ``JPEG`` realiza."

#~ msgid ""
#~ "You do not have to reduce the "
#~ "color depth of each channel evenly. "
#~ "For example, if blue was the "
#~ "dominant color in an image, to "
#~ "preserve image quality, you could reduce"
#~ " Red to 2 values, Green to 4,"
#~ " and let the blue take on "
#~ ":math:`256/(2 × 4)` or 32 values. "
#~ "If using the HSV, you could reduce"
#~ " the Saturation and Value to 2 "
#~ "values (0 or 1.0) by Multiply by"
#~ " 2 and Divide by 2, and "
#~ "restrict the Hue to 64 possible "
#~ "values."
#~ msgstr ""
#~ "Você não tem de reduzir a "
#~ "profundidade de cores de cada um "
#~ "dos canais de maneira uniforme. Por "
#~ "exemplo, caso o azul seja a cor"
#~ " dominante em uma imagem, para "
#~ "preservar a qualidade de imagem, você"
#~ " pode reduzir o vermelho em 2 "
#~ "valores, o verde para 4 e permitir"
#~ " que o azul esteja em toda a"
#~ " escala de :math:`256/(2 × 4)` ou "
#~ "32 valores. Caso esteja utilizando o "
#~ "nó do tipo \"Matiz, saturação e "
#~ "valor\", você pode reduzir o valor "
#~ "e a saturação para apenas dois "
#~ "valores (0 ou 1) multiplicando-os "
#~ "por 2 e dividindo-os por 2, "
#~ "e restringir a matiz para os 64"
#~ " valores possíveis."

#~ msgid ""
#~ "You can use this node setup to "
#~ "quantize any channel; alpha, speed "
#~ "(vector), Z values, and so forth."
#~ msgstr ""
#~ "Você pode usar esta configuração de "
#~ "nós para quantizar quaisquer canais, "
#~ "alfa, velocidade (vetor), valores-Z, dentre"
#~ " outros."

#~ msgid ""
#~ "To implement this function in Blender,"
#~ " consider the node setup above. We"
#~ " string the math nodes into a "
#~ "function that takes each color (values"
#~ " from 0 to 1), multiplies it up"
#~ " by six, the desired number of "
#~ "divisions (values becomes from 0 to "
#~ "6), offsets it by 0.5 (-0.5 to "
#~ "5.5), rounds the value to the "
#~ "nearest whole number (produces 0, 1, "
#~ "2, 3, 4, 5), and then divides "
#~ "the image pixel color by five "
#~ "(0.0, 0.2, 0.4, 0.6, 0.8, 1.0)."
#~ msgstr ""

