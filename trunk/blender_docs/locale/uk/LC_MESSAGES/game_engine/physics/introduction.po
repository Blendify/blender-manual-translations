# SOME DESCRIPTIVE TITLE.
# Copyright (C) : This page is public domain as CC0
# This file is distributed under the same license as the Blender Reference
# Manual package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
# urko <urkokul@gmail.com>, 2018.
#
msgid ""
msgstr ""
"Project-Id-Version: Blender 2.78 Manual 2.78\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-06 21:41+1100\n"
"PO-Revision-Date: 2018-02-19 03:41+0200\n"
"Last-Translator: urko <urkokul@gmail.com>\n"
"Language: uk\n"
"Language-Team: \n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"
"X-Generator: Poedit 2.0.6\n"

#: ../../manual/game_engine/physics/introduction.rst:3
msgid "Introduction"
msgstr "Вступ"

#: ../../manual/game_engine/physics/introduction.rst:6
msgid "Blender includes advanced physics simulation in the form of the Bullet Physics Engine (`Bullet Physics <http://bulletphysics.org>`__). Most of your work will involve setting the right properties on the objects in your scene, then you can sit back and let the engine take over. The physics simulation can be used for Games, but also for Animation."
msgstr "Blender включає просунуту імітацію, симуляцію фізики у формі рушія фізики Bullet Physics Engine (`Bullet Physics <http://bulletphysics.org>`__). Більшість вашої роботи передбачатиме установлення правильних властивостей на об'єктах у вашій сцені, далі ви можете сидіти, склавши руки, та дозволити рушію зробити все інше. Імітація фізики може використовуватися для Ігор, а також для Анімації."

#: ../../manual/game_engine/physics/introduction.rst:12
msgid "The Blender Game Engine (BGE) is based on Rigid-Body Physics, which differs significantly from the complementary set of tools available in the form of Soft Body Physics Simulations. Though the BGE does have a Soft Body type, it is not nearly as nuanced as the non-BGE Soft Body. The inverse is even more true: it is difficult to get the non-BGE physics to resemble anything like a stiff shape. Rigid Body Physics does not have, as an effect or a cause, any mesh deformations. For a discussion on how to partially overcome this, see: `Mesh Deformations`_."
msgstr "Рушій Blender Game Engine (BGE) базується на фізиці твердого тіла -- Rigid-Body Physics, яка суттєво відрізняється від додаткового набору засобів, доступних у формі імітації фізики м'якого тіла -- Soft Body Physics. Хоча BGE має тип фізики Soft Body, але він не настільки деталізований як тип Soft Body не для BGE. Зворотне є навіть більш вірним: важко отримати не-BGE фізику, схожою на щось з жорсткою формою. Фізика твердого тіла -- Rigid Body Physics не має, як результат або як причину, будь-які деформування сіті. Для обговорення того, як це частково подолати, дивіться: `Mesh Deformations`_."

#: ../../manual/game_engine/physics/introduction.rst:23
msgid "Global Options"
msgstr "Глобальні Опції -- Global Options"

#: ../../manual/game_engine/physics/introduction.rst:26
msgid "The global Physics Engine settings can be found in the :doc:`World Properties </game_engine/physics/world>`, which include the Gravity constant and some important engine performance tweaks."
msgstr "Глобальні устави Рушія Фізики можна знайти тут -- :doc:`World Properties </game_engine/physics/world>`, які включають константу Гравітації та деякі важливі підправлення продуктивності рушія."

#: ../../manual/game_engine/physics/introduction.rst:30
msgid "Object Physics"
msgstr "Фізика Об'єкта -- Object Physics"

#: ../../manual/game_engine/physics/introduction.rst:35
msgid "See :ref:`game-engine-physics-types` in this chapter."
msgstr "Дивіться детальніше тут -- :ref:`game-engine-physics-types`."

#: ../../manual/game_engine/physics/introduction.rst:38
msgid "Material Physics"
msgstr "Фізика Матеріалу -- Material Physics"

#: ../../manual/game_engine/physics/introduction.rst:41
msgid "Physics can be associated with a material on the material properties tab. These are settings that one would normally associate with a material, such has its friction and they are meant to be used in conjunction with the object physics settings, not replace it."
msgstr "Фізика може бути асоційована з матеріалом на вкладці властивостей матеріалу. Ці устави, які зазвичай асоціюються з матеріалом, зокрема, його тертя, і вони призначені для використання у поєднанні з уставами фізики об'єкта, а не мають заміняти їх."

#: ../../manual/game_engine/physics/introduction.rst:47
msgid "Constraints"
msgstr "Примуси -- Constraints"

#: ../../manual/game_engine/physics/introduction.rst:50
msgid "It is imperative to understand that the Blender Constraints generally do not work inside the BGE. This means interesting effects such as *Copy Rotation* are unavailable directly."
msgstr "Слід категорично зрозуміти, що Примуси Blender'а зазвичай не працюють всередині BGE. Це означає, що цікаві ефекти, такі як *Copy Rotation*, є недоступні безпосередньо."

#: ../../manual/game_engine/physics/introduction.rst:53
msgid "Your options include:"
msgstr "Ваші доступні варіанти:"

#: ../../manual/game_engine/physics/introduction.rst:55
msgid ":doc:`Parenting </editors/3dview/object/properties/relations/parents>` - But not Vertex Parenting."
msgstr "Приріднення -- :doc:`Parenting </editors/3dview/object/properties/relations/parents>` - Але не приріднення до вершин -- Vertex Parenting."

#: ../../manual/game_engine/physics/introduction.rst:56
msgid ":doc:`Rigid Body Joint </rigging/constraints/relationship/rigid_body_joint>` -- This is the one Constraint that you can set up through the UI that works in the BGE. It has several options, and can be very powerful -- see ITS page for a detailed description and demo blend-file. Do not forget that you can loop through objects using ``bpy`` instead of clicking thousands of times to set up chains of these Constraints."
msgstr "Сполучення Твердого Тіла -- :doc:`Rigid Body Joint </rigging/constraints/relationship/rigid_body_joint>` -- Це єдиний Примус, який ви можете установити через інтерфейс користувача у BGE. Він має кілька опцій й може бути дуже потужним -- дивіться сторінку ITS для детального опису та демо blend-файл. Не забувайте, що ви можете зациклювати об'єкти за допомогою ``bpy``, замість клацання тисячі раз для укладання ланцюгів цих Примусів."

#: ../../manual/game_engine/physics/introduction.rst:61
msgid "Rigid Body Joints on the Fly -- You can add/remove them after the BGE starts by using ``bge.constraints.createConstraint()``. This can be good either to simply automate their setup, or to truly make them dynamic. A simple demo can be viewed in: `BGE-Physics-DynamicallyCreateConstraint.blend <https://wiki.blender.org/index.php/Media:BGE-Physics-DynamicallyCreateConstraint.blend>`__"
msgstr "Сполучення Твердого Тіла на Льоту -- Ви можете додавати/вилучати їх після запуску BGE за допомогою ``bge.constraints.createConstraint()``. Це може бути добрим, щоб просто автоматизувати їх уклад або по-справжньому зробити їх динамічними. Просте демо можна переглянути тут: `BGE-Physics-DynamicallyCreateConstraint.blend <https://wiki.blender.org/index.php/Media:BGE-Physics-DynamicallyCreateConstraint.blend>`__"

#: ../../manual/game_engine/physics/introduction.rst:66
msgid ":doc:`Python Controllers </game_engine/logic/controllers/types/python>` -- As always, in the BGE, you can get the most power when you drop into Python and start toying with the settings directly. For instance, the *Copy Rotation* mentioned above is not hard -- All you have to do is something to the effect of ``own.worldOrientation = bge.logic.getCurrentScene().objects['TheTargetObject'].worldOrientation``"
msgstr "Контролери Python -- :doc:`Python Controllers </game_engine/logic/controllers/types/python>` -- Як завжди, у BGE, ви можете отримати максимальну потужність, коли занурюєтеся у Python та починаєте гратися з уставами безпосередньо. Наприклад, примус *Copy Rotation*, згаданий вище, укласти не важко -- Все, що ви маєте зробити, -- це щось подібне на ефект -- ``own.worldOrientation = bge.logic.getCurrentScene().objects['TheTargetObject'].worldOrientation``"

#: ../../manual/game_engine/physics/introduction.rst:73
msgid "Visualizing Physics"
msgstr "Візуалізація Фізики -- Visualizing Physics"

#: ../../manual/game_engine/physics/introduction.rst:78
msgid "Go to :menuselection:`Game --> Show Physics Visualization` to show lines representing various attributes of the Bullet representation of your objects. Note that these might be easier to see when you turn on Wireframe Mode :kbd:`Z` before you press :kbd:`P`. Also note that you can see how the Bullet triangulation is working (it busts all your Quads to Tris at run-time, but the BGE meshes are still quads at run-time)."
msgstr "Увімкніть стяг :menuselection:`Game --> Show Physics Visualization` для показу ліній, що представляють різні атрибути представлення Bullet ваших об'єктів. Зауважте, що їх може бути легшим бачити, коли ви перемкнетеся у каркасний режим -- Wireframe Mode :kbd:`Z`, перед тим, як натиснете :kbd:`P`. Також, зверніть увагу, що ви можете бачити, як трибічникування, тріангуляція Bullet працює (це дасть при виконанні перетворення чотирибічників у трибічники, але сіті BGE все ще залишатимуться чотирибічними)."

#: ../../manual/game_engine/physics/introduction.rst:85
msgid "*RGB/XYZ Widget* -- Representing the object's Local Orientation and Origin."
msgstr "Віджет *RGB/XYZ Widget* -- Представлення Локальних Орієнтації та Початку об'єкта."

#: ../../manual/game_engine/physics/introduction.rst:86
msgid "*Green* -- \"sleeping meshes\" that are not moving, saving calculations until an external event \"wakes\" them."
msgstr "*Зелений* -- «сплячі сіті», що не рухаються, зберігають розрахування, допоки зовнішня подія «не розбудить» їх."

#: ../../manual/game_engine/physics/introduction.rst:87
msgid "*White* -- White lines represent active bounding meshes at are undergoing physics calculations, until such calculations are so small that the object is put to rest. This is how you can see the effects of the *Collision Bounds*. - *Thick*, or *Many White Lines* -- A compound collision mesh/meshes."
msgstr "*Білий* -- Білі лінії представляють активні межові сіті у процесі розрахування фізики, допоки такі розрахування є такі малі, що об'єкт залишається у спокої. Це те, як ви можете бачити ефекти меж зіткнення -- *Collision Bounds*. - *Товсті* або *Багато Білих Ліній* -- складене зіткнення сіті/сітей."

#: ../../manual/game_engine/physics/introduction.rst:91
msgid "*Violet* -- Bounding meshes for Soft bodies."
msgstr "*Фіолетовий* -- Межові сіті для М'яких тіл."

#: ../../manual/game_engine/physics/introduction.rst:92
msgid "*Red* -- The Bounding Box, the outer boundary of object. It is always aligned with global X Y and Z, and is used to optimize calculations. Also represents meshes that have been forced into \"no sleep\" status."
msgstr "*Червоний* -- Габаритна Коробка (Bounding Box), зовнішня границя об'єкта. Вона завжди вирівнюється по глобальних X Y та Z та використовується для оптимізації розрахунків. Також представляє сіті, що були примушені бути у «не сплячому» стані."

#: ../../manual/game_engine/physics/introduction.rst:95
msgid "*Yellow* -- Normals."
msgstr "*Жовтий* -- Нормалі."

#: ../../manual/game_engine/physics/introduction.rst:96
msgid "*Black* -- When in wireframe, this is your mesh's visual appearance."
msgstr "*Чорний* -- Коли у каркасному режимі, це візуальний вигляд вашої сіті."

#: ../../manual/game_engine/physics/introduction.rst:98
msgid "If you want finer-grained control over the display options, you can add this as a Python Controller and uncomment whichever pieces you want to see::"
msgstr "Якщо ви хочете більш детальне керування опціями показу, ви можете додати їх як контролер Python та розкоментувати частини, які ви хочете бачити::"

#: ../../manual/game_engine/physics/introduction.rst:108
msgid "For all debug modes, API docs for ``bge.constraints``."
msgstr "Для усіх режимів налагодження, документація API для ``bge.constraints``."

#: ../../manual/game_engine/physics/introduction.rst:111
msgid "Show Framerate and Profile"
msgstr "Показати Частоту кадрів та Профіль -- Show Framerate and Profile"

#: ../../manual/game_engine/physics/introduction.rst:116
msgid "A shot of `Manual-BGE-Physics-DancingSticks.blend <https://wiki.blender.org/index.php/Media:Manual-BGE-Physics-DancingSticks.blend>`__ with :menuselection:`Game --> Show Framerate and Profile` enabled."
msgstr "Знімок вікна з файлом `Manual-BGE-Physics-DancingSticks.blend <https://wiki.blender.org/index.php/Media:Manual-BGE-Physics-DancingSticks.blend>`__ з увімкненим :menuselection:`Game --> Show Framerate and Profile`."

#: ../../manual/game_engine/physics/introduction.rst:120
msgid "If you enable :menuselection:`Game --> Show Framerate and Profile`, it will put some statistics in the upper-left area of the game window."
msgstr "Якщо ви увімкнете :menuselection:`Game --> Show Framerate and Profile`, то це поставить деяку статистику у верхню ліву частину вікна гри."

#: ../../manual/game_engine/physics/introduction.rst:125
msgid "These can be very informative, but also a bit cryptic. Moguri has elaborated on their meanings, for us: `Moguri's blog <https://mogurijin.wordpress.com/2012/01/03/bge-profile-stats-and-what-they-mean/>`__."
msgstr "Ці записи можуть бути дуже інформативними, але також трохи загадковими. Moguri розробив їх значення для нас: `Moguri's blog <https://mogurijin.wordpress.com/2012/01/03/bge-profile-stats-and-what-they-mean/>`__."

#: ../../manual/game_engine/physics/introduction.rst:129
msgid "Mesh Deformations"
msgstr "Деформування Сіті -- Mesh Deformations"

#: ../../manual/game_engine/physics/introduction.rst:132
msgid "As mentioned above, Rigid Body physics do not affect mesh deformations, nor do they account for them in the physics model. This leaves you with a few options:"
msgstr "Як згадувалося вище, фізики Rigid Body не впливає на деформування сіті й останні не враховуються у моделі фізики. Це залишає вам кілька варіантів:"

#: ../../manual/game_engine/physics/introduction.rst:136
msgid "Soft Bodies"
msgstr "М'які Тіла -- Soft Bodies"

#: ../../manual/game_engine/physics/introduction.rst:139
msgid "You can try using a :doc:`Soft Body </game_engine/physics/types/soft_body>`, but these are fairly hard to configure well."
msgstr "Ви можете спробувати використовувати м'які тіла -- :doc:`Soft Body </game_engine/physics/types/soft_body>`, але конфігурувати досить складно."

#: ../../manual/game_engine/physics/introduction.rst:143
msgid "Actions"
msgstr "Дії -- Actions"

#: ../../manual/game_engine/physics/introduction.rst:146
msgid "To use an :doc:`Action Actuator </game_engine/logic/actuators/types/action>` to do the deformation, you have to make a choice. If you use Shapekeys in the Action, you will be fine as far as the overall collisions (but see below for the note on ``reinstancePhysicsMesh()``). The mesh itself is both a display and a physics mesh, so there is not much to configure."
msgstr "Щоб скористатися актуатором -- :doc:`Action Actuator </game_engine/logic/actuators/types/action>` для зроблення такого деформування, ви повинні зробити вибір. Якщо ви використовуєте ключі форм -- Shapekeys у дії -- Action, то це настільки ж добре, як вжити загальні зіткнення (але дивіться нижче примітку про ``reinstancePhysicsMesh()``). Сама сіть є показуваною та фізичною сіттю, а тому конфігурувати вже не так і багато."

#: ../../manual/game_engine/physics/introduction.rst:151
msgid "To use an Armature as the deformer will require a bit of extra thought and effort. Basically the Armature will only deform a mesh if the Armature is the parent of that mesh. But at that point, your mesh will lose its physics responsiveness, and only hang in the air (it is copying the location/rotation of the Armature). To somewhat fix this you can then parent the Armature to a collision mesh (perhaps a simple box or otherwise very-low-poly mesh). This \"Deformation Mesh\" will be the physics representative, being type: Dynamic or Rigid Body, but it will be set to Invisible. Then \"Display Mesh\" will be the opposite set to *No Collision*, but visible. This still leaves the problem mentioned in the previous paragraph."
msgstr "Для використання арматури Armature як деформера буде потрібно трохи більше роздумувань та зусиль. Базово Armature буде деформувати тільки сіть, якщо Арматура є предком для такої сіті. Але у такий момент, ваша сіть буде втрачати її фізичну чутливість і буде лише висіти у повітрі (вона копіює локацію/оберт Арматури). Для деякого виправлення цього ви можете далі приріднити Арматуру до сіті зіткнення (можливо простої коробки або іншої сіті з дуже малою кількістю полігонів). Ця «Сіть Деформування» буде представником фізики, будучи типом: Dynamic або Rigid Body, але установлена як Невидима. Далі «Показувана Сіть» буде навпаки задана як *Без Зіткнення*, але видима. Це все ще залишає проблему, згадану у попередньому параграфі."

#: ../../manual/game_engine/physics/introduction.rst:161
msgid "When you deform a display mesh, it does not update the corresponding physics mesh. You can view this evidently when you enable physics visualization (`Visualizing Physics`_) -- the collision bounds will remain exactly as when they began. To fix this, you must call ``own.reinstancePhysicsMesh()`` in some form. Currently this only works on *Triangle Mesh* bounds, not *Convex Hull*. We have prepared a demonstration file in `Manual-BGE-Physics-DancingSticks.blend <https://wiki.blender.org/index.php/Media:Manual-BGE-Physics-DancingSticks.blend>`__. Note that, we had to increase the :menuselection:`World --> Physics --> Physics Steps --> Substeps` to make the collisions work well. The more basic case is the case the Shapekeyed Action, which you can see in the back area of the scene. Since it is the only object involved, you can call ``reinstancePhysicsMesh()`` unadorned, and it will do the right thing."
msgstr "Коли ви деформуєте показувану сіть, то це не оновлює відповідну фізичну сіть. Ви можете це явно бачити, коли увімкнете візуалізацію фізики (`Visualizing Physics`_) -- межі зіткнення будуть залишатися точно такими, як на початку. Для виправлення цього ви повинні викликати ``own.reinstancePhysicsMesh()`` в якійсь формі. Поточно це працює тільки для меж трибічникової сіті -- *Triangle Mesh*, а не для опуклої оболонки -- *Convex Hull*. Ми підготували демонстраційний файл -- `Manual-BGE-Physics-DancingSticks.blend <https://wiki.blender.org/index.php/Media:Manual-BGE-Physics-DancingSticks.blend>`__. Зауважте, що ми підвищили уставу :menuselection:`World --> Physics --> Physics Steps --> Substeps`, що примусити зіткнення добре працювати. Більш базовий випадок -- дія з ключами форм -- Shapekeyed Action, яку ви можете бачити у задній області сцени. Оскільки задіяно лише один об'єкт, то ви можете викликати ``reinstancePhysicsMesh()`` без аргументів і він зробить це правильно."

#: ../../manual/game_engine/physics/introduction.rst:175
msgid "The more complicated case is the :menuselection:`Collision Mesh --> Armature --> Display Mesh` cluster, which you can see in the front of the scene. What it does in the blend-file is call ``reinstancePhysicsMesh(viz)``, that is, passing in a reference to the visual mesh. If we tried to establish this relationship without the use of Python, we would find that Blender's dependency check system would reject it as a cyclic setup. This is an example of where Blender's checking is too coarsely-grained, as this circle is perfectly valid: the grandparent object (the Collision Mesh) controls the location/rotation, while the middle object (the Armature) receives the animated Action, where the child (the Display Mesh) receives the deformation, and passes that on up to the top, harmlessly. Something to note is that the Collision Mesh is merely a plane -- that is all it requires for this, since it will be getting the mesh data from ``viz``."
msgstr "Більш складний випадок -- кластер :menuselection:`Collision Mesh --> Armature --> Display Mesh`, який ви можете бачити у передній області сцени. Те, що він робить у цьому blend-файлі -- це виклик ``reinstancePhysicsMesh(viz)``, тобто, передавання посилання на візуальну сіть. Якщо ми б намагалися встановити це відношення без використання Python, то ми виявили б, що система перевірки залежностей у Blender'а відкинула його як зациклений уклад. Це приклад того, де перевірка Blender'а є надто груба, оскільки ця зацикленість є ідеально допустимою: об'єкт-предок вищого рівня (ця Сіть Зіткнення) керує локацією/обертанням, тоді як предок рівня під ним -- середній об'єкт (ця Арматура) приймає анімовану Дію, а нащадок (ця Показувана Сіть) отримує деформування та передає його нагору без шкоди. Слід зауважити, що Сіть Зіткнення є просто площиною -- тобто, це все, що вимагається тут, оскільки вона отримує дані сіті від ``viz``."

#: ../../manual/game_engine/physics/introduction.rst:190
msgid "Ragdolls"
msgstr "«Ганчіркові ляльки» -- Ragdolls"

#: ../../manual/game_engine/physics/introduction.rst:193
msgid "A third option is to create your items out of many sub-objects, connected together with Rigid Body Joints or similar. This can be quite a bit more work, but the results can be much more like a realistic response to collisions. For an Add-on that can help you out in the process, check out the `Blender Ragdoll Implementation Kit <https://wiki.blender.org/index.php/Extensions:2.6/Py/Scripts/Game_Engine/BRIK_ragdolls>`__."
msgstr "Третій варіант -- створити об'єкти з багатьох під-об'єктів, з'єднаних між собою за допомогою Rigid Body Joint або подібним чином. Це може вимагати трохи більше роботи, але результати можуть бути більш подібними на реалістичну реакцію на зіткнення. Про Додаток, що може допомогти вам у цьому процесі, дивіться тут -- `Blender Ragdoll Implementation Kit <https://wiki.blender.org/index.php/Extensions:2.6/Py/Scripts/Game_Engine/BRIK_ragdolls>`__."

#: ../../manual/game_engine/physics/introduction.rst:202
msgid "Digging Deeper"
msgstr "Копання Глибше -- Digging Deeper"

#: ../../manual/game_engine/physics/introduction.rst:205
msgid "Sometimes you will want to look at:"
msgstr "Іноді ви схочете подивитися тут:"

#: ../../manual/game_engine/physics/introduction.rst:207
msgid "The `main Bullet Physics page <http://bulletphysics.org/wordpress/>`__"
msgstr "The `main Bullet Physics page <http://bulletphysics.org/wordpress/>`__"

#: ../../manual/game_engine/physics/introduction.rst:208
msgid "The `Bullet Wiki <http://www.bulletphysics.org/mediawiki-1.5.8/index.php?title=Documentation>`__"
msgstr "The `Bullet Wiki <http://www.bulletphysics.org/mediawiki-1.5.8/index.php?title=Documentation>`__"

#: ../../manual/game_engine/physics/introduction.rst:209
msgid "The `Bullet API Docs <http://www.continuousphysics.com/Bullet/BulletFull/index.html>`__"
msgstr "The `Bullet API Docs <http://www.continuousphysics.com/Bullet/BulletFull/index.html>`__"

#: ../../manual/game_engine/physics/introduction.rst:210
msgid "The `Bullet Forums <http://www.bulletphysics.org/Bullet/phpBB3/>`__"
msgstr "The `Bullet Forums <http://www.bulletphysics.org/Bullet/phpBB3/>`__"

#: ../../manual/game_engine/physics/introduction.rst:213
msgid "Recording to Keyframes"
msgstr "Записування у Ключкадри -- Recording to Keyframes"

#: ../../manual/game_engine/physics/introduction.rst:216
msgid "Beyond gaming, sometimes you wish to render a complex scene that involves collisions, multiple forces, friction between multiple bodies, and air drag or even a simple setup that is just easier to achieve using the realtime physics."
msgstr "Поза іграми, інколи ви схочете рендерити складну сцену, що задіює зіткнення, одночасно кілька сил, тертя між одночасно кількома тілами та опір повітря чи навіть простий уклад, що просто легше досягти, використовуючи реально-часову фізику."

#: ../../manual/game_engine/physics/introduction.rst:220
msgid "Blender provides a way to ''bake'' or ''record'' a physics simulation into keyframes allowing it then to be played as an action either for animation or games. Keep in mind that the result of this method is a recording, no longer a simulation. This means that the result is completely deterministic (the same every time it is run) and unable to interact with new objects that are added to the physics simulation after it was recorded. This may, or not, be desired according to the situation."
msgstr "Blender надає спосіб «запікання» або «запису» імітації фізики у ключкадри, дозволяючи далі відтворювати її як дію для анімації або ігор. Майте на увазі, що результатом цьому методу буде запис, більше не імітація. Це означає, що цей результат є повністю детермінований (однаковий при кожному виконанні) і не у змозі взаємодіяти з новими об'єктами, що додаються в імітацію фізики після того, як вона була записана. Це можливо або ні бути бажаним, відповідно до ситуації."

#: ../../manual/game_engine/physics/introduction.rst:230
msgid "Menu to record Keyframes to the Dope Sheet."
msgstr "Пункт меню для запису Ключкадрів в Аркуші Експозицій -- Dope Sheet."

#: ../../manual/game_engine/physics/introduction.rst:232
msgid "All you have to do to achieve this effect is go to the Info Editor (the bar at the top of the window) :menuselection:`Game --> Record Animation`, and it will lock away your keyframes for use in *Blender Render* mode. You can go back to the 3D View and press :kbd:`Alt-A` to play it back, or :kbd:`Ctrl-F12` to render it out as an animation."
msgstr "Все, що вам потрібно зробити для досягнення цього ефекту, -- це перейти у редактор Info Editor (смуга вгорі вікна), увімкнути :menuselection:`Game --> Record Animation`, і це зблокує ваші ключкадри для використання у режимі *Blender Render*. Ви можете повернутися у редактор 3D View та натиснути :kbd:`Alt-A` для відтворення або :kbd:`Ctrl-F12` для рендерингу як анімації."

#: ../../manual/game_engine/physics/introduction.rst:238
msgid "Note that you can also use Game Logic Bricks and scripting. Everything will be recorded."
msgstr "Зауважте, що ви можете також використовувати цеглини логіки гри та скриптування. Все буде записано."

#: ../../manual/game_engine/physics/introduction.rst:241
msgid "Keyframe Clean-up"
msgstr "Вичищення Ключкадрів -- Keyframe Clean-up"

#: ../../manual/game_engine/physics/introduction.rst:246
msgid "Resulting recorded animation."
msgstr "Результатна записана анімація."

#: ../../manual/game_engine/physics/introduction.rst:248
msgid "*Record Animation* keys redundant data (data that was did not change relative to the last frame). Pressing :kbd:`O` while in the *Dope Sheet* will remove all superfluous keyframes. Unwanted channels can also be removed."
msgstr "*Запис Анімації* ключує зайві дані (дані, що не були змінені відносно останнього кадру). Натискання :kbd:`O` при знаходженні у режимі *Dope Sheet* вилучить усі ці зайві ключкадри. Небажані канали можуть також бути вилучені."

#: ../../manual/game_engine/physics/introduction.rst:254
msgid "Cleaned up recording."
msgstr "Вичищення запису."

#: ../../manual/game_engine/physics/introduction.rst:257
msgid "Exporting"
msgstr "Експортування -- Exporting"

#: ../../manual/game_engine/physics/introduction.rst:261
msgid ".bullet / Bullet Compatible Engines"
msgstr ".bullet / Bullet Compatible Engines"

#: ../../manual/game_engine/physics/introduction.rst:263
msgid "You can snapshot the physics world at any time with the following code::"
msgstr "Ви можете зазнімкувати світ фізики у будь-який момент за допомогою наступного коду::"

#: ../../manual/game_engine/physics/introduction.rst:269
msgid "This will allow importing into other Bullet-based projects. See the `Bullet Wiki on Serialization <http://bulletphysics.org/mediawiki-1.5.8/index.php/Bullet_binary_serialization>`__ for more."
msgstr "Це дозволить імпортувати його в інші проекти, що базуються на Bullet. Дивіться детальніше тут -- `Bullet Wiki on Serialization <http://bulletphysics.org/mediawiki-1.5.8/index.php/Bullet_binary_serialization>`__."
