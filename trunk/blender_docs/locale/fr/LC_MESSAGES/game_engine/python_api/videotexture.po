# SOME DESCRIPTIVE TITLE.
# Copyright (C) : This page is public domain as CC0
# This file is distributed under the same license as the Blender Reference
# Manual package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
# phan <phahoatho@gmail.com>, 2016, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Blender Reference Manual 2.76\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-12-04 22:59+1100\n"
"PO-Revision-Date: 2017-09-06 22:01+0200\n"
"Last-Translator: phan <phahoatho@gmail.com>\n"
"Language-Team: français <bf-docboard@blender.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../../manual/game_engine/python_api/videotexture.rst:4
msgid "The VideoTexture Module: bge.texture"
msgstr "Le module VideoTexture : bge.texture"

#: ../../manual/game_engine/python_api/videotexture.rst:6
#, fuzzy
msgid ""
"The ``bge.texture`` module allows you to manipulate textures during the "
"game. Several sources for texture are possible: video files, image files,"
" video capture, memory buffer, camera render or a mix of that. The video "
"and image files can be loaded from the Internet using a URL instead of a "
"file name. In addition, you can apply filters on the images before "
"sending them to the GPU, allowing video effect: blue screen, gradient, "
"gray, normal map. ``bge.texture`` uses FFmpeg to load images and videos. "
"All the formats and codecs that FFmpeg supports are supported by "
"``bge.texture``, including but not limited to:"
msgstr ""
"Le module ``bge.texture`` vous permet de manipuler des textures durant le"
" jeu. Plusieurs sources pour des textures sont possibles : fichiers "
"vidéo, fichiers image, capture vidéo, tampon de mémoire, rendu de caméra "
"ou un mélange de cela. Les fichiers vidéo et image peuvent être chargés "
"en utilisant un URL à la place d'un nom de fichier. De plus, vous pouvez "
"appliquer des filtres sur les images avant de les envoyer au GPU, "
"permettant des effets vidéo : écran bleu, bande de couleur, gris, . "
"``bge.texture`` utilise FFmpeg pour charger des images et des vidéos. "
"Tous les formats et codecs que FFmpeg prend en charge sont pris en charge"
" par ``bge.texture``, comprenant mais pas limité à :"

#: ../../manual/game_engine/python_api/videotexture.rst:16
msgid "AVI"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:17
msgid "Ogg"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:18
msgid "Xvid"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:19
msgid "Theora"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:20
msgid "dv1394 camera"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:21
msgid "video4linux capture card (this includes many webcams)"
msgstr "Carte de capture video4linux (ceci inclut de nombreux webcams)"

#: ../../manual/game_engine/python_api/videotexture.rst:22
msgid "videoForWindows capture card (this includes many webcams)"
msgstr "Carte de capture videoForWindows (ceci inclut de nombreux webcams)"

#: ../../manual/game_engine/python_api/videotexture.rst:23
msgid "JPG"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:27
#, fuzzy
msgid "How It Works"
msgstr "Son fonctionnement"

#: ../../manual/game_engine/python_api/videotexture.rst:29
msgid ""
"The principle is simple: first you identify an existing texture by object"
" and name, then you create a new texture with dynamic content and swap "
"the two textures in the GPU. The GE is not aware of the substitution and "
"continues to display the object as always, except that you are now in "
"control of the texture. At the end, the new texture is deleted and the "
"old texture restored."
msgstr ""
"Le principe est simple : d'abord vous identifiez une texture existante "
"par objet et nom, ensuite vous créez une nouvelle texture avec un contenu"
" dynamique et échangez les deux textures dans le GPU. Le GE n'est pas "
"averti de la substitution et continue à afficher l'objet comme toujours, "
"sauf que vous avez maintenant le contrôle de la texture. À la fin, la "
"nouvelle texture est supprimée et l'ancienne texture restaurée."

#: ../../manual/game_engine/python_api/videotexture.rst:35
msgid ""
"The present page is a guide to the ``bge.texture`` module with simple "
"examples."
msgstr ""
"La présente page est un guide pour le module ``bge.texture`` avec des "
"exemples simples."

#: ../../manual/game_engine/python_api/videotexture.rst:39
#, fuzzy
msgid "Game Preparation"
msgstr "Préparation du jeu"

#: ../../manual/game_engine/python_api/videotexture.rst:41
msgid ""
"Before you can use the thing ``bge.texture`` module, you must have "
"objects with textures applied appropriately."
msgstr ""
"Avant que vous puissiez utiliser le module ``bge.texture``, vous devez "
"disposer d'objets avec des textures appliquées de façon appropriée."

#: ../../manual/game_engine/python_api/videotexture.rst:44
msgid ""
"Imagine you want to have a television showing live broadcast programs in "
"the game. You will create a television object and UV-apply a different "
"texture at the place of the screen, for example ``tv.png``. What this "
"texture looks like is not important; probably you want to make it dark "
"gray to simulate power-off state. When the television must be turned on, "
"you create a dynamic texture from a video capture card and use it instead"
" of ``tv.png``: the TV screen will come to life."
msgstr ""
"Imaginez que vous voulez avoir une télévision affichant des émissions en "
"direct dans le jeu. Vous allez créer un objet télévision et appliquer "
"(UV) une texture différente à la place de l'écran, par exemple "
"``tv.png``. Ce à quoi ressemble cette texture n'est pas important ; "
"probablement vous aimeriez la rendre en gris foncé pour simuler l'état "
"éteint. Quand la télévision doit être allumée, vous créez une texture "
"dynamique depuis une carte de capture vidéo et l'utilisez à la place de "
"``tv.png``: l'écran TV va prendre vie."

#: ../../manual/game_engine/python_api/videotexture.rst:51
msgid "You have two ways to define textures that ``bge.texture`` can grab:"
msgstr ""
"Vous avez deux façons pour définir les textures que ``bge.texture`` peut "
"saisir :"

#: ../../manual/game_engine/python_api/videotexture.rst:53
msgid "Simple UV texture."
msgstr "Texture UV simple."

#: ../../manual/game_engine/python_api/videotexture.rst:54
msgid "Blender material with image texture channel."
msgstr "Matériau Blender avec canal de texture d'image."

#: ../../manual/game_engine/python_api/videotexture.rst:56
msgid ""
"Because ``bge.texture`` works at texture level, it is compatible with all"
" GE fancy texturing features: GLSL, multi-texture, custom shaders, etc."
msgstr ""
"Du fait que ``bge.texture`` fonctionne au niveau texture, c'est "
"compatible avec toutes les fonctions sophistiquées de texturage de BGE : "
"GLSL, multi-texture, custom shaders, etc."

#: ../../manual/game_engine/python_api/videotexture.rst:62
#, fuzzy
msgid "First Example"
msgstr "Premier exemple"

#: ../../manual/game_engine/python_api/videotexture.rst:64
msgid ""
"Let us assume that we have a game object with one or more faces assigned "
"to a material/image on which we want to display a video."
msgstr ""
"Supposons que nous avons un objet de jeu avec une ou plusieurs faces "
"assignées à un matériau/image sur lequel nous voulons afficher une vidéo."

#: ../../manual/game_engine/python_api/videotexture.rst:67
msgid ""
"The first step is to create a ``Texture`` object. We will do it in a "
"script that runs once. It can be at the start of the game, the video is "
"only played when you refresh the texture; we will come to that later. The"
" script is normally attached to the object on which we want to display "
"the video so that we can easily retrieve the object reference::"
msgstr ""
"La première étape est de créer un objet ``Texture``. Nous allons le faire"
" dans un script qui s'exécute une fois. Il peut être au début du jeu, la "
"vidéo est seulement jouée quand vous actualisez la texture ; nous allons "
"revenir dessus plus tard. Le script est normalement attaché à l'objet sur"
" lequel vous voulons afficher la vidéo de sorte que nous pouvons "
"facilement récupérer la référence de l'objet :  "

#: ../../manual/game_engine/python_api/videotexture.rst:80
msgid ""
"The check on ``video`` attribute is just a trick to make sure we create "
"the texture only once."
msgstr ""
"La coche sur l'attribut ``video`` est simplement une astuce pour nous "
"assurer que vous avons créé la texture seulement une fois."

#: ../../manual/game_engine/python_api/videotexture.rst:84
#, fuzzy
msgid "Find Material"
msgstr "Recherche de matériau"

#: ../../manual/game_engine/python_api/videotexture.rst:91
msgid ""
"``bge.texture.materialID()`` is a handy function to retrieve the object "
"material that is using ``video.png`` as texture. This method will work "
"with Blender material and UV texture. In case of UV texture, it grabs the"
" internal material corresponding to the faces that are assigned to this "
"texture. In case of Blender material, it grabs the material that has an "
"image texture channel matching the name as first channel."
msgstr ""
"``bge.texture.materialID()`` est une fonction pratique pour récupérer le "
"matériau de l'objet qui utilise ``video.png`` comme texture. Cette "
"méthode fonctionnera avec un matériau Blender et une texture UV. Dans le "
"cas d'une texture UV, il prend le matériau interne correspondant aux "
"faces qui sont assignées à cette texture. Dans le cas d'un matériau "
"Blnder, il prend le matériau qui a un canal de texture d'image "
"correspondant au nom du premier canal."

#: ../../manual/game_engine/python_api/videotexture.rst:98
msgid ""
"The ``IM`` prefix indicates that we are searching for a texture name but "
"we can also search for a material by giving the ``MA`` prefix. For "
"example, if we want to find the material called ``VideoMat`` on this "
"object, the code becomes::"
msgstr ""
"Le préfixe ``IM`` indique que nous sommes en train de chercher un nom de "
"texture mais nous pouvons aussi chercher un matériau en donnant le "
"préfixe ``MA`` . Par exemple, si nous voulons trouver le matériau appelé "
"``VideoMat`` sur cet objet, le code devient :"

#: ../../manual/game_engine/python_api/videotexture.rst:106
#, fuzzy
msgid "Create Texture"
msgstr "Création d'une texture"

#: ../../manual/game_engine/python_api/videotexture.rst:108
msgid ""
"``bge.texture.Texture`` is the class that creates the ``Texture`` object "
"that loads the dynamic texture on the GPU. The constructor takes one "
"mandatory and three optional arguments:"
msgstr ""
"``bge.texture.Texture`` est la classe qui crée l'objet ``Texture`` qui "
"charge la texture dynamique sur le GPU. Le constructeur prend un argument"
" obligatoire et trois facultatifs :"

#: ../../manual/game_engine/python_api/videotexture.rst:111
msgid "``gameObj``"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:112
msgid "The game object."
msgstr "L'objet game."

#: ../../manual/game_engine/python_api/videotexture.rst:113
msgid "``materialID``"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:114
msgid ""
"Material index as returned by ``bge.texture.materialID()``, 0 = first "
"material by default."
msgstr ""
"Index du matériau retourné par ``bge.texture.materialID()``, 0 = premier "
"matériau par défaut."

#: ../../manual/game_engine/python_api/videotexture.rst:116
msgid "``textureID``"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:116
msgid ""
"Texture index in case of multi-texture channel, 0 = first channel by "
"default. In case of UV texture, this parameter should always be 0."
msgstr ""
"Index de texture dans le cas de canal multi-texture, 0 = premier canal "
"par défaut. Dans le cas de texture UV, ce paramètre devrait toujours être"
" à 0."

#: ../../manual/game_engine/python_api/videotexture.rst:122
msgid "``textureObj``"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:119
#, fuzzy
msgid ""
"Reference to another ``Texture`` object of which we want to reuse the "
"texture. If we use this argument, we should not create any source on this"
" texture and there is no need to refresh it either ; the other "
"``Texture`` object will provide the texture for both materials/textures."
msgstr ""
"Référence à un autre objet ``Texture`` dont nous voulons réutiliser la "
"texture. Si nous utilisons cet argument, nous devrions pas créer une "
"source sur cette texture et il n'est pas nécessaire de le réactualiser "
"non plus ; l'autre objet ``Texture`` fournira la texture à la fois pour "
"les matériaux/textures. "

#: ../../manual/game_engine/python_api/videotexture.rst:130
msgid "Make Texture Persistent"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:132
#, fuzzy
msgid ""
"Note that we have assigned the object to a ``GameLogic``, ``video`` "
"attribute that we have created for the occasion. The reason is that the "
"``Texture`` object must be persistent across the game scripts. A local "
"variable would be deleted at the end of the script and the GPU texture "
"deleted at the same time. ``GameLogic`` module object is a handy place to"
" store persistent objects."
msgstr ""
"Notez que nous avons assigné l'objet à un attribut ``GameLogic``, "
"``video`` que nous avons créé pour l'occasion. La raison est que l'objet "
"``Texture`` doit être persistant à travers les scripts de jeu. une "
"variable locale serait supprimée à la fin du script et la texture GPU "
"supprimée en même temps. l'objet du module ``GameLogic`` est un "
"emplacement pratique pour stocker les objets persistants."

#: ../../manual/game_engine/python_api/videotexture.rst:140
#, fuzzy
msgid "Create a Source"
msgstr "Installation de la source"

#: ../../manual/game_engine/python_api/videotexture.rst:142
msgid ""
"Now we have a ``Texture`` object but it cannot do anything because it "
"does not have any source. We must create a source object from one of the "
"possible sources available in ``bge.texture``:"
msgstr ""
"maintenant nous avons un objet ``Texture`` mais il ne peut rien faire car"
" il n'a aucune source. Nous devons créer une source à partir d'une des "
"sources possibles disponibles dans ``bge.texture``:"

#: ../../manual/game_engine/python_api/videotexture.rst:148
msgid "``VideoFFmpeg``"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:147
msgid "Moving pictures. Video file, video capture, video streaming."
msgstr "images animées. Fichier vidéo, capture vidéo, streaming vidéo."

#: ../../manual/game_engine/python_api/videotexture.rst:152
msgid "``ImageFFmpeg``"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:151
msgid "Still pictures. Image file, image on web."
msgstr "Images fixes. Fichier image, image sur le web."

#: ../../manual/game_engine/python_api/videotexture.rst:156
msgid "``ImageBuff``"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:155
msgid ""
"Image from application memory. For computer generated images, drawing "
"applications."
msgstr ""
"Image depuis la mémoire de l'application. Pour les images générées par "
"ordinateur, les applications de dessin."

#: ../../manual/game_engine/python_api/videotexture.rst:159
msgid "``ImageViewport``"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:159
msgid ""
"Part or whole of the viewport (=rendering of the active camera displayed "
"on screen)."
msgstr "Tout ou partie de la vue (= rendu de la caméra active affichée à l'écran)."

#: ../../manual/game_engine/python_api/videotexture.rst:162
msgid "``ImageRender``"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:162
msgid "Render of a non active camera."
msgstr "Rendu d'une caméra non active."

#: ../../manual/game_engine/python_api/videotexture.rst:165
msgid "``ImageMix``"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:165
msgid "A mix of two or more of the above sources."
msgstr "Un mélange de deux ou plus des sources ci-dessus."

#: ../../manual/game_engine/python_api/videotexture.rst:167
msgid ""
"In this example we use a simple video file as source. The ``VideoFFmpeg``"
" constructor takes a file name as argument. To avoid any confusion with "
"the location of the file, we will use ``GameLogic.expandPath ()`` to "
"build an absolute file name, assuming the video file is in the same "
"directory as the blend-file::"
msgstr ""
"Dans cet exemple nous utilisons un simple fichier vidéo comme source. Le "
"constructeur ``VideoFFmpeg`` prend un nom de fichier comme argument. Pour"
" éviter toute confusion avec l'emplacement du fichier , nous utiliserons "
"``GameLogic.expandPath ()`` pour construire un nom de fichier absolu, en "
"supposant que le fichier vidéo est dans le même dossier que le fichier "
"blend :"

#: ../../manual/game_engine/python_api/videotexture.rst:177
msgid ""
"We create the video source object and assign it to the ``Texture`` object"
" ``source`` attribute to set the source and make it persistent: as the "
"``Texture`` object is persistent, the source object will also be "
"persistent."
msgstr ""
"Nous créons l'objet source vidéo et l'assignons à l'attribut ``source`` "
"de l'objet ``Texture`` pour définir la source et le rend persistant : "
"comme l'objet ``Texture`` est persistant, l'objet source sera aussi "
"persistant."

#: ../../manual/game_engine/python_api/videotexture.rst:181
msgid ""
"Note that we can change the ``Texture`` source at any time. Suppose we "
"want to switch between two movies during the game."
msgstr ""
"Notez que nous pouvons modifier la source ``Texture`` à tout moment. "
"Supposez que nous voulons échanger les deux films durant le jeu."

#: ../../manual/game_engine/python_api/videotexture.rst:184
msgid "We can do the following::"
msgstr "Nous pouvons faire ce qui suit :"

#: ../../manual/game_engine/python_api/videotexture.rst:189
msgid "And then assign (and reassign) the source during the game::"
msgstr "Et ensuite assigner (et réassigner) la source durant le jeu :"

#: ../../manual/game_engine/python_api/videotexture.rst:195
#, fuzzy
msgid "Setup the Source"
msgstr "Installation de la source"

#: ../../manual/game_engine/python_api/videotexture.rst:197
msgid ""
"The ``VideoFFmpeg`` source has several attributes to control the movie "
"playback:"
msgstr ""
"La source ``VideoFFmpeg`` a plusieurs attributs pour contrôler la lecture"
" vidéo :"

#: ../../manual/game_engine/python_api/videotexture.rst:202
msgid "``range``"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:200
msgid ""
"[start,stop] (floats). Set the start and stop time of the video playback,"
" expressed in seconds from beginning. By default the entire video."
msgstr ""
"[start,stop] (flottants). Définir les temps de début et de fin de la "
"lecture vidéo, exprimés en secondes à partir le début de la vidéo. Par "
"début, la vidéo en entier."

#: ../../manual/game_engine/python_api/videotexture.rst:206
msgid "``repeat``"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:205
msgid "(integer). Number of video replay, -1 for infinite."
msgstr "(entier). Nombre de lectures vidéo. -1 pour infini."

#: ../../manual/game_engine/python_api/videotexture.rst:210
msgid "``framerate``"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:209
msgid "(float). Relative frame rate, <1.0 for slow, >1.0 for fast."
msgstr "(flottant). Fréquence d'images relative, <1.0 pour rapide. "

#: ../../manual/game_engine/python_api/videotexture.rst:218
msgid "``scale``"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:213
#, fuzzy
msgid ""
"(bool). Set to True to activate fast nearest neighbor scaling algorithm. "
"Texture width and height must be a power of 2. If the video picture size "
"is not a power of 2, rescaling is required. By default ``bge.texture`` "
"uses the precise but slow ``gluScaleImage()`` function. Best is to "
"rescale the video offline so that no scaling is necessary at runtime!"
msgstr ""
"(booléen). Fixé à *True* pour activer l'algorithme rapide *nearest "
"neighbor scaling*. La largeur et la hauteur de texture doit être une "
"puissance de 2. Si la taille d'image de la vidéo n'est pas une puissance "
"de 2, le redimensionnement est nécessaire. Par défaut ``bge.texture`` "
"utilise la fonction ``gluScaleImage()`` précise mais lente. Il vaut mieux"
" redimensionner l vidéo de sorte que aucun dimensionnement ne soit "
"nécessaire au moment du ! "

#: ../../manual/game_engine/python_api/videotexture.rst:223
msgid "``flip``"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:221
#, fuzzy
msgid ""
"(bool). Set to True if the image must be vertically flipped. FFmpeg "
"always delivers the image upside down, so this attribute is set to True "
"by default."
msgstr ""
"(booléen). Fixé à *True* si l'image doit être verticalement. FFmpeg "
"délivre toujours l'image aussi cet attribut est fixé à *True* par défaut."

#: ../../manual/game_engine/python_api/videotexture.rst:229
msgid "``filter``"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:226
msgid ""
"Set additional filter on the video before sending to GPU. Assign to one "
"of ``bge.texture`` filter object. By default the image is send unchanged "
"to the GPU. If an alpha channel is present in the video, it is "
"automatically loaded and sent to the GPU as well."
msgstr ""
"Définir un filtre supplémentaire sur la vidéo avant son envoi vers le "
"GPU. Assignez à un de objets filtres ``bge.texture``. Par défaut l'image "
"est envoyée sans modification au GPU. Si un canal alpha est présent dans "
"la vidéo, il est automatiquement chargé et envoyé de même au GPU."

#: ../../manual/game_engine/python_api/videotexture.rst:231
msgid ""
"We will simply set the ``scale`` attribute to True because the "
"``gluScaleImage ()`` is really too slow for real time video. In case the "
"video dimensions are already a power of 2, it has no effect. ::"
msgstr ""
"Nous allons simplement mettre l'attribut ``scale`` à *True* parce que "
"``gluScaleImage ()`` est vraiment trop lent pour une vidéo en temps réel."
" Dans le cas où les dimensions vidéo sont déjà une puissance de 2, il n'a"
" aucun effet. ::"

#: ../../manual/game_engine/python_api/videotexture.rst:239
#, fuzzy
msgid "Play the Video"
msgstr "Lecture de la vidéo"

#: ../../manual/game_engine/python_api/videotexture.rst:241
msgid "We are now ready to play the video::"
msgstr "Nous sommes maintenant prêts à lire la vidéo :"

#: ../../manual/game_engine/python_api/videotexture.rst:245
msgid ""
"Video playback is not a background process: it happens only when we "
"refresh the texture. So we must have another script that runs on every "
"frame and calls the ``refresh()`` method of the ``Texture`` object::"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:252
msgid ""
"If the video source is stopped, ``refresh()`` has no effect. The argument"
" of ``refresh ()`` is a flag that indicates if the texture should be "
"recalculated on next refresh. For video playback, you definitively want "
"to set it to True."
msgstr ""
"Si la source vidéo est arrêtée, ``refresh()`` n'a pas d'effet, L'argument"
" de ``refresh()`` est un drapeau qui indique si la texture devrait être "
"recalculée au prochain rafraîchissement. Pour la lecture vidéo, vous "
"voudrez certainement le mettre à *True*. "

#: ../../manual/game_engine/python_api/videotexture.rst:259
#, fuzzy
msgid "Checking the Video Status"
msgstr "Vérification de l'état de la vidéo"

#: ../../manual/game_engine/python_api/videotexture.rst:261
msgid ""
"Video source classes (such as VideoFFMpeg) have an attribute ``status``. "
"If video is playing, its value is 2, if it's stopped, it's 3. So in our "
"example::"
msgstr ""
"Les classes de source vidéo (telle que VideoFFMpeg) ont  un attribut "
"``status``. Si la lecture vidéo est en cours, sa valeur est 2, si elle "
"est arrêtée, c'est 3. Aussi dans notre exemple :"

#: ../../manual/game_engine/python_api/videotexture.rst:270
#, fuzzy
msgid "Advanced Workflow"
msgstr "Flux de travail avancé"

#: ../../manual/game_engine/python_api/videotexture.rst:272
msgid ""
"True argument in ``Texture.refresh()`` method simply invalidates the "
"image buffer after sending it to the GPU so that on next frame, a new "
"image will be loaded from the source. It has the side effect of making "
"the image unavailable to Python. You can also do it manually by calling "
"the ``refresh()`` method of the source directly."
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:277
msgid "Here are some possible advanced work flow:"
msgstr "Voici certaines possibilités de flux de travail avancés :"

#: ../../manual/game_engine/python_api/videotexture.rst:279
msgid "Use the image buffer in Python (does not effect the Texture)::"
msgstr "Utiliser le tampon d'image dans Python (n'affecte pas la Texture) :"

#: ../../manual/game_engine/python_api/videotexture.rst:288
msgid "Load image from source for Python processing without download to GPU:"
msgstr ""
"Charger l'image depuis la source pour le traitement avec Python sans "
"chargement vers le GPU : "

#: ../../manual/game_engine/python_api/videotexture.rst:289
#, fuzzy
msgid "Note that we do not even call refresh on the Texture."
msgstr "Notez que nous n'appelons même pas d'actualisation de la Texture. "

#: ../../manual/game_engine/python_api/videotexture.rst:290
msgid "We could also just create a source object without a Texture object::"
msgstr "Vous pourrions aussi créer un objet source sans objet Texture :"

#: ../../manual/game_engine/python_api/videotexture.rst:296
msgid ""
"If you have more than one material on the mesh and you want to modify a "
"texture of one particular material, get its ID::"
msgstr ""
"Si vous avez plus d'un matériau sur le mesh et que vous voulez modifier "
"une texture d'un matériau particulier, récupérez son ID :"

#: ../../manual/game_engine/python_api/videotexture.rst:301
msgid ""
"GLSL material can have more than one texture channel, identify the "
"texture by the texture slot where it is defined, here two::"
msgstr ""
"Le matériau GLSL peut avoir plus d'un canal de texture, identifiez la "
"texture par le slot de texture où elle est définie, ici deux :"

#: ../../manual/game_engine/python_api/videotexture.rst:308
#, fuzzy
msgid "Advanced Demos"
msgstr "Démos avancées"

#: ../../manual/game_engine/python_api/videotexture.rst:310
#, fuzzy
msgid ""
"Here is a `demo "
"<http://www.graphicall.org/ftp/ben2610/VideoTextureDemo2video.blend>`__ "
"that demonstrates the use of two videos alternatively on the same "
"texture. Note that it requires an additional video file which is the "
"*Elephant Dream* teaser. You can replace it with another file that you "
"want to run the demo."
msgstr ""
"Voici une `démo "
"<http://www.graphicall.org/ftp/ben2610/VideoTextureDemo2video.blend>`__ "
"qui montre l'utilisation de deux vidéos alternativement sur la même "
"texture. Notez qu'elle nécessite un fichier vidéo supplémentaire qui est "
"la bande-annonce de *Elephant Dream*. Vous pouvez le remplacer avec un "
"autre fichier dont vous voulez lancer la démo."

#: ../../manual/game_engine/python_api/videotexture.rst:315
msgid ""
"Here is a `demo "
"<http://www.graphicall.org/ftp/ben2610/VideoTextureDemo2videoMix.blend>`__"
" that demonstrates the use of the ``ImageMix`` source. ``ImageMix`` is a "
"source that needs sources, which can be any other ``Texture`` source, "
"like ``VideoFFmpeg``, ``ImageFFmpeg`` or ``ImageRender``. You set them "
"with ``setSource ()`` and their relative weight with ``setWeight()``. Pay"
" attention that the weight is a short number between 0 and 255, and that "
"the sum of all weights should be 255. ``ImageMix`` makes a mix of all the"
" sources according to their weights. The sources must all have the same "
"image size (after reduction to the nearest power of two dimension). If "
"they do not, you will get a Python error on the console."
msgstr ""
"Voici une `démo "
"<http://www.graphicall.org/ftp/ben2610/VideoTextureDemo2videoMix.blend>`__"
" qui montre l'utilisation de la source ``ImageMix``. ``ImageMix``est une "
"source qui nécessite des sources, qui peuvent être n'importe quelle autre"
" source ``Texture``, comme ``VideoFFmpeg``, ``ImageFFmpeg`` ou "
"``ImageRender``. Vous les définissez avec ``setSource ()`` et leur poids "
"relatif avec ``setWeight()``. Faites attention le poids est un nombre "
"entre 0 et 255, et que la somme de tous les poids devrait être 255. "
"``ImageMix`` fait un mélange de les sources selon leurs poids. Les "
"sources doivent avoir la même taille d'image (après réduction des "
"dimensions à la puissance de deux la plus proche). Si cette condition "
"n'est pas remplie, vous obtiendrez une erreur Python sur la console.   "
"Voici une `démo "
"<http://www.graphicall.org/ftp/ben2610/VideoTextureDemo2videoMix.blend>`__"
" qui montre l'utilisation de la source ``ImageMix``. ``ImageMix``est une "
"source qui nécessite des sources, qui peuvent être n'importe quelle autre"
" source ``Texture``, comme ``VideoFFmpeg``, ``ImageFFmpeg`` ou "
"``ImageRender``. Vous les définissez avec ``setSource ()`` et leur poids "
"relatif avec ``setWeight()``. Faites attention le poids est un nombre "
"entre 0 et 255, et que la somme de tous les poids devrait être 255. "
"``ImageMix`` fait un mélange de les sources selon leurs poids. Les "
"sources doivent avoir la même taille d'image (après réduction des "
"dimensions à la puissance de deux la plus proche). Si cette condition "
"n'est pas remplie, vous obtendrez une erreur Python sur la console.   "
"Voici une `démo "
"<http://www.graphicall.org/ftp/ben2610/VideoTextureDemo2videoMix.blend>`__"
" qui montre l'utilisation de la source ``ImageMix``. ``ImageMix``est une "
"source qui nécessite des sources, qui peuvent être n'importe quelle autre"
" source ``Texture``, comme ``VideoFFmpeg``, ``ImageFFmpeg`` ou "
"``ImageRender``. Vous les définissez avec ``setSource ()`` et leur poids "
"relatif avec ``setWeight()``. Faites attention le poids est un nombre "
"entre 0 et 255, et que la somme de tous les poids devrait être 255. "
"``ImageMix`` fait un mélange de les sources selon leurs poids. Les "
"sources doivent avoir la même taille d'image (après réduction des "
"dimensions à la puissance de deux la plus proche). Si cette condition "
"n'est pas remplie, vous obtendrez une erreur Python sur la console.   "

#~ msgid "The VideoTexture module: bge.texture"
#~ msgstr ""

#~ msgid "Make texture persistent"
#~ msgstr ""

#~ msgid "Create a source"
#~ msgstr ""

#~ msgid ""
#~ "Video playback is not a background "
#~ "process: it happens only when we "
#~ "refresh the texture. So we must "
#~ "have another script that runs on "
#~ "every frame and calls the ``refresh "
#~ "()`` method of the ``Texture`` "
#~ "object::Video playback is not a "
#~ "background process: it happens only when"
#~ " we refresh the texture. So we "
#~ "must have another script that runs "
#~ "on every frame and calls the "
#~ "``refresh ()`` method of the ``Texture``"
#~ " object::Video playback is not a "
#~ "background process: it happens only when"
#~ " we refresh the texture. So we "
#~ "must have another script that runs "
#~ "on every frame and calls the "
#~ "``refresh()`` method of the ``Texture`` "
#~ "object::"
#~ msgstr ""
#~ "La lecture vidéo n'est pas un "
#~ "processus en arrière-plan : elle "
#~ "se produit seulement quand nous "
#~ "rafraîchissons la texture. Aussi nous "
#~ "devons avoir un autre script qui "
#~ "se lance à chaque frame et appelle"
#~ " la méthode ``refresh ()`` de l'objet"
#~ " ``Texture``::"

#~ msgid ""
#~ "True argument in ``Texture.refresh()`` method"
#~ " simply invalidates the image buffer "
#~ "after sending it to the GPU so "
#~ "that on next frame, a new image"
#~ " will be loaded from the source. "
#~ "It has the side effect of making"
#~ " the image unavailable to Python. You"
#~ " can also do it manually by "
#~ "calling the ``refresh ()`` method of "
#~ "the source directly.True argument in "
#~ "``Texture.refresh()`` method simply invalidates "
#~ "the image buffer after sending it "
#~ "to the GPU so that on next "
#~ "frame, a new image will be loaded"
#~ " from the source. It has the "
#~ "side effect of making the image "
#~ "unavailable to Python. You can also "
#~ "do it manually by calling the "
#~ "``refresh ()`` method of the source "
#~ "directly.True argument in ``Texture.refresh()`` "
#~ "method simply invalidates the image "
#~ "buffer after sending it to the GPU"
#~ " so that on next frame, a new"
#~ " image will be loaded from the "
#~ "source. It has the side effect of"
#~ " making the image unavailable to "
#~ "Python. You can also do it "
#~ "manually by calling the ``refresh()`` "
#~ "method of the source directly."
#~ msgstr ""
#~ "L'argument *True* dans la méthode "
#~ "``Texture.refresh()``invalide simplement le tampon"
#~ " d'image après son envoi au GPU, "
#~ "ainsi sur la prochaine frame, une "
#~ "nouvelle image sera chargée depuis la"
#~ " source. Il a l'effet collatéral de"
#~ " rendre l'image indisponible pour Python."
#~ " Vous pouvez aussi le faire "
#~ "manuellement en appelant directement la "
#~ "méthode ``refresh ()`` de la source."
#~ " \n"

