# SOME DESCRIPTIVE TITLE.
# Copyright (C) : This page is public domain as CC0
# This file is distributed under the same license as the Blender Reference
# Manual package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
# phan <phahoatho@gmail.com>, 2016, 2017, 2018.
#
msgid ""
msgstr ""
"Project-Id-Version: Blender Reference Manual 2.76\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-19 21:38-0400\n"
"PO-Revision-Date: 2018-06-22 21:19+0200\n"
"Last-Translator: phan <phahoatho@gmail.com>\n"
"Language-Team: français <bf-docboard@blender.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.3\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Gtranslator 2.91.6\n"

#: ../../manual/game_engine/python_api/videotexture.rst:4
msgid "The VideoTexture Module: bge.texture"
msgstr "Le module VideoTexture : bge.texture"

#: ../../manual/game_engine/python_api/videotexture.rst:6
msgid ""
"The ``bge.texture`` module allows you to manipulate textures during the "
"game. Several sources for texture are possible: video files, image files, "
"video capture, memory buffer, camera render or a mix of that. The video and "
"image files can be loaded from the Internet using a URL instead of a file "
"name. In addition, you can apply filters on the images before sending them "
"to the GPU, allowing video effect: blue screen, gradient, gray, normal map. "
"``bge.texture`` uses FFmpeg to load images and videos. All the formats and "
"codecs that FFmpeg supports are supported by ``bge.texture``, including but "
"not limited to:"
msgstr ""
"Le module ``bge.texture`` vous permet de manipuler les textures pendant le "
"jeu. Plusieurs sources de textures sont possibles : fichiers vidéo, fichiers "
"image, capture vidéo, tampon de mémoire, rendu de caméra ou un mélange de "
"tout cela. Les fichiers vidéo et image peuvent être chargés depuis Internet "
"en utilisant un URL à la place d'un nom de fichier. De plus, vous pouvez "
"appliquer des filtres sur les images avant de les envoyer au GPU, produisant "
"ainsi un effet vidéo : écran bleu, gradient, gris, normal map. ``bge."
"texture`` utilise FFmpeg pour charger les images et les vidéo. Tous les "
"formats et codecs pris en charge par FFmpeg le sont par ``bge.texture``, y "
"compris (mais pas limités à ceux-ci) :"

#: ../../manual/game_engine/python_api/videotexture.rst:16
msgid "AVI"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:17
msgid "Ogg"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:18
msgid "Xvid"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:19
msgid "Theora"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:20
msgid "dv1394 camera"
msgstr "caméra dv1394"

#: ../../manual/game_engine/python_api/videotexture.rst:21
msgid "video4linux capture card (this includes many webcams)"
msgstr "Carte de capture video4linux (ceci inclut de nombreux webcams)"

#: ../../manual/game_engine/python_api/videotexture.rst:22
msgid "videoForWindows capture card (this includes many webcams)"
msgstr "Carte de capture videoForWindows (ceci inclut de nombreux webcams)"

#: ../../manual/game_engine/python_api/videotexture.rst:23
msgid "JPG"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:27
msgid "How It Works"
msgstr "Comment ça marche"

#: ../../manual/game_engine/python_api/videotexture.rst:29
msgid ""
"The principle is simple: first you identify an existing texture by object "
"and name, then you create a new texture with dynamic content and swap the "
"two textures in the GPU. The GE is not aware of the substitution and "
"continues to display the object as always, except that you are now in "
"control of the texture. At the end, the new texture is deleted and the old "
"texture restored."
msgstr ""
"Le principe est simple : d'abord vous identifiez une texture existante par "
"objet et nom, ensuite vous créez une nouvelle texture avec un contenu "
"dynamique et échangez les deux textures dans le GPU. Le GE n'est pas averti "
"de la substitution et continue à afficher l'objet comme toujours, sauf que "
"vous avez maintenant le contrôle de la texture. À la fin, la nouvelle "
"texture est supprimée et l'ancienne texture restaurée."

#: ../../manual/game_engine/python_api/videotexture.rst:35
msgid ""
"The present page is a guide to the ``bge.texture`` module with simple "
"examples."
msgstr ""
"La présente page est un guide pour le module ``bge.texture`` avec des "
"exemples simples."

#: ../../manual/game_engine/python_api/videotexture.rst:39
msgid "Game Preparation"
msgstr "Préparation du jeu"

#: ../../manual/game_engine/python_api/videotexture.rst:41
msgid ""
"Before you can use the thing ``bge.texture`` module, you must have objects "
"with textures applied appropriately."
msgstr ""
"Avant que vous puissiez utiliser le module ``bge.texture``, vous devez "
"disposer d'objets avec des textures appliquées de façon appropriée."

#: ../../manual/game_engine/python_api/videotexture.rst:44
msgid ""
"Imagine you want to have a television showing live broadcast programs in the "
"game. You will create a television object and UV-apply a different texture "
"at the place of the screen, for example ``tv.png``. What this texture looks "
"like is not important; probably you want to make it dark gray to simulate "
"power-off state. When the television must be turned on, you create a dynamic "
"texture from a video capture card and use it instead of ``tv.png``: the TV "
"screen will come to life."
msgstr ""
"Imaginez que vous voulez avoir une télévision affichant des émissions en "
"direct dans le jeu. Vous allez créer un objet télévision et appliquer (UV) "
"une texture différente à la place de l'écran, par exemple ``tv.png``. Ce à "
"quoi ressemble cette texture n'est pas important ; probablement vous "
"aimeriez la rendre en gris foncé pour simuler l'état éteint. Quand la "
"télévision doit être allumée, vous créez une texture dynamique depuis une "
"carte de capture vidéo et l'utilisez à la place de ``tv.png``: l'écran TV va "
"prendre vie."

#: ../../manual/game_engine/python_api/videotexture.rst:51
msgid "You have two ways to define textures that ``bge.texture`` can grab:"
msgstr ""
"Vous avez deux façons pour définir les textures que ``bge.texture`` peut "
"saisir :"

#: ../../manual/game_engine/python_api/videotexture.rst:53
msgid "Simple UV texture."
msgstr "Texture UV simple."

#: ../../manual/game_engine/python_api/videotexture.rst:54
msgid "Blender material with image texture channel."
msgstr "Matériau Blender avec canal de texture d'image."

#: ../../manual/game_engine/python_api/videotexture.rst:56
msgid ""
"Because ``bge.texture`` works at texture level, it is compatible with all GE "
"fancy texturing features: GLSL, multi-texture, custom shaders, etc."
msgstr ""
"Du fait que ``bge.texture`` fonctionne au niveau texture, c'est compatible "
"avec toutes les fonctions sophistiquées de texturage de BGE : GLSL, multi-"
"texture, custom shaders, etc."

#: ../../manual/game_engine/python_api/videotexture.rst:62
msgid "First Example"
msgstr "Premier exemple"

#: ../../manual/game_engine/python_api/videotexture.rst:64
msgid ""
"Let us assume that we have a game object with one or more faces assigned to "
"a material/image on which we want to display a video."
msgstr ""
"Supposons que nous avons un objet de jeu avec une ou plusieurs faces "
"assignées à un matériau/image sur lequel nous voulons afficher une vidéo."

#: ../../manual/game_engine/python_api/videotexture.rst:67
msgid ""
"The first step is to create a ``Texture`` object. We will do it in a script "
"that runs once. It can be at the start of the game, the video is only played "
"when you refresh the texture; we will come to that later. The script is "
"normally attached to the object on which we want to display the video so "
"that we can easily retrieve the object reference::"
msgstr ""
"La première étape est de créer un objet ``Texture``. Nous allons le faire "
"dans un script qui s'exécute une fois. Il peut être au début du jeu, la "
"vidéo est seulement jouée quand vous actualisez la texture ; nous allons "
"revenir dessus plus tard. Le script est normalement attaché à l'objet sur "
"lequel vous voulons afficher la vidéo de sorte que nous pouvons facilement "
"récupérer la référence de l'objet :  "

#: ../../manual/game_engine/python_api/videotexture.rst:80
msgid ""
"The check on ``video`` attribute is just a trick to make sure we create the "
"texture only once."
msgstr ""
"La coche sur l'attribut ``video`` est simplement une astuce pour nous "
"assurer que vous avons créé la texture seulement une fois."

#: ../../manual/game_engine/python_api/videotexture.rst:84
msgid "Find Material"
msgstr "Recherche de matériau"

#: ../../manual/game_engine/python_api/videotexture.rst:91
msgid ""
"``bge.texture.materialID()`` is a handy function to retrieve the object "
"material that is using ``video.png`` as texture. This method will work with "
"Blender material and UV texture. In case of UV texture, it grabs the "
"internal material corresponding to the faces that are assigned to this "
"texture. In case of Blender material, it grabs the material that has an "
"image texture channel matching the name as first channel."
msgstr ""
"``bge.texture.materialID()`` est une fonction pratique pour récupérer le "
"matériau de l'objet qui utilise ``video.png`` comme texture. Cette méthode "
"fonctionnera avec un matériau Blender et une texture UV. Dans le cas d'une "
"texture UV, il prend le matériau interne correspondant aux faces qui sont "
"assignées à cette texture. Dans le cas d'un matériau Blender, il prend le "
"matériau qui a un canal de texture d'image correspondant au nom du premier "
"canal."

#: ../../manual/game_engine/python_api/videotexture.rst:98
msgid ""
"The ``IM`` prefix indicates that we are searching for a texture name but we "
"can also search for a material by giving the ``MA`` prefix. For example, if "
"we want to find the material called ``VideoMat`` on this object, the code "
"becomes::"
msgstr ""
"Le préfixe ``IM`` indique que nous sommes en train de chercher un nom de "
"texture mais nous pouvons aussi chercher un matériau en donnant le préfixe "
"``MA`` . Par exemple, si nous voulons trouver le matériau appelé "
"``VideoMat`` sur cet objet, le code devient :"

#: ../../manual/game_engine/python_api/videotexture.rst:106
msgid "Create Texture"
msgstr "Création d'une texture"

#: ../../manual/game_engine/python_api/videotexture.rst:108
msgid ""
"``bge.texture.Texture`` is the class that creates the ``Texture`` object "
"that loads the dynamic texture on the GPU. The constructor takes one "
"mandatory and three optional arguments:"
msgstr ""
"``bge.texture.Texture`` est la classe qui crée l'objet ``Texture`` qui "
"charge la texture dynamique sur le GPU. Le constructeur prend un argument "
"obligatoire et trois facultatifs :"

#: ../../manual/game_engine/python_api/videotexture.rst:111
msgid "``gameObj``"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:112
msgid "The game object."
msgstr "L'objet game."

#: ../../manual/game_engine/python_api/videotexture.rst:113
msgid "``materialID``"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:114
msgid ""
"Material index as returned by ``bge.texture.materialID()``, 0 = first "
"material by default."
msgstr ""
"Index du matériau retourné par ``bge.texture.materialID()``, 0 = premier "
"matériau par défaut."

#: ../../manual/game_engine/python_api/videotexture.rst:116
msgid "``textureID``"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:116
msgid ""
"Texture index in case of multi-texture channel, 0 = first channel by "
"default. In case of UV texture, this parameter should always be 0."
msgstr ""
"Index de texture dans le cas de canal multi-texture, 0 = premier canal par "
"défaut. Dans le cas de texture UV, ce paramètre devrait toujours être à 0."

#: ../../manual/game_engine/python_api/videotexture.rst:122
msgid "``textureObj``"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:119
msgid ""
"Reference to another ``Texture`` object of which we want to reuse the "
"texture. If we use this argument, we should not create any source on this "
"texture and there is no need to refresh it either; the other ``Texture`` "
"object will provide the texture for both materials/textures."
msgstr ""
"Référence à un autre objet ``Texture`` dont nous voulons réutiliser la "
"texture. Si nous utilisons cet argument, nous ne devrions pas créer de "
"source sur cette texture et il n'est pas nécessaire de le réactualiser non "
"plus ; l'autre objet ``Texture`` fournira la texture à la fois pour les "
"matériaux/textures. "

#: ../../manual/game_engine/python_api/videotexture.rst:130
msgid "Make Texture Persistent"
msgstr "Rendre une texture persistante"

#: ../../manual/game_engine/python_api/videotexture.rst:132
msgid ""
"Note that we have assigned the object to a ``GameLogic``, ``video`` "
"attribute that we have created for the occasion. The reason is that the "
"``Texture`` object must be persistent across the game scripts. A local "
"variable would be deleted at the end of the script and the GPU texture "
"deleted at the same time. ``GameLogic`` module object is a handy place to "
"store persistent objects."
msgstr ""
"Notez que nous avons assigné l'objet à un ``GameLogic``, attribut ``video`` "
"que nous avons créé pour l'occasion. La raison est que l'objet ``Texture`` "
"doit être persistant à travers les scripts de jeu. une variable locale "
"serait supprimée à la fin du script et la texture GPU supprimée en même "
"temps. l'objet du module ``GameLogic`` est un emplacement pratique pour "
"stocker les objets persistants."

#: ../../manual/game_engine/python_api/videotexture.rst:140
msgid "Create a Source"
msgstr "Création d'une source"

#: ../../manual/game_engine/python_api/videotexture.rst:142
msgid ""
"Now we have a ``Texture`` object but it cannot do anything because it does "
"not have any source. We must create a source object from one of the possible "
"sources available in ``bge.texture``:"
msgstr ""
"maintenant nous avons un objet ``Texture`` mais il ne peut rien faire car il "
"n'a aucune source. Nous devons créer une source à partir d'une des sources "
"possibles disponibles dans ``bge.texture`` :"

#: ../../manual/game_engine/python_api/videotexture.rst:148
msgid "``VideoFFmpeg``"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:147
msgid "Moving pictures. Video file, video capture, video streaming."
msgstr "images animées. Fichier vidéo, capture vidéo, streaming vidéo."

#: ../../manual/game_engine/python_api/videotexture.rst:152
msgid "``ImageFFmpeg``"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:151
msgid "Still pictures. Image file, image on web."
msgstr "Images fixes. Fichier image, image sur le web."

#: ../../manual/game_engine/python_api/videotexture.rst:156
msgid "``ImageBuff``"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:155
msgid ""
"Image from application memory. For computer generated images, drawing "
"applications."
msgstr ""
"Image depuis la mémoire de l'application. Pour les images générées par "
"ordinateur, les applications de dessin."

#: ../../manual/game_engine/python_api/videotexture.rst:159
msgid "``ImageViewport``"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:159
msgid ""
"Part or whole of the viewport (=rendering of the active camera displayed on "
"screen)."
msgstr ""
"Tout ou partie de la vue (= rendu de la caméra active affichée à l'écran)."

#: ../../manual/game_engine/python_api/videotexture.rst:162
msgid "``ImageRender``"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:162
msgid "Render of a non-active camera."
msgstr "Rendu d'une caméra non active."

#: ../../manual/game_engine/python_api/videotexture.rst:165
msgid "``ImageMix``"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:165
msgid "A mix of two or more of the above sources."
msgstr "Un mélange de deux ou plus des sources ci-dessus."

#: ../../manual/game_engine/python_api/videotexture.rst:167
msgid ""
"In this example we use a simple video file as source. The ``VideoFFmpeg`` "
"constructor takes a file name as argument. To avoid any confusion with the "
"location of the file, we will use ``GameLogic.expandPath()`` to build an "
"absolute file name, assuming the video file is in the same directory as the "
"blend-file::"
msgstr ""
"Dans cet exemple nous utilisons un simple fichier vidéo comme source. Le "
"constructeur ``VideoFFmpeg`` prend un nom de fichier comme argument. Pour "
"éviter toute confusion avec l'emplacement du fichier, nous utiliserons "
"``GameLogic.expandPath ()`` pour construire un nom de fichier absolu, en "
"supposant que le fichier vidéo est dans le même dossier que le fichier "
"blend::"

#: ../../manual/game_engine/python_api/videotexture.rst:177
msgid ""
"We create the video source object and assign it to the ``Texture`` object "
"``source`` attribute to set the source and make it persistent: as the "
"``Texture`` object is persistent, the source object will also be persistent."
msgstr ""
"Nous créons l'objet source vidéo et l'assignons à l'attribut ``source`` de "
"l'objet ``Texture`` pour définir la source et la rendre persistante : comme "
"l'objet ``Texture`` est persistant, l'objet source sera aussi persistant."

#: ../../manual/game_engine/python_api/videotexture.rst:181
msgid ""
"Note that we can change the ``Texture`` source at any time. Suppose we want "
"to switch between two movies during the game."
msgstr ""
"Notez que nous pouvons modifier la source ``Texture`` à tout moment. "
"Supposez que nous voulons échanger les deux films durant le jeu."

#: ../../manual/game_engine/python_api/videotexture.rst:184
msgid "We can do the following::"
msgstr "Nous pouvons faire ce qui suit::"

#: ../../manual/game_engine/python_api/videotexture.rst:189
msgid "And then assign (and reassign) the source during the game::"
msgstr "Et ensuite assigner (et réassigner) la source durant le jeu::"

#: ../../manual/game_engine/python_api/videotexture.rst:195
msgid "Setup the Source"
msgstr "Installation de la source"

#: ../../manual/game_engine/python_api/videotexture.rst:197
msgid ""
"The ``VideoFFmpeg`` source has several attributes to control the movie "
"playback:"
msgstr ""
"La source ``VideoFFmpeg`` a plusieurs attributs pour contrôler la lecture "
"vidéo :"

#: ../../manual/game_engine/python_api/videotexture.rst:202
msgid "``range``"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:200
msgid ""
"[start,stop] (floats). Set the start and stop time of the video playback, "
"expressed in seconds from beginning. By default the entire video."
msgstr ""
"[start,stop] (flottants). Définissez les heures de début et de fin de la "
"lecture vidéo, exprimés en secondes depuis le début de la vidéo. Par début, "
"la vidéo en entier."

#: ../../manual/game_engine/python_api/videotexture.rst:206
msgid "``repeat``"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:205
msgid "(integer). Number of video replay, -1 for infinite."
msgstr "(entier). Nombre de lectures vidéo. -1 pour infini."

#: ../../manual/game_engine/python_api/videotexture.rst:210
msgid "``framerate``"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:209
msgid "(float). Relative frame rate, <1.0 for slow, >1.0 for fast."
msgstr "(flottant). Fréquence d'images relative, <1.0 pour rapide. "

#: ../../manual/game_engine/python_api/videotexture.rst:218
msgid "``scale``"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:213
msgid ""
"(bool). Set to True to activate fast nearest-neighbor scaling algorithm. "
"Texture width and height must be a power of 2. If the video picture size is "
"not a power of 2, rescaling is required. By default ``bge.texture`` uses the "
"precise but slow ``gluScaleImage()`` function. Best is to rescale the video "
"offline so that no scaling is necessary at run-time!"
msgstr ""
"(booléen). Fixé à *True* pour activer l'algorithme rapide d emise à "
"l'échelle *nearest-neighbor (le plus proche voisin)*. La largeur et la "
"hauteur de texture doivent être des puissances de 2. Si la taille d'image "
"vidéo n'est pas une puissance de 2, la remise à l'échelle est nécessaire. "
"Par défaut  ``bge.texture`` utilise la fonction  ``gluScaleImage()`` précise "
"mais lente. Le mieux est de remettre à l'échelle la vidéo hors ligne afin "
"qu'aucune mise à l'échelle ne soit nécessaire à l'exécution !"

#: ../../manual/game_engine/python_api/videotexture.rst:223
msgid "``flip``"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:221
msgid ""
"(bool). Set to True if the image must be vertically flipped. FFmpeg always "
"delivers the image upside down, so this attribute is set to True by default."
msgstr ""
"(booléen). Fixé à *True* si l'image doit être inversée verticalement. FFmpeg "
"délivre toujours l'image retournée aussi cet attribut est fixé à *True* par "
"défaut."

#: ../../manual/game_engine/python_api/videotexture.rst:229
msgid "``filter``"
msgstr ""

#: ../../manual/game_engine/python_api/videotexture.rst:226
msgid ""
"Set additional filter on the video before sending to GPU. Assign to one of "
"``bge.texture`` filter object. By default the image is send unchanged to the "
"GPU. If an alpha channel is present in the video, it is automatically loaded "
"and sent to the GPU as well."
msgstr ""
"Définir un filtre supplémentaire sur la vidéo avant son envoi vers le GPU. "
"Assignez à un de objets filtres ``bge.texture``. Par défaut l'image est "
"envoyée sans modification au GPU. Si un canal alpha est présent dans la "
"vidéo, il est automatiquement chargé et envoyé de même au GPU."

#: ../../manual/game_engine/python_api/videotexture.rst:231
msgid ""
"We will simply set the ``scale`` attribute to True because the "
"``gluScaleImage()`` is really too slow for real-time video. In case the "
"video dimensions are already a power of 2, it has no effect. ::"
msgstr ""
"Nous allons simplement mettre l'attribut ``scale`` à *True* parce que "
"``gluScaleImage ()`` est vraiment trop lent pour une vidéo en temps réel. "
"Dans le cas où les dimensions vidéo sont déjà une puissance de 2, il n'a "
"aucun effet. ::"

#: ../../manual/game_engine/python_api/videotexture.rst:239
msgid "Play the Video"
msgstr "Lecture de la vidéo"

#: ../../manual/game_engine/python_api/videotexture.rst:241
msgid "We are now ready to play the video::"
msgstr "Nous sommes maintenant prêts à lire la vidéo :"

#: ../../manual/game_engine/python_api/videotexture.rst:245
msgid ""
"Video playback is not a background process: it happens only when we refresh "
"the texture. So we must have another script that runs on every frame and "
"calls the ``refresh()`` method of the ``Texture`` object::"
msgstr ""
"La lecture vidéo n'est pas un processus d'arrière-plan : il se passe "
"seulement quand nous actualisons la texture. Aussi nous devons avoir un "
"autre script qui fonctionne sur chaque trame et appelle la méthode "
"``refresh()`` de l'objet ``Texture`` ::"

#: ../../manual/game_engine/python_api/videotexture.rst:252
msgid ""
"If the video source is stopped, ``refresh()`` has no effect. The argument of "
"``refresh()`` is a flag that indicates if the texture should be recalculated "
"on next refresh. For video playback, you definitively want to set it to True."
msgstr ""
"Si la source vidéo est arrêtée, ``refresh()`` n'a pas d'effet, L'argument de "
"``refresh()`` est un drapeau qui indique si la texture devrait être "
"recalculée au prochain rafraîchissement. Pour la lecture vidéo, vous voudrez "
"certainement le mettre à *True*. "

#: ../../manual/game_engine/python_api/videotexture.rst:259
msgid "Checking the Video Status"
msgstr "Vérification du statut de la vidéo"

#: ../../manual/game_engine/python_api/videotexture.rst:261
msgid ""
"Video source classes (such as VideoFFMpeg) have an attribute ``status``. If "
"video is playing, its value is 2, if it's stopped, it's 3. So in our "
"example::"
msgstr ""
"Les classes de source vidéo (telle que VideoFFMpeg) ont  un attribut "
"``status``. Si la lecture vidéo est en cours, sa valeur est 2, si elle est "
"arrêtée, c'est 3. Aussi dans notre exemple :"

#: ../../manual/game_engine/python_api/videotexture.rst:270
msgid "Advanced Workflow"
msgstr "Flux de travail avancé"

#: ../../manual/game_engine/python_api/videotexture.rst:272
msgid ""
"True argument in ``Texture.refresh()`` method simply invalidates the image "
"buffer after sending it to the GPU so that on next frame, a new image will "
"be loaded from the source. It has the side effect of making the image "
"unavailable to Python. You can also do it manually by calling the "
"``refresh()`` method of the source directly."
msgstr ""
"L'argument *True* dans la méthode ``Texture.refresh()`` invalide simplement "
"le tampon d'image après son envoi vers le GPU de sorte que sur la trame "
"suivante, une nouvelle image sera chargée depuis la source. Il a l'effet "
"indésirable de rendre l'image indisponible à Python. Vous pouvez aussi le "
"faire manuellement en appelant directement la méthode ``refresh()`` de la "
"source."

#: ../../manual/game_engine/python_api/videotexture.rst:277
msgid "Here are some possible advanced workflow:"
msgstr "Voici certaines possibilités de flux de travail avancés :"

#: ../../manual/game_engine/python_api/videotexture.rst:279
msgid "Use the image buffer in Python (does not effect the Texture)::"
msgstr "Utiliser le tampon d'image dans Python (n'affecte pas la Texture) :"

#: ../../manual/game_engine/python_api/videotexture.rst:288
msgid "Load image from source for Python processing without download to GPU:"
msgstr ""
"Charger l'image depuis la source pour le traitement avec Python sans "
"chargement vers le GPU : "

#: ../../manual/game_engine/python_api/videotexture.rst:289
msgid "Note that we do not even call refresh on the Texture."
msgstr "Notez que nous n'appelons même pas d'actualisation de la Texture. "

#: ../../manual/game_engine/python_api/videotexture.rst:290
msgid "We could also just create a source object without a Texture object::"
msgstr "Vous pourrions aussi créer un objet source sans objet Texture :"

#: ../../manual/game_engine/python_api/videotexture.rst:296
msgid ""
"If you have more than one material on the mesh and you want to modify a "
"texture of one particular material, get its ID::"
msgstr ""
"Si vous avez plus d'un matériau sur le mesh et que vous voulez modifier une "
"texture d'un matériau particulier, récupérez son ID :"

#: ../../manual/game_engine/python_api/videotexture.rst:301
msgid ""
"GLSL material can have more than one texture channel, identify the texture "
"by the texture slot where it is defined, here two::"
msgstr ""
"Le matériau GLSL peut avoir plus d'un canal de texture, identifiez la "
"texture par le slot de texture où elle est définie, ici deux :"

#: ../../manual/game_engine/python_api/videotexture.rst:308
msgid "Advanced Demos"
msgstr "Démos avancées"

#: ../../manual/game_engine/python_api/videotexture.rst:310
msgid ""
"Here is a `demo <http://www.graphicall.org/ftp/ben2610/"
"VideoTextureDemo2video.blend>`__ that demonstrates the use of two videos "
"alternatively on the same texture. Note that it requires an additional video "
"file which is the *Elephant Dream* teaser. You can replace it with another "
"file that you want to run the demo."
msgstr ""
"Voici une `démo <http://www.graphicall.org/ftp/ben2610/"
"VideoTextureDemo2video.blend>`__ qui montre l'utilisation de deux vidéos "
"alternativement sur la même texture. Notez qu'elle nécessite un fichier "
"vidéo supplémentaire qui est la bande-annonce de *Elephant Dream*. Vous "
"pouvez le remplacer par un autre fichier dont vous voulez lancer la démo."

#: ../../manual/game_engine/python_api/videotexture.rst:315
msgid ""
"Here is a `demo <http://www.graphicall.org/ftp/ben2610/"
"VideoTextureDemo2videoMix.blend>`__ that demonstrates the use of the "
"``ImageMix`` source. ``ImageMix`` is a source that needs sources, which can "
"be any other ``Texture`` source, like ``VideoFFmpeg``, ``ImageFFmpeg`` or "
"``ImageRender``. You set them with ``setSource()`` and their relative weight "
"with ``setWeight()``. Pay attention that the weight is a short number "
"between 0 and 255, and that the sum of all weights should be 255. "
"``ImageMix`` makes a mix of all the sources according to their weights. The "
"sources must all have the same image size (after reduction to the nearest "
"power of two dimension). If they do not, you will get a Python error on the "
"console."
msgstr ""
"Voici une `démo <http://www.graphicall.org/ftp/ben2610/"
"VideoTextureDemo2videoMix.blend>`__ qui montre l'utilisation de la source "
"``ImageMix``. ``ImageMix``est une source qui nécessite des sources, qui "
"peuvent être n'importe quelle autre source ``Texture``, comme "
"``VideoFFmpeg``, ``ImageFFmpeg`` ou ``ImageRender``. Vous les définissez "
"avec ``setSource ()`` et leur poids relatif avec ``setWeight()``. Faites "
"attention au fait que le poids est un nombre entre 0 et 255, et que la somme "
"de tous les poids devrait être 255. ``ImageMix`` fait un mélange de tous les "
"sources selon leurs poids. Les sources doivent avoir la même taille d'image "
"(après réduction de la dimension à la puissance de deux la plus proche). Si "
"cette condition n'est pas remplie, vous obtiendrez une erreur Python sur la "
"console."

#~ msgid ""
#~ "Video playback is not a background process: it happens only when we "
#~ "refresh the texture. So we must have another script that runs on every "
#~ "frame and calls the ``refresh ()`` method of the ``Texture`` object::"
#~ "Video playback is not a background process: it happens only when we "
#~ "refresh the texture. So we must have another script that runs on every "
#~ "frame and calls the ``refresh ()`` method of the ``Texture`` object::"
#~ "Video playback is not a background process: it happens only when we "
#~ "refresh the texture. So we must have another script that runs on every "
#~ "frame and calls the ``refresh()`` method of the ``Texture`` object::"
#~ msgstr ""
#~ "La lecture vidéo n'est pas un processus en arrière-plan : elle se produit "
#~ "seulement quand nous rafraîchissons la texture. Aussi nous devons avoir "
#~ "un autre script qui se lance à chaque frame et appelle la méthode "
#~ "``refresh ()`` de l'objet ``Texture``::"
