# SOME DESCRIPTIVE TITLE.
# Copyright (C) : This page is public domain as CC0
# This file is distributed under the same license as the Blender Reference
# Manual package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
# phan <phahoatho@gmail.com>, 2017, 2018.
#
msgid ""
msgstr ""
"Project-Id-Version: Blender Reference Manual 2.76\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-24 22:17+1100\n"
"PO-Revision-Date: 2018-03-02 06:38+0100\n"
"Last-Translator: phan <phahoatho@gmail.com>\n"
"Language-Team: français <bf-docboard@blender.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.3\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Gtranslator 2.91.6\n"

#: ../../manual/compositing/types/converter/math.rst:11
msgid "Math Node"
msgstr "Node Math"

#: ../../manual/compositing/types/converter/math.rst:16
msgid "Math node."
msgstr "Node Math."

#: ../../manual/compositing/types/converter/math.rst:18
msgid "The *Math Node* performs math operations."
msgstr "Le *Node Math* effectue des opérations mathématiques."

#: ../../manual/compositing/types/converter/math.rst:22
msgid "Inputs"
msgstr "Entrées"

#: ../../manual/compositing/types/converter/math.rst:25
#: ../../manual/compositing/types/converter/math.rst:31
#: ../../manual/compositing/types/converter/math.rst:48
msgid "Value"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:25
msgid ""
"First numerical value. The trigonometric functions accept values in radians."
msgstr ""
"Première valeur numérique. Les fonctions trigonométriques acceptent des "
"valeurs en radians."

#: ../../manual/compositing/types/converter/math.rst:28
msgid ""
"Second numerical value. This value is **not** used in functions that accept "
"only one parameter like the trigonometric functions, Round and Absolute."
msgstr ""
"Seconde valeur numérique. Cette valeur n'est **pas** utilisée dans les "
"fonctions qui acceptent seulement un paramètre  comme les fonctions "
"trigonométriques, Round et Absolute."

#: ../../manual/compositing/types/converter/math.rst:34
msgid "Properties"
msgstr "Propriétés"

#: ../../manual/compositing/types/converter/math.rst:37
msgid "Operation"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:37
msgid ""
"Add, Subtract, Multiply, Divide, Sine, Cosine, Tangent, Arcsine, Arccosine, "
"Arctangent, Power, Logarithm, Minimum, Maximum, Round, Less Than, Greater "
"Than, Modulo, Absolute."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:41
msgid "Clamp"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:40
msgid "Limits the output to the range (0 to 1). See :term:`clamp`."
msgstr "Borde la sortie dasn l'intervalle (0 à 1). Voir :term:`clamp`."

#: ../../manual/compositing/types/converter/math.rst:44
msgid "Outputs"
msgstr "Sorties"

#: ../../manual/compositing/types/converter/math.rst:47
msgid "Numerical value output."
msgstr "Sortie de valeur numérique."

#: ../../manual/compositing/types/converter/math.rst:51
msgid "Examples"
msgstr "Exemples"

#: ../../manual/compositing/types/converter/math.rst:54
msgid "Manual Z-Mask"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:58
msgid "Example."
msgstr "Exemples"

#: ../../manual/compositing/types/converter/math.rst:60
#, fuzzy
msgid ""
"This example has one scene input by the top *Render Layer* node, which has a "
"cube that is about 10 BU from the camera. The bottom Render Layer node "
"inputs a scene (FlyCam) with a plane that covers the left half of the view "
"and is 7 BU from the camera. Both are fed through their respective Map Value "
"nodes to divide the Z buffer by 20 (multiply by 0.05, as shown in the Size "
"field) and clamped to be a min/ max of 0.0/ 1.0 respectively."
msgstr ""
"Cet exemple a une entrée de scène par le node *Render Layer* du haut, qui a "
"un cube qui est environ à 10 BU de la caméra. Le node *Render Layer* du bas "
"entre une scène (FlyCam) avec un plan qui couvre la moitié gauche de la vue "
"et est à 7 BU de la caméra. Les deux sont alimentés via leurs nodes *Map "
"Value* respectifs pour diviser le tampon Z par 20 (multiplier par 0.05, "
"comme montré dans le champ *Size*) et borné min/max de 0.0/ 1.0 "
"respectivement."

#: ../../manual/compositing/types/converter/math.rst:68
#, fuzzy
msgid ""
"For the minimum function, the node selects those Z values where the "
"corresponding pixel is closer to the camera; so it chooses the Z values for "
"the plane and part of the cube. The background has an infinite Z value, so "
"it is clamped to 1.0 (shown as white). In the maximum example, the Z values "
"of the cube are greater than the plane, so they are chosen for the left "
"side, but the plane (FlyCam) Render layers Z are infinite (mapped to 1.0) "
"for the right side, so they are chosen."
msgstr ""
"Pour la fonction *minimum*, le node sélectionne ces valeurs Z où le pixel "
"correspondant est plus proche de la caméra ; ainsi il choisit les valeurs Z "
"pour le plan et une partie du cube. L'arrière-plan a une valeur Z infinie, "
"aussi il est à 1.0 (affiché en blanc). Dans l'exemple *maximum*, les valeurs "
"Z du cube sont supérieures à celles du plan, aussi elles sont choisies pour "
"le côté gauche, mais le plan (FlyCam) sont infinies (correspond à 1.0) pour "
"le côté droit, raison pour laquelle elles sont choisies."

#: ../../manual/compositing/types/converter/math.rst:78
msgid "Using Sine Function to Pulsate"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:82
#: ../../manual/compositing/types/converter/math.rst:94
#, fuzzy
msgid ""
"Use this function to vary, for example, the alpha channel of an image to "
"produce a fading in/out effect. Alter the Z channel to move a scene in/out "
"of focus. Alter a color channel value to make a color \"pulse\"."
msgstr ""
"Utilisez cette fonction pour varier, par exemple, le canal alpha d'une image "
"pour produire un effet de fusion . Altérez la canal Z pour déplacer une "
"scène dans/hors du focus. Altérez une valeur de canal de couleur \"pulse\"."

#: ../../manual/compositing/types/converter/math.rst:101
msgid "Brightening/Scaling a Channel"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:105
msgid ""
"This example has a *Math: Multiply* node increasing the luminance channel "
"(Y) of the image to make it brighter. Note that you should use a *Map Value "
"node* with min() and max() enabled to clamp the output to valid values. With "
"this approach, you could use a logarithmic function to make a high-dynamic "
"range image. For this particular example, there is also a *Brighten/Contrast "
"node* that might give simpler control over brightness."
msgstr ""
"Cet exemple a un node *Math: Multiply* augmentant la canal luminance (Y) de "
"l'image pour la rendre plus claire. Notez que vous devriez utiliser un *node "
"Map Value* avec min() and max() activés pour borner la sortie aux valeurs "
"valides. Avec cette approche, vous pourriez utiliser une fonction "
"logarithmique pour construire une image à palette hautement dynamique. Pour "
"cet exemple particulier, il y a aussi un *node Brighten/Contrast* qui "
"pourrait offrir un contrôle plus simple sur la clarté."

#: ../../manual/compositing/types/converter/math.rst:114
msgid "Quantize/Restrict Color Selection"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:116
#, fuzzy
msgid ""
"In this example, we want to restrict the color output to only 256 possible "
"values. Possible use of this is to see what the image will look like on an 8-"
"bit cell phone display. To do this, we want to restrict the R, G and B "
"values of any pixel to be one of a certain value, such that when they are "
"combined, will not result in more than 256 possible values. The number of "
"possible values of an output is the number of channel values multiplied by "
"each other, or Q = R × G × B."
msgstr ""
"Dans cet exemple, nous voulons restreindre la sortie de couleur à seulement "
"256 valeurs possibles, Une utilisation possible de ceci est de voir à quoi "
"l'image va ressembler sur un écran 8 bits de téléphone portable. Pour ce "
"faire, nous voulons restreindre les valeurs R, G et B de chaque pixel à une "
"certaine valeur, de sorte que quand elles sont combinées, ne produiront pas "
"plus que 256 valeurs possibles. Le nombre de valeurs possibles d'une sortie "
"est le nombre de valeurs de canal multiplié par l'un l'autre, ou Q = R × G × "
"B."

#: ../../manual/compositing/types/converter/math.rst:123
#: ../../manual/compositing/types/converter/math.rst:135
msgid "Theory"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:137
msgid ""
"`Two Approaches to Quantizing to six values <https://wiki.blender.org/index."
"php/File:Manual-Compositing-Node-Math_ColorBand>`__."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:140
msgid ""
"To accomplish this quantization of an image to 256 possible values, let us "
"use the set {6, 6, 7}. To split up a continuous range of values between 0 "
"and 1 (the full Red spectrum) into six values, we need to construct an "
"algorithm or function that takes any input value but only puts out six "
"possible values, as illustrated by the image to the right. We want to "
"include zero as true black, with five other colors in between. The approach "
"shown produces {0, 0.2, 0.4, 0.6, 0.8, 1}. Dividing 1.0 by 5 equals 0.2, "
"which tells how far apart each quantified value is from the other."
msgstr ""
"Pour effectuer cette quantification d'une image en 256 valeurs possibles, "
"utilisons l'ensemble {6, 6, 7}. Pour diviser un intervalle continu de "
"valeurs entre 0 et 1 (le spectre Rouge complet) en six valeurs, nous devons "
"construire un algorithme ou une fonction qui prend toute valeur d'entrée "
"mais sort seulement six valeurs possibles, comme illustré par l'image de "
"droite. Nous voulons inclure zéro comme noir véritable, avec cinq autres "
"valeurs entre. L'approche affichée produit {0, 0.2, 0.4, 0.6, 0.8, 1}. La "
"division de 1.0 par 5 est égale à 0.2, qui représente la distance entre "
"chaque valeur de quantification.  "

#: ../../manual/compositing/types/converter/math.rst:148
msgid ""
"So, to get good even shading, we want to take values that are 0.16 or less "
"and map them to 0.0; values between 0.16 and 0.33 get fixed to 0.2; color "
"values between 0.33 and 0.5 get quantized to 0.4, and so on up to values "
"between 0.83 and 1.0 get mapped to 1.0."
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:154
msgid "Function f(x)"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:156
msgid ""
"An algebraic function is made up of primitive mathematical operations (add, "
"subtract, multiply, sine, cosine, etc.) that operate on an input value to "
"provide the desired output value."
msgstr ""
"Une fonction algébrique est faite d'opérations mathématiques primaires "
"(addition, soustraction, multiplication, sinus, cosinus, etc.) qui opèrent "
"sur une valeur d'entrée pour produire la valeur de sortie souhaitée. "

#: ../../manual/compositing/types/converter/math.rst:160
msgid ""
"`Spreadsheet showing a function <https://wiki.blender.org/index.php/File:"
"Manual-Compositing-Node-Math_spreadsheet>`__."
msgstr ""
"`Feuille de calcul montrant une fonction <https://wiki.blender.org/index.php/"
"File:Manual-Compositing-Node-Math_spreadsheet>`__."

#: ../../manual/compositing/types/converter/math.rst:163
msgid ""
"The theory behind this function is scaled truncation. Suppose we want a math "
"function that takes in a range of values between 0 and 1, such as 0.552, but "
"only outputs a value of 0.0, 0.2, 0.4, etc. We can imagine then that we need "
"to get that range 0 to 1 powered up to something 0 to 6 so that we can chop "
"off and make it a whole number. So, with six divisions, how can we do that? "
"The answer is we multiply the range by 6. The output of that first math "
"Multiply Node is a range of values between 0 and 6. To get even divisions, "
"because we are using the rounding function (see documentation above), we "
"want any number plus or minus around a whole number will get rounded to that "
"number. So, we subtract a half, which shifts everything over. The round() "
"function then makes that range 0 to 5. We then divide by 5 to get back a "
"range of numbers between 0 and 1 which can then be combined back with the "
"other color channels. Thus, you get the function :math:`f(x, n) = round(x × "
"n - 0.5)/ (n - 1)` where \"n\" is the number of possible output values, and "
"\"x\" is the input pixel color and :math:`f(x, n)` is the output value. "
"There is only one slight problem, and that is for the value exactly equal to "
"1, the formula result is 1.2, which is an invalid value. This is because the "
"round function is actually a roundup function, and exactly 5.5 is rounded up "
"to 6. So, by subtracting 0.501, we compensate and thus 5. 499 is rounded to "
"5. At the other end of the spectrum, pure black, or 0, when 0.501 "
"subtracted, rounds up to 0 since the Round() function does not return a "
"negative number."
msgstr ""
"La théorie derrière cette fonction est la troncation . Supposons que nous "
"voulons une fonction mathématique qui prenne un intervalle entre 0 et 1, tel "
"que 0.552, mais sort seulement une valeur de 0.0, 0.2, 0.4, etc. Nous "
"pouvons imaginer alors que nous devons obtenir l'intervalle 0 à 1 levé à la "
"puissance 0 à 6 de sorte que nous pouvons et en faire u n nombre entier. "
"Aussi, avec six divisions,comment pouvons-nous faire cela ? la réponse est "
"que nous multiplions l'intervalle par 6. La sortie de ce premier Node math "
"Multiply est un intervalle de valeurs entre 0 et 6. Pour obtenir des "
"divisions paires, parce que nous utilisons la fonction d'arrondi (voir la "
"documentation ci-dessus), nous voulons que tout nombre plus ou moins autour "
"d'un nombre entier soit arrondi à ce nombre. Aussi, nous soustrayons un "
"demi, ce qui va tout décaler. La fonction round() qui  Nous divisons alors "
"par 5 pour revenir sur un intervalle de nombres entre 0 et 1 qui peut être "
"combiné avec les autres canaux de couleur. Ainsi,vous obtenez la fonction :"
"math:`f(x, n) = round(x × n - 0.5)/ (n - 1)` où \"n\" est le nombre de "
"valeurs de sortie possibles, et \"x\" est la couleur de pixel d'entrée et :"
"math:`f(x, n)` est la valeur de sortie. Seulement il y a un petit problème, "
"et c'est la valeur exactement à 1, le résultat de la formule est 1.2, qui "
"est une valeur invalide. C'est à cause de la fonction round es en réalité "
"une fonction , et exactement 5.5 est arrondi à 6. Aussi, en soustrayant "
"0.501, nous compensons et ainsi 5.499 est arrondi à 5. À l'autre bout du "
"spectre, le noir pur, ou 0, quand 0.501 est soustrait, arrondi à 0 puisque "
"la fonction Round() ne retourne pas de valeur négative."

#: ../../manual/compositing/types/converter/math.rst:185
#, fuzzy
msgid ""
"Sometimes using a spreadsheet can help you figure out how to put these nodes "
"together to get the result that you want. Stepping you through the formula "
"for :math:`n = 6` and :math:`x = 0.70`, locate the line on the spreadsheet "
"that has the 8-bit value 179 and R value 0.7. Multiplying by 6 gives 4.2. "
"Subtracting 1/2 gives 3.7, which rounds up to 4.4 divided by 5 = 0.8. Thus, "
"f(0.7, 6) = 0.8 or an 8-bit value of 204. You can see that this same 8-bit "
"value is output for a range of input values."
msgstr ""
"Parfois l'utilisation d'un feuille de tableur peut vous aider à déterminer "
"la manière de mettre ces nodes ensemble pour obtenir le résultat que vous "
"voulez. En parcourant la formule pour :math:`n = 6` et :math:`x = 0.70`, "
"localisez la ligne sur la feuille du tableur qui a une valeur de 8 bits de "
"179 et R valeur de 0.7. La multiplication par 6 donne 4.2. La soustraction "
"de 1/2 donne 3.7, ce qui s'arrondit à 4.4 divisé par 5 = 0.8. Ainsi, f(0.7, "
"6) = 0.8 ou une valeur 8 bits de 204. Vous pouvez voir que cette même valeur "
"8 bits est sortie pour  un intervalle de valeurs de sortie.  "

#: ../../manual/compositing/types/converter/math.rst:194
msgid "Reality"
msgstr ""

#: ../../manual/compositing/types/converter/math.rst:196
#, fuzzy
msgid ""
"To implement this function in Blender, consider the node setup above. First, "
"feed the image to the Separate RGB node. For the Red channel, we string the "
"math nodes into a function that takes each red color, multiplies (scales) it "
"up by the desired number of divisions (6), offsets it by 0.5, rounds the "
"value to the nearest whole number, and then divides the image pixel color by "
"5. So, the transformation is {0 to 1} becomes {0 to 6}, subtracting centers "
"the medians to {-0.5 to 5.5} and the rounding to the nearest whole number "
"produces {0, 1, 2, 3, 4, 5} since the function rounds down, and then "
"dividing by five results in six values {0.0, 0.2, 0.4, 0.6, 0.8, 1.0}."
msgstr ""
"Pour implémenter cette fonction dans Blender, observez la configuration du "
"node ci-dessus. D'abord, alimentez l'image au node *Separate RGB*. Pour le "
"canal Rouge, nous enfilons les nodes *math* dans une fonction qui prend "
"chaque couleur rouge, la multiplie (mise à l'échelle) par le nombre désiré "
"de divisions (6),   , arrondit la valeur au nombre entier le plus proche, et "
"puis divise la couleur de pixel d'image par 5. Ainsi, la transformation est "
"{0 à 1} devient {0 à 6}, en soustrayant aux centres les médianes à {-0.5 à "
"5.5} et l'arrondi au nombre entier le plus proche produit {0, 1, 2, 3, 4, 5} "
"puisque la fonction arrondit , et ensuite en divisant par cinq produit six "
"valeurs {0.0, 0.2, 0.4, 0.6, 0.8, 1.0}."

#: ../../manual/compositing/types/converter/math.rst:206
msgid ""
"The result is that the output value can only be one of a certain set of "
"values, stair-stepped, because of the rounding function of the math node. "
"Copying this one channel to operate on Green and Blue gives the node setup "
"below. To get the 6:6:7, we set the three Multiply Nodes to {6, 6, 7} and "
"the divide nodes to {5, 5, 6}."
msgstr ""
"Le résultat est que la valeur de sortie peut seulement être une valeur parmi "
"un certain ensemble de valeurs, en marches d'escalier, à cause de la "
"fonction rounding (arrondi) du node math.   Pour obtenir 6:6:7, nous fixons "
"les trois Nodes Multiply à {6, 6, 7} et les nodes divide à {5, 5, 6}."

#: ../../manual/compositing/types/converter/math.rst:213
msgid ""
"If you make this into a node group, you can easily reuse this setup from "
"project to project. When you do, consider using a math node to drive the "
"different values that you would have to otherwise set manually, just to "
"error-proof your work."
msgstr ""
"Si vous faites ceci dans un groupe de nodes, vous pouvez facilement "
"réutiliser cette configuration de projet en projet. En faisant cela, "
"l'utilisation d'un node math pour contrôler les différentes valeurs que vous "
"auriez autrefois définies manuellement, pour éviter des erreurs dans votre "
"travail."

#: ../../manual/compositing/types/converter/math.rst:219
msgid "Summary"
msgstr "Résumé"

#: ../../manual/compositing/types/converter/math.rst:221
#, fuzzy
msgid ""
"Normally, an output render consists of 32- or 24-bit color depth, and each "
"pixel can be one of the millions of possible colors. This node setup example "
"takes each of the Red, Green and Blue channels and normalizes them to one of "
"a few values. When all three channels are combined back together, each color "
"can only be one of 256 possible values."
msgstr ""
"Normalement, un rendu de sortie consiste en une profondeur de couleur de 32 "
"ou 44 bits, et chaque peut être une couleur parmi des millions possibles. "
"Cet exemple de configuration de nodes prend chacun des canaux Rouge, Vert, "
"Bleu et les normalise à une des valeurs. Quand les trois canaux sont "
"recombinés ensemble, chaque couleur peut seulement être une des 256 valeurs "
"possibles."

#: ../../manual/compositing/types/converter/math.rst:228
msgid ""
"While this example uses the Separate/Combine RGB to create distinct colors, "
"other Separate/Combine nodes can be used as well. If using the YUV values, "
"remember that U and V vary between (-0.5 to +0.5), so you will have to first "
"add on a half to bring the range between 0 and 1, and then after dividing, "
"subtract a half to bring in back into standard range."
msgstr ""
"Alors que cet exemple utilise le *node Separate/Combine RGB* pour créer des "
"couleurs distinctes, d'autres nodes Separate/Combine peuvent aussi être "
"utilisés. Si les valeurs YUV sont utilisées, rappelez que U and V varient "
"entre (-0.5 et +0.5), aussi vous devez d'abord ajouter un demi pour amener "
"l'intervalle entre 0 et 1, et ensuite, après la division, soustraire un demi "
"pour le ramener dans l'intervalle standard. "

#: ../../manual/compositing/types/converter/math.rst:234
msgid ""
"The ``JPG`` or ``PNG`` image format will store each of the colors according "
"to its image standard for color depth (e.g. ``JPG`` is 24-bit), but the "
"image will be very small since reducing color depth and quantizing colors "
"are essentially what the ``JPEG`` compression algorithm accomplishes."
msgstr ""
"le format d'image ``JPG`` ou ``PNG`` va enregistrer chacune des couleurs "
"selon son standard d'image pour la profondeur de couleur (ex. ``JPG`` est à "
"24-bit), mais l'image sera très petite puisque la réduction de la profondeur "
"de couleur et la quantification des couleurs sont essentiellement ce "
"qu'accomplit l'algorithme de compression ``JPEG``. "

#: ../../manual/compositing/types/converter/math.rst:239
#, fuzzy
msgid ""
"You do not have to reduce the color depth of each channel evenly. For "
"example, if blue was the dominant color in an image, to preserve image "
"quality, you could reduce Red to 2 values, Green to 4, and let the blue take "
"on :math:`256/(2 × 4)` or 32 values. If using the HSV, you could reduce the "
"Saturation and Value to 2 values (0 or 1.0) by Multiply by 2 and Divide by "
"2, and restrict the Hue to 64 possible values."
msgstr ""
"Vous n'avez pas à réduire uniformément la profondeur de couleur de chaque "
"canal. Par exemple, si le Bleu est la couleur dominante d'une image, pour "
"préserver la qualité de l'image, vous pourriez réduire le Rouge à 2 valeurs, "
"le Vert à 4, et laisser le Bleu prendre :math:`256/(2 × 4)` ou 32 valeurs. "
"Si *HSV* est utilisé, vous pourriez réduire la *Saturation* et la *Value* à "
"2 valeurs (0.0 ou 1.0)    , et restreindre le *Hue* à 64 valeurs possibles."

#: ../../manual/compositing/types/converter/math.rst:245
msgid ""
"You can use this node setup to quantize any channel; alpha, speed (vector), "
"z-values, and so forth."
msgstr ""
"Vous pouvez utiliser cette configuration de nodes pour quantifier un canal ; "
"alpha, vitesse (vecteur), valeur Z, etc."
